import {
  Box_default,
  Button_default,
  ClickAwayListener,
  Collapse_default,
  DialogActions_default,
  Divider_default,
  Fade_default,
  Link_default,
  MenuItem_default,
  Paper_default,
  Popper_default,
  Select_default,
  Stack_default,
  TextField_default,
  ToggleButton_default,
  Tooltip_default,
  Typography_default,
  outlinedInputClasses_default,
  selectClasses_default,
  toggleButtonClasses_default
} from "./chunk-M7MXCZRP.js";
import {
  Decoration,
  DecorationSet,
  Editor,
  Extension,
  Fragment,
  Heading,
  InputRule,
  Node3,
  NodeSelection,
  NodeView,
  Plugin,
  PluginKey,
  Selection,
  SelectionRange,
  Slice,
  TextSelection,
  Transform,
  callOrReturn,
  findParentNodeClosestToPos,
  getAttributes,
  getExtensionField,
  getMarkRange,
  getMarkType,
  getNodeType,
  getRenderedAttributes,
  getSchemaTypeNameByName,
  getText,
  getTextSerializersFromSchema,
  isNodeSelection,
  keydownHandler,
  mergeAttributes,
  nodeInputRule,
  posToDOMRect
} from "./chunk-NXS7P5DW.js";
import {
  require_react_dom
} from "./chunk-NUMECXU6.js";
import "./chunk-C6WWHQR7.js";
import {
  __unsafe_useEmotionCache,
  alpha,
  createSvgIcon,
  darken,
  getRegisteredStyles,
  insertStyles,
  keyframes,
  lighten,
  rgbToHex,
  serializeStyles,
  svgIconClasses_default,
  useTheme
} from "./chunk-E7UWZ623.js";
import {
  require_jsx_runtime
} from "./chunk-S725DACQ.js";
import {
  require_react
} from "./chunk-RLJ2RCJQ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports, module) {
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module.exports = arrayMap;
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports, module) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports, module) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module.exports = eq;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports, module) {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports, module) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  }
});

// node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/lodash/_stackClear.js"(exports, module) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module.exports = stackClear;
  }
});

// node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/lodash/_stackDelete.js"(exports, module) {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module.exports = stackDelete;
  }
});

// node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/lodash/_stackGet.js"(exports, module) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module.exports = stackGet;
  }
});

// node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/lodash/_stackHas.js"(exports, module) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module.exports = stackHas;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports, module) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports, module) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports, module) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    module.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports, module) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports, module) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports, module) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module.exports = getNative;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module.exports = Map2;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports, module) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports, module) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports, module) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module.exports = Hash;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports, module) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports, module) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports, module) {
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports, module) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  }
});

// node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/lodash/_stackSet.js"(exports, module) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module.exports = stackSet;
  }
});

// node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/lodash/_Stack.js"(exports, module) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module.exports = Stack;
  }
});

// node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/lodash/_arrayEach.js"(exports, module) {
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    module.exports = arrayEach;
  }
});

// node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/lodash/_defineProperty.js"(exports, module) {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e2) {
      }
    }();
    module.exports = defineProperty;
  }
});

// node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/lodash/_baseAssignValue.js"(exports, module) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    module.exports = baseAssignValue;
  }
});

// node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "node_modules/lodash/_assignValue.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module.exports = assignValue;
  }
});

// node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "node_modules/lodash/_copyObject.js"(exports, module) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    module.exports = copyObject;
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports, module) {
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module.exports = baseTimes;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports, module) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module.exports = isArguments;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    var isArray = Array.isArray;
    module.exports = isArray;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports, module) {
    function stubFalse() {
      return false;
    }
    module.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports, module) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module.exports = isIndex;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module.exports = isLength;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports, module) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    module.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports, module) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports, module) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module.exports = isPrototype;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module.exports = overArg;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports, module) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports, module) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeys;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports, module) {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module.exports = isArrayLike;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module.exports = keys;
  }
});

// node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "node_modules/lodash/_baseAssign.js"(exports, module) {
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    module.exports = baseAssign;
  }
});

// node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "node_modules/lodash/_nativeKeysIn.js"(exports, module) {
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = nativeKeysIn;
  }
});

// node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "node_modules/lodash/_baseKeysIn.js"(exports, module) {
    var isObject = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeysIn;
  }
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "node_modules/lodash/keysIn.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module.exports = keysIn;
  }
});

// node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "node_modules/lodash/_baseAssignIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    module.exports = baseAssignIn;
  }
});

// node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "node_modules/lodash/_cloneBuffer.js"(exports, module) {
    var root = require_root();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    module.exports = cloneBuffer;
  }
});

// node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "node_modules/lodash/_copyArray.js"(exports, module) {
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    module.exports = copyArray;
  }
});

// node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/lodash/_arrayFilter.js"(exports, module) {
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module.exports = arrayFilter;
  }
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/lodash/stubArray.js"(exports, module) {
    function stubArray() {
      return [];
    }
    module.exports = stubArray;
  }
});

// node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/lodash/_getSymbols.js"(exports, module) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module.exports = getSymbols;
  }
});

// node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "node_modules/lodash/_copySymbols.js"(exports, module) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    module.exports = copySymbols;
  }
});

// node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/lodash/_arrayPush.js"(exports, module) {
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module.exports = arrayPush;
  }
});

// node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/lodash/_getPrototype.js"(exports, module) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module.exports = getPrototype;
  }
});

// node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "node_modules/lodash/_getSymbolsIn.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module.exports = getSymbolsIn;
  }
});

// node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "node_modules/lodash/_copySymbolsIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    module.exports = copySymbolsIn;
  }
});

// node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module.exports = baseGetAllKeys;
  }
});

// node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/lodash/_getAllKeys.js"(exports, module) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module.exports = getAllKeys;
  }
});

// node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "node_modules/lodash/_getAllKeysIn.js"(exports, module) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    module.exports = getAllKeysIn;
  }
});

// node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/lodash/_DataView.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView = getNative(root, "DataView");
    module.exports = DataView;
  }
});

// node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/lodash/_Promise.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module.exports = Promise2;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module.exports = Set2;
  }
});

// node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/lodash/_WeakMap.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module.exports = WeakMap2;
  }
});

// node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/lodash/_getTag.js"(exports, module) {
    var DataView = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module.exports = getTag;
  }
});

// node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "node_modules/lodash/_initCloneArray.js"(exports, module) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    module.exports = initCloneArray;
  }
});

// node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/lodash/_Uint8Array.js"(exports, module) {
    var root = require_root();
    var Uint8Array = root.Uint8Array;
    module.exports = Uint8Array;
  }
});

// node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "node_modules/lodash/_cloneArrayBuffer.js"(exports, module) {
    var Uint8Array = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }
    module.exports = cloneArrayBuffer;
  }
});

// node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "node_modules/lodash/_cloneDataView.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module.exports = cloneDataView;
  }
});

// node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "node_modules/lodash/_cloneRegExp.js"(exports, module) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module.exports = cloneRegExp;
  }
});

// node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "node_modules/lodash/_cloneSymbol.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module.exports = cloneSymbol;
  }
});

// node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "node_modules/lodash/_cloneTypedArray.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module.exports = cloneTypedArray;
  }
});

// node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "node_modules/lodash/_initCloneByTag.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    module.exports = initCloneByTag;
  }
});

// node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "node_modules/lodash/_baseCreate.js"(exports, module) {
    var isObject = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module.exports = baseCreate;
  }
});

// node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "node_modules/lodash/_initCloneObject.js"(exports, module) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    module.exports = initCloneObject;
  }
});

// node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "node_modules/lodash/_baseIsMap.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    module.exports = baseIsMap;
  }
});

// node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "node_modules/lodash/isMap.js"(exports, module) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module.exports = isMap;
  }
});

// node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "node_modules/lodash/_baseIsSet.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    module.exports = baseIsSet;
  }
});

// node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "node_modules/lodash/isSet.js"(exports, module) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module.exports = isSet;
  }
});

// node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "node_modules/lodash/_baseClone.js"(exports, module) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    module.exports = baseClone;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module.exports = isSymbol;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports, module) {
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module.exports = isKey;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports, module) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module.exports = memoize;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports, module) {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module.exports = memoizeCapped;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports, module) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    module.exports = stringToPath;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = baseToString;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports, module) {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module.exports = toString;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports, module) {
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    module.exports = castPath;
  }
});

// node_modules/lodash/last.js
var require_last = __commonJS({
  "node_modules/lodash/last.js"(exports, module) {
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : void 0;
    }
    module.exports = last;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports, module) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = toKey;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports, module) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    module.exports = baseGet;
  }
});

// node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "node_modules/lodash/_baseSlice.js"(exports, module) {
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    module.exports = baseSlice;
  }
});

// node_modules/lodash/_parent.js
var require_parent = __commonJS({
  "node_modules/lodash/_parent.js"(exports, module) {
    var baseGet = require_baseGet();
    var baseSlice = require_baseSlice();
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }
    module.exports = parent;
  }
});

// node_modules/lodash/_baseUnset.js
var require_baseUnset = __commonJS({
  "node_modules/lodash/_baseUnset.js"(exports, module) {
    var castPath = require_castPath();
    var last = require_last();
    var parent = require_parent();
    var toKey = require_toKey();
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }
    module.exports = baseUnset;
  }
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/lodash/isPlainObject.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module.exports = isPlainObject;
  }
});

// node_modules/lodash/_customOmitClone.js
var require_customOmitClone = __commonJS({
  "node_modules/lodash/_customOmitClone.js"(exports, module) {
    var isPlainObject = require_isPlainObject();
    function customOmitClone(value) {
      return isPlainObject(value) ? void 0 : value;
    }
    module.exports = customOmitClone;
  }
});

// node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "node_modules/lodash/_isFlattenable.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module.exports = isFlattenable;
  }
});

// node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "node_modules/lodash/_baseFlatten.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module.exports = baseFlatten;
  }
});

// node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  "node_modules/lodash/flatten.js"(exports, module) {
    var baseFlatten = require_baseFlatten();
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }
    module.exports = flatten;
  }
});

// node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "node_modules/lodash/_apply.js"(exports, module) {
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module.exports = apply;
  }
});

// node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "node_modules/lodash/_overRest.js"(exports, module) {
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    module.exports = overRest;
  }
});

// node_modules/lodash/constant.js
var require_constant = __commonJS({
  "node_modules/lodash/constant.js"(exports, module) {
    function constant(value) {
      return function() {
        return value;
      };
    }
    module.exports = constant;
  }
});

// node_modules/lodash/identity.js
var require_identity = __commonJS({
  "node_modules/lodash/identity.js"(exports, module) {
    function identity(value) {
      return value;
    }
    module.exports = identity;
  }
});

// node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "node_modules/lodash/_baseSetToString.js"(exports, module) {
    var constant = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    module.exports = baseSetToString;
  }
});

// node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "node_modules/lodash/_shortOut.js"(exports, module) {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module.exports = shortOut;
  }
});

// node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "node_modules/lodash/_setToString.js"(exports, module) {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module.exports = setToString;
  }
});

// node_modules/lodash/_flatRest.js
var require_flatRest = __commonJS({
  "node_modules/lodash/_flatRest.js"(exports, module) {
    var flatten = require_flatten();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function flatRest(func) {
      return setToString(overRest(func, void 0, flatten), func + "");
    }
    module.exports = flatRest;
  }
});

// node_modules/lodash/omit.js
var require_omit = __commonJS({
  "node_modules/lodash/omit.js"(exports, module) {
    var arrayMap = require_arrayMap();
    var baseClone = require_baseClone();
    var baseUnset = require_baseUnset();
    var castPath = require_castPath();
    var copyObject = require_copyObject();
    var customOmitClone = require_customOmitClone();
    var flatRest = require_flatRest();
    var getAllKeysIn = require_getAllKeysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var omit2 = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });
    module.exports = omit2;
  }
});

// node_modules/encodeurl/index.js
var require_encodeurl = __commonJS({
  "node_modules/encodeurl/index.js"(exports, module) {
    "use strict";
    module.exports = encodeUrl;
    var ENCODE_CHARS_REGEXP = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
    var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
    var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1�$2";
    function encodeUrl(url) {
      return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
    }
  }
});

// node_modules/lodash/_castSlice.js
var require_castSlice = __commonJS({
  "node_modules/lodash/_castSlice.js"(exports, module) {
    var baseSlice = require_baseSlice();
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    module.exports = castSlice;
  }
});

// node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "node_modules/lodash/_hasUnicode.js"(exports, module) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    module.exports = hasUnicode;
  }
});

// node_modules/lodash/_baseIsRegExp.js
var require_baseIsRegExp = __commonJS({
  "node_modules/lodash/_baseIsRegExp.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var regexpTag = "[object RegExp]";
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }
    module.exports = baseIsRegExp;
  }
});

// node_modules/lodash/isRegExp.js
var require_isRegExp = __commonJS({
  "node_modules/lodash/isRegExp.js"(exports, module) {
    var baseIsRegExp = require_baseIsRegExp();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
    module.exports = isRegExp;
  }
});

// node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "node_modules/lodash/_baseProperty.js"(exports, module) {
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    module.exports = baseProperty;
  }
});

// node_modules/lodash/_asciiSize.js
var require_asciiSize = __commonJS({
  "node_modules/lodash/_asciiSize.js"(exports, module) {
    var baseProperty = require_baseProperty();
    var asciiSize = baseProperty("length");
    module.exports = asciiSize;
  }
});

// node_modules/lodash/_unicodeSize.js
var require_unicodeSize = __commonJS({
  "node_modules/lodash/_unicodeSize.js"(exports, module) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    module.exports = unicodeSize;
  }
});

// node_modules/lodash/_stringSize.js
var require_stringSize = __commonJS({
  "node_modules/lodash/_stringSize.js"(exports, module) {
    var asciiSize = require_asciiSize();
    var hasUnicode = require_hasUnicode();
    var unicodeSize = require_unicodeSize();
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    module.exports = stringSize;
  }
});

// node_modules/lodash/_asciiToArray.js
var require_asciiToArray = __commonJS({
  "node_modules/lodash/_asciiToArray.js"(exports, module) {
    function asciiToArray(string) {
      return string.split("");
    }
    module.exports = asciiToArray;
  }
});

// node_modules/lodash/_unicodeToArray.js
var require_unicodeToArray = __commonJS({
  "node_modules/lodash/_unicodeToArray.js"(exports, module) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    module.exports = unicodeToArray;
  }
});

// node_modules/lodash/_stringToArray.js
var require_stringToArray = __commonJS({
  "node_modules/lodash/_stringToArray.js"(exports, module) {
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    module.exports = stringToArray;
  }
});

// node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    module.exports = trimmedEndIndex;
  }
});

// node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "node_modules/lodash/_baseTrim.js"(exports, module) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    module.exports = baseTrim;
  }
});

// node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/lodash/toNumber.js"(exports, module) {
    var baseTrim = require_baseTrim();
    var isObject = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = toNumber;
  }
});

// node_modules/lodash/toFinite.js
var require_toFinite = __commonJS({
  "node_modules/lodash/toFinite.js"(exports, module) {
    var toNumber = require_toNumber();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    module.exports = toFinite;
  }
});

// node_modules/lodash/toInteger.js
var require_toInteger = __commonJS({
  "node_modules/lodash/toInteger.js"(exports, module) {
    var toFinite = require_toFinite();
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    module.exports = toInteger;
  }
});

// node_modules/lodash/truncate.js
var require_truncate = __commonJS({
  "node_modules/lodash/truncate.js"(exports, module) {
    var baseToString = require_baseToString();
    var castSlice = require_castSlice();
    var hasUnicode = require_hasUnicode();
    var isObject = require_isObject();
    var isRegExp = require_isRegExp();
    var stringSize = require_stringSize();
    var stringToArray = require_stringToArray();
    var toInteger = require_toInteger();
    var toString = require_toString();
    var DEFAULT_TRUNC_LENGTH = 30;
    var DEFAULT_TRUNC_OMISSION = "...";
    var reFlags = /\w*$/;
    function truncate2(string, options) {
      var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
      if (isObject(options)) {
        var separator = "separator" in options ? options.separator : separator;
        length = "length" in options ? toInteger(options.length) : length;
        omission = "omission" in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);
      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
      if (separator === void 0) {
        return result + omission;
      }
      if (strSymbols) {
        end += result.length - end;
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match, substring = result;
          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g");
          }
          separator.lastIndex = 0;
          while (match = separator.exec(substring)) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === void 0 ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }
    module.exports = truncate2;
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    (function() {
      function is(x2, y2) {
        return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
      }
      function useSyncExternalStore$2(subscribe, getSnapshot) {
        didWarnOld18Alpha || void 0 === React5.startTransition || (didWarnOld18Alpha = true, console.error(
          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
        ));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot();
          objectIs(value, cachedValue) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        cachedValue = useState9({
          inst: { value, getSnapshot }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect2(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe, value, getSnapshot]
        );
        useEffect11(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe]
        );
        useDebugValue3(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React5 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is, useState9 = React5.useState, useEffect11 = React5.useEffect, useLayoutEffect2 = React5.useLayoutEffect, useDebugValue3 = React5.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React5.useSyncExternalStore ? React5.useSyncExternalStore : shim;
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/fast-deep-equal/es6/react.js
var require_react2 = __commonJS({
  "node_modules/fast-deep-equal/es6/react.js"(exports, module) {
    "use strict";
    module.exports = function equal(a2, b2) {
      if (a2 === b2) return true;
      if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
        if (a2.constructor !== b2.constructor) return false;
        var length, i2, keys;
        if (Array.isArray(a2)) {
          length = a2.length;
          if (length != b2.length) return false;
          for (i2 = length; i2-- !== 0; )
            if (!equal(a2[i2], b2[i2])) return false;
          return true;
        }
        if (a2 instanceof Map && b2 instanceof Map) {
          if (a2.size !== b2.size) return false;
          for (i2 of a2.entries())
            if (!b2.has(i2[0])) return false;
          for (i2 of a2.entries())
            if (!equal(i2[1], b2.get(i2[0]))) return false;
          return true;
        }
        if (a2 instanceof Set && b2 instanceof Set) {
          if (a2.size !== b2.size) return false;
          for (i2 of a2.entries())
            if (!b2.has(i2[0])) return false;
          return true;
        }
        if (ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
          length = a2.length;
          if (length != b2.length) return false;
          for (i2 = length; i2-- !== 0; )
            if (a2[i2] !== b2[i2]) return false;
          return true;
        }
        if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
        if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b2.valueOf();
        if (a2.toString !== Object.prototype.toString) return a2.toString() === b2.toString();
        keys = Object.keys(a2);
        length = keys.length;
        if (length !== Object.keys(b2).length) return false;
        for (i2 = length; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys[i2])) return false;
        for (i2 = length; i2-- !== 0; ) {
          var key = keys[i2];
          if (key === "_owner" && a2.$$typeof) {
            continue;
          }
          if (!equal(a2[key], b2[key])) return false;
        }
        return true;
      }
      return a2 !== a2 && b2 !== b2;
    };
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    (function() {
      function is(x2, y2) {
        return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React5 = require_react(), shim = require_shim(), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore3 = shim.useSyncExternalStore, useRef11 = React5.useRef, useEffect11 = React5.useEffect, useMemo11 = React5.useMemo, useDebugValue3 = React5.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef11(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo11(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot))
                return currentSelection;
              var nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual]
        );
        var value = useSyncExternalStore3(subscribe, instRef[0], instRef[1]);
        useEffect11(
          function() {
            inst.hasValue = true;
            inst.value = value;
          },
          [value]
        );
        useDebugValue3(value);
        return value;
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});

// node_modules/lodash/now.js
var require_now = __commonJS({
  "node_modules/lodash/now.js"(exports, module) {
    var root = require_root();
    var now = function() {
      return root.Date.now();
    };
    module.exports = now;
  }
});

// node_modules/lodash/debounce.js
var require_debounce = __commonJS({
  "node_modules/lodash/debounce.js"(exports, module) {
    var isObject = require_isObject();
    var now = require_now();
    var toNumber = require_toNumber();
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    function debounce3(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    module.exports = debounce3;
  }
});

// node_modules/lodash/throttle.js
var require_throttle = __commonJS({
  "node_modules/lodash/throttle.js"(exports, module) {
    var debounce3 = require_debounce();
    var isObject = require_isObject();
    var FUNC_ERROR_TEXT = "Expected a function";
    function throttle2(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce3(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    module.exports = throttle2;
  }
});

// node_modules/mui-tiptap/dist/esm/ControlledBubbleMenu.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react9 = __toESM(require_react());

// node_modules/tss-react/esm/makeStyles.js
var import_react3 = __toESM(require_react());

// node_modules/tss-react/esm/tools/polyfills/Object.fromEntries.js
var objectFromEntries = !Object.fromEntries ? (entries) => {
  if (!entries || !entries[Symbol.iterator]) {
    throw new Error("Object.fromEntries() requires a single iterable argument");
  }
  const o2 = {};
  Object.keys(entries).forEach((key) => {
    const [k2, v2] = entries[key];
    o2[k2] = v2;
  });
  return o2;
} : Object.fromEntries;

// node_modules/tss-react/esm/tools/objectKeys.js
function objectKeys(o2) {
  return Object.keys(o2);
}

// node_modules/tss-react/esm/tools/assert.js
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}

// node_modules/tss-react/esm/tools/typeGuard.js
function typeGuard(_value, isMatched) {
  return isMatched;
}

// node_modules/tss-react/esm/tools/classnames.js
var classnames = (args) => {
  const len = args.length;
  let i2 = 0;
  let cls = "";
  for (; i2 < len; i2++) {
    const arg = args[i2];
    if (arg == null)
      continue;
    let toAdd;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames(arg);
        } else {
          assert(!typeGuard(arg, false));
          if (arg.styles !== void 0 && arg.name !== void 0) {
            console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
          }
          toAdd = "";
          for (const k2 in arg) {
            if (arg[k2] && k2) {
              toAdd && (toAdd += " ");
              toAdd += k2;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};

// node_modules/tss-react/esm/tools/useGuaranteedMemo.js
var import_react = __toESM(require_react());
function useGuaranteedMemo(fn, deps) {
  var _a;
  const ref = (0, import_react.useRef)();
  if (!ref.current || deps.length !== ((_a = ref.current.prevDeps) === null || _a === void 0 ? void 0 : _a.length) || ref.current.prevDeps.map((v2, i2) => v2 === deps[i2]).indexOf(false) >= 0) {
    ref.current = {
      "v": fn(),
      "prevDeps": [...deps]
    };
  }
  return ref.current.v;
}

// node_modules/tss-react/esm/types.js
function matchCSSObject(arg) {
  return arg instanceof Object && !("styles" in arg) && !("length" in arg) && !("__emotion_styles" in arg);
}

// node_modules/tss-react/esm/cssAndCx.js
var { createCssAndCx } = /* @__PURE__ */ (() => {
  function merge(registered, css2, className) {
    const registeredStyles = [];
    const rawClassName = getRegisteredStyles(registered, registeredStyles, className);
    if (registeredStyles.length < 2) {
      return className;
    }
    return rawClassName + css2(registeredStyles);
  }
  function createCssAndCx2(params) {
    const { cache } = params;
    const css2 = (...args) => {
      const serialized = serializeStyles(args, cache.registered);
      insertStyles(cache, serialized, false);
      const className = `${cache.key}-${serialized.name}`;
      scope: {
        const arg = args[0];
        if (!matchCSSObject(arg)) {
          break scope;
        }
        increaseSpecificityToTakePrecedenceOverMediaQueries.saveClassNameCSSObjectMapping(cache, className, arg);
      }
      return className;
    };
    const cx = (...args) => {
      const className = classnames(args);
      const feat27FixedClassnames = increaseSpecificityToTakePrecedenceOverMediaQueries.fixClassName(cache, className, css2);
      return merge(cache.registered, css2, feat27FixedClassnames);
    };
    return { css: css2, cx };
  }
  return { createCssAndCx: createCssAndCx2 };
})();
function createUseCssAndCx(params) {
  const { useCache } = params;
  function useCssAndCx() {
    const cache = useCache();
    const { css: css2, cx } = useGuaranteedMemo(() => createCssAndCx({ cache }), [cache]);
    return { css: css2, cx };
  }
  return { useCssAndCx };
}
var increaseSpecificityToTakePrecedenceOverMediaQueries = /* @__PURE__ */ (() => {
  const cssObjectMapByCache = /* @__PURE__ */ new WeakMap();
  return {
    "saveClassNameCSSObjectMapping": (cache, className, cssObject) => {
      let cssObjectMap = cssObjectMapByCache.get(cache);
      if (cssObjectMap === void 0) {
        cssObjectMap = /* @__PURE__ */ new Map();
        cssObjectMapByCache.set(cache, cssObjectMap);
      }
      cssObjectMap.set(className, cssObject);
    },
    "fixClassName": /* @__PURE__ */ (() => {
      function fix(classNameCSSObjects) {
        let isThereAnyMediaQueriesInPreviousClasses = false;
        return classNameCSSObjects.map(([className, cssObject]) => {
          if (cssObject === void 0) {
            return className;
          }
          let out;
          if (!isThereAnyMediaQueriesInPreviousClasses) {
            out = className;
            for (const key in cssObject) {
              if (key.startsWith("@media")) {
                isThereAnyMediaQueriesInPreviousClasses = true;
                break;
              }
            }
          } else {
            out = {
              "&&": cssObject
            };
          }
          return out;
        });
      }
      return (cache, className, css2) => {
        const cssObjectMap = cssObjectMapByCache.get(cache);
        return classnames(fix(className.split(" ").map((className2) => [
          className2,
          cssObjectMap === null || cssObjectMap === void 0 ? void 0 : cssObjectMap.get(className2)
        ])).map((classNameOrCSSObject) => typeof classNameOrCSSObject === "string" ? classNameOrCSSObject : css2(classNameOrCSSObject)));
      };
    })()
  };
})();

// node_modules/tss-react/esm/tools/getDependencyArrayRef.js
function getDependencyArrayRef(obj) {
  if (!(obj instanceof Object) || typeof obj === "function") {
    return obj;
  }
  const arr = [];
  for (const key in obj) {
    const value = obj[key];
    const typeofValue = typeof value;
    if (!(typeofValue === "string" || typeofValue === "number" && !isNaN(value) || typeofValue === "boolean" || value === void 0 || value === null)) {
      return obj;
    }
    arr.push(`${key}:${typeofValue}_${value}`);
  }
  return "xSqLiJdLMd9s" + arr.join("|");
}

// node_modules/tss-react/esm/mergeClasses.js
function mergeClasses(classesFromUseStyles, classesOverrides, cx) {
  if (!(classesOverrides instanceof Object)) {
    return classesFromUseStyles;
  }
  const out = {};
  objectKeys(classesFromUseStyles).forEach((ruleName) => out[ruleName] = cx(classesFromUseStyles[ruleName], classesOverrides[ruleName]));
  objectKeys(classesOverrides).forEach((ruleName) => {
    if (ruleName in classesFromUseStyles) {
      return;
    }
    const className = classesOverrides[ruleName];
    if (typeof className !== "string") {
      return;
    }
    out[ruleName] = className;
  });
  return out;
}

// node_modules/tss-react/esm/makeStyles.js
var import_react4 = __toESM(require_react());

// node_modules/tss-react/esm/mui/themeStyleOverridesPlugin.js
var import_react2 = __toESM(require_react());
var useMuiThemeStyleOverridesPlugin = ({ classes, theme, muiStyleOverridesParams, css: css2, cx, name }) => {
  var _a, _b;
  require_named: {
    if (name === "makeStyle no name") {
      name = void 0;
      break require_named;
    }
    if (muiStyleOverridesParams !== void 0 && name === void 0) {
      throw new Error("To use muiStyleOverridesParams, you must specify a name using .withName('MyComponent')");
    }
  }
  let styleOverrides = void 0;
  try {
    styleOverrides = name === void 0 ? void 0 : ((_b = (_a = theme.components) === null || _a === void 0 ? void 0 : _a[
      name
      /*example*/
    ]) === null || _b === void 0 ? void 0 : _b.styleOverrides) || void 0;
  } catch (_c) {
  }
  const classesFromThemeStyleOverrides = (0, import_react2.useMemo)(() => {
    if (styleOverrides === void 0) {
      return void 0;
    }
    const themeClasses = {};
    for (const ruleName in styleOverrides) {
      const cssObjectOrGetCssObject = styleOverrides[ruleName];
      if (!(cssObjectOrGetCssObject instanceof Object)) {
        continue;
      }
      themeClasses[ruleName] = css2(typeof cssObjectOrGetCssObject === "function" ? cssObjectOrGetCssObject({
        theme,
        "ownerState": muiStyleOverridesParams === null || muiStyleOverridesParams === void 0 ? void 0 : muiStyleOverridesParams.ownerState,
        ...muiStyleOverridesParams === null || muiStyleOverridesParams === void 0 ? void 0 : muiStyleOverridesParams.props
      }) : cssObjectOrGetCssObject);
    }
    return themeClasses;
  }, [
    styleOverrides,
    getDependencyArrayRef(muiStyleOverridesParams === null || muiStyleOverridesParams === void 0 ? void 0 : muiStyleOverridesParams.props),
    getDependencyArrayRef(muiStyleOverridesParams === null || muiStyleOverridesParams === void 0 ? void 0 : muiStyleOverridesParams.ownerState),
    css2
  ]);
  classes = (0, import_react2.useMemo)(() => mergeClasses(classes, classesFromThemeStyleOverrides, cx), [classes, classesFromThemeStyleOverrides, cx]);
  return { classes };
};

// node_modules/tss-react/esm/makeStyles.js
var useContextualCache = __unsafe_useEmotionCache;
var counter = 0;
function createMakeStyles(params) {
  const { useTheme: useTheme2, cache: cacheProvidedAtInception } = params;
  const { useCache } = createUseCache({ cacheProvidedAtInception });
  const { useCssAndCx } = createUseCssAndCx({ useCache });
  function makeStyles2(params2) {
    const { name: nameOrWrappedName, uniqId = `${counter++}` } = params2 !== null && params2 !== void 0 ? params2 : {};
    const name = typeof nameOrWrappedName !== "object" ? nameOrWrappedName : Object.keys(nameOrWrappedName)[0];
    return function(cssObjectByRuleNameOrGetCssObjectByRuleName) {
      const getCssObjectByRuleName = typeof cssObjectByRuleNameOrGetCssObjectByRuleName === "function" ? cssObjectByRuleNameOrGetCssObjectByRuleName : () => cssObjectByRuleNameOrGetCssObjectByRuleName;
      return function useStyles28(params3, muiStyleOverridesParams) {
        const theme = useTheme2();
        let { css: css2, cx } = useCssAndCx();
        const cache = useCache();
        let classes = (0, import_react3.useMemo)(() => {
          const refClassesCache = {};
          const refClasses = typeof Proxy !== "undefined" && new Proxy({}, {
            "get": (_target, propertyKey) => {
              if (typeof propertyKey === "symbol") {
                assert(false);
              }
              return refClassesCache[propertyKey] = `${cache.key}-${uniqId}${name !== void 0 ? `-${name}` : ""}-${propertyKey}-ref`;
            }
          });
          const cssObjectByRuleName = getCssObjectByRuleName(theme, params3, refClasses || {});
          const classes2 = objectFromEntries(objectKeys(cssObjectByRuleName).map((ruleName) => {
            const cssObject = cssObjectByRuleName[ruleName];
            if (!cssObject.label) {
              cssObject.label = `${name !== void 0 ? `${name}-` : ""}${ruleName}`;
            }
            return [
              ruleName,
              `${css2(cssObject)}${typeGuard(ruleName, ruleName in refClassesCache) ? ` ${refClassesCache[ruleName]}` : ""}`
            ];
          }));
          objectKeys(refClassesCache).forEach((ruleName) => {
            if (ruleName in classes2) {
              return;
            }
            classes2[ruleName] = refClassesCache[ruleName];
          });
          return classes2;
        }, [cache, css2, cx, theme, getDependencyArrayRef(params3)]);
        {
          const propsClasses = muiStyleOverridesParams === null || muiStyleOverridesParams === void 0 ? void 0 : muiStyleOverridesParams.props.classes;
          classes = (0, import_react3.useMemo)(() => mergeClasses(classes, propsClasses, cx), [classes, getDependencyArrayRef(propsClasses), cx]);
        }
        {
          const pluginResultWrap = useMuiThemeStyleOverridesPlugin({
            classes,
            css: css2,
            cx,
            "name": name !== null && name !== void 0 ? name : "makeStyle no name",
            "idOfUseStyles": uniqId,
            muiStyleOverridesParams,
            // NOTE: If it's not a Mui Theme the plugin is resilient, it will not crash
            "theme": theme
          });
          if (pluginResultWrap.classes !== void 0) {
            classes = pluginResultWrap.classes;
          }
          if (pluginResultWrap.css !== void 0) {
            css2 = pluginResultWrap.css;
          }
          if (pluginResultWrap.cx !== void 0) {
            cx = pluginResultWrap.cx;
          }
        }
        return {
          classes,
          theme,
          css: css2,
          cx
        };
      };
    };
  }
  function useStyles27() {
    const theme = useTheme2();
    const { css: css2, cx } = useCssAndCx();
    return { theme, css: css2, cx };
  }
  return { makeStyles: makeStyles2, useStyles: useStyles27 };
}
var reactContext = (0, import_react4.createContext)(void 0);
var { createUseCache } = /* @__PURE__ */ (() => {
  function useCacheProvidedByProvider() {
    const cacheExplicitlyProvidedForTss = (0, import_react4.useContext)(reactContext);
    return cacheExplicitlyProvidedForTss;
  }
  function createUseCache2(params) {
    const { cacheProvidedAtInception } = params;
    function useCache() {
      var _a;
      const contextualCache = useContextualCache();
      const cacheExplicitlyProvidedForTss = useCacheProvidedByProvider();
      const cacheToBeUsed = (_a = cacheProvidedAtInception !== null && cacheProvidedAtInception !== void 0 ? cacheProvidedAtInception : cacheExplicitlyProvidedForTss) !== null && _a !== void 0 ? _a : contextualCache;
      if (cacheToBeUsed === null) {
        throw new Error([
          "In order to get SSR working with tss-react you need to explicitly provide an Emotion cache.",
          "MUI users be aware: This is not an error strictly related to tss-react, with or without tss-react,",
          "MUI needs an Emotion cache to be provided for SSR to work.",
          "Here is the MUI documentation related to SSR setup: https://mui.com/material-ui/guides/server-rendering/",
          "TSS provides helper that makes the process of setting up SSR easier: https://docs.tss-react.dev/ssr"
        ].join("\n"));
      }
      return cacheToBeUsed;
    }
    return { useCache };
  }
  return { createUseCache: createUseCache2 };
})();

// node_modules/tss-react/esm/withStyles.js
var import_react6 = __toESM(require_react());

// node_modules/tss-react/esm/tools/capitalize.js
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// node_modules/tss-react/esm/withStyles.js
function createWithStyles(params) {
  const { useTheme: useTheme2, cache } = params;
  const { makeStyles: makeStyles2 } = createMakeStyles({ useTheme: useTheme2, cache });
  function withStyles2(Component2, cssObjectByRuleNameOrGetCssObjectByRuleName, params2) {
    const Component_ = typeof Component2 === "string" ? (() => {
      const tag = Component2;
      const Out2 = function({ children, ...props }) {
        return (0, import_react6.createElement)(tag, props, children);
      };
      Object.defineProperty(Out2, "name", {
        "value": capitalize(tag)
      });
      return Out2;
    })() : Component2;
    const name = (() => {
      {
        const { name: nameOrWrappedName } = params2 !== null && params2 !== void 0 ? params2 : {};
        if (nameOrWrappedName !== void 0) {
          return typeof nameOrWrappedName !== "object" ? nameOrWrappedName : Object.keys(nameOrWrappedName)[0];
        }
      }
      let name2 = void 0;
      displayName: {
        const displayName = Component_.displayName;
        if (typeof displayName !== "string" || displayName === "") {
          break displayName;
        }
        name2 = displayName;
      }
      functionName: {
        if (name2 !== void 0) {
          break functionName;
        }
        const functionName = Component_.name;
        if (typeof functionName !== "string" || functionName === "") {
          break functionName;
        }
        name2 = functionName;
      }
      if (name2 === void 0) {
        return void 0;
      }
      name2 = name2.replace(/\$/g, "usd");
      name2 = name2.replace(/\(/g, "_").replace(/\)/g, "_");
      name2 = name2.replace(/[^a-zA-Z0-9-_]/g, "_");
      return name2;
    })();
    const useStyles27 = makeStyles2({ ...params2, name })(typeof cssObjectByRuleNameOrGetCssObjectByRuleName === "function" ? (theme, props, classes) => incorporateMediaQueries(cssObjectByRuleNameOrGetCssObjectByRuleName(theme, props, classes)) : incorporateMediaQueries(cssObjectByRuleNameOrGetCssObjectByRuleName));
    function getHasNonRootClasses(classes) {
      for (const name2 in classes) {
        if (name2 === "root") {
          continue;
        }
        return true;
      }
      return false;
    }
    const Out = (0, import_react6.forwardRef)(function(props, ref) {
      const { className, classes: _classes, ...rest } = props;
      const { classes, cx } = useStyles27(props, { props });
      const rootClassName = cx(classes.root, className);
      fixedClassesByClasses.set(classes, {
        ...classes,
        "root": rootClassName
      });
      return import_react6.default.createElement(Component_, { ref, className: getHasNonRootClasses(classes) ? className : rootClassName, ...typeof Component2 === "string" ? {} : { classes }, ...rest });
    });
    if (name !== void 0) {
      Out.displayName = `${capitalize(name)}WithStyles`;
      Object.defineProperty(Out, "name", { "value": Out.displayName });
    }
    return Out;
  }
  withStyles2.getClasses = getClasses;
  return { withStyles: withStyles2 };
}
var fixedClassesByClasses = /* @__PURE__ */ new WeakMap();
var errorMessageGetClasses = "getClasses should only be used in conjunction with withStyles";
function getClasses(props) {
  const classesIn = props.classes;
  if (classesIn === void 0) {
    throw new Error(errorMessageGetClasses);
  }
  const classes = fixedClassesByClasses.get(classesIn);
  if (classes === void 0) {
    throw new Error(errorMessageGetClasses);
  }
  return classes;
}
function incorporateMediaQueries(cssObjectByRuleNameWithMediaQueries) {
  const cssObjectByRuleName = {};
  const cssObjectByRuleNameWithMediaQueriesByMediaQuery = {};
  Object.keys(cssObjectByRuleNameWithMediaQueries).forEach((ruleNameOrMediaQuery) => (ruleNameOrMediaQuery.startsWith("@media") ? cssObjectByRuleNameWithMediaQueriesByMediaQuery : cssObjectByRuleName)[ruleNameOrMediaQuery] = cssObjectByRuleNameWithMediaQueries[ruleNameOrMediaQuery]);
  Object.keys(cssObjectByRuleNameWithMediaQueriesByMediaQuery).forEach((mediaQuery) => {
    const cssObjectByRuleNameBis = cssObjectByRuleNameWithMediaQueriesByMediaQuery[mediaQuery];
    Object.keys(cssObjectByRuleNameBis).forEach((ruleName) => {
      var _a;
      return cssObjectByRuleName[ruleName] = {
        ...(_a = cssObjectByRuleName[ruleName]) !== null && _a !== void 0 ? _a : {},
        [mediaQuery]: cssObjectByRuleNameBis[ruleName]
      };
    });
  });
  return cssObjectByRuleName;
}

// node_modules/tss-react/esm/tools/isSSR.js
var isSSR = (() => {
  const isBrowser = typeof document === "object" && typeof (document === null || document === void 0 ? void 0 : document.getElementById) === "function";
  const isJest = typeof jest !== "undefined";
  const isMocha = typeof mocha !== "undefined";
  const isVitest = typeof __vitest_worker__ !== "undefined";
  return !isBrowser && !isJest && !isMocha && !isVitest;
})();

// node_modules/tss-react/esm/tss.js
function createTss(params) {
  counter2 = 0;
  nestedSelectorUsageTrackRecord.splice(0, nestedSelectorUsageTrackRecord.length);
  const { useContext: useContext5, usePlugin, cache: cacheProvidedAtInception } = params;
  const { useCache } = createUseCache({ cacheProvidedAtInception });
  const { useCssAndCx } = createUseCssAndCx({ useCache });
  const usePluginDefault = ({ classes, cx, css: css2 }) => ({ classes, cx, css: css2 });
  const tss3 = createTss_internal({
    useContext: useContext5,
    useCache,
    useCssAndCx,
    "usePlugin": usePlugin !== null && usePlugin !== void 0 ? usePlugin : usePluginDefault,
    "name": void 0,
    "doesUseNestedSelectors": false
  });
  return { tss: tss3 };
}
var counter2 = 0;
var nestedSelectorUsageTrackRecord = [];
function createTss_internal(params) {
  const { useContext: useContext5, useCache, useCssAndCx, usePlugin, name, doesUseNestedSelectors } = params;
  return {
    "withParams": () => createTss_internal({ ...params }),
    "withName": (nameOrWrappedName) => createTss_internal({
      ...params,
      "name": typeof nameOrWrappedName !== "object" ? nameOrWrappedName : Object.keys(nameOrWrappedName)[0]
    }),
    "withNestedSelectors": () => createTss_internal({
      ...params,
      "doesUseNestedSelectors": true
    }),
    "create": (cssObjectByRuleNameOrGetCssObjectByRuleName) => {
      const idOfUseStyles = `x${counter2++}`;
      if (name !== void 0) {
        while (true) {
          const wrap = nestedSelectorUsageTrackRecord.find((wrap2) => wrap2.name === name);
          if (wrap === void 0) {
            break;
          }
          nestedSelectorUsageTrackRecord.splice(nestedSelectorUsageTrackRecord.indexOf(wrap), 1);
        }
      }
      const getCssObjectByRuleName = typeof cssObjectByRuleNameOrGetCssObjectByRuleName === "function" ? cssObjectByRuleNameOrGetCssObjectByRuleName : () => cssObjectByRuleNameOrGetCssObjectByRuleName;
      return function useStyles27(params2) {
        var _a, _b, _c;
        const { classesOverrides, ...paramsAndPluginParams } = params2 !== null && params2 !== void 0 ? params2 : {};
        const context = useContext5();
        const { css: css2, cx } = useCssAndCx();
        const cache = useCache();
        const getClasses2 = () => {
          const refClassesCache = {};
          const cssObjectByRuleName = getCssObjectByRuleName({
            ...params2,
            ...context,
            ...!doesUseNestedSelectors ? {} : {
              "classes": typeof Proxy === "undefined" ? {} : new Proxy({}, {
                "get": (_target, ruleName) => {
                  if (typeof ruleName === "symbol") {
                    assert(false);
                  }
                  if (isSSR && name === void 0) {
                    throw new Error([
                      `tss-react: In SSR setups, in order to use nested selectors, you must also give a unique name to the useStyle function.`,
                      `Solution: Use tss.withName("ComponentName").withNestedSelectors<...>()... to set a name.`
                    ].join("\n"));
                  }
                  update_nested_selector_usage_track_record: {
                    if (name === void 0) {
                      break update_nested_selector_usage_track_record;
                    }
                    let wrap = nestedSelectorUsageTrackRecord.find((wrap2) => wrap2.name === name && wrap2.idOfUseStyles === idOfUseStyles);
                    if (wrap === void 0) {
                      wrap = { name, idOfUseStyles, "nestedSelectorRuleNames": /* @__PURE__ */ new Set() };
                      nestedSelectorUsageTrackRecord.push(wrap);
                    }
                    wrap.nestedSelectorRuleNames.add(ruleName);
                  }
                  detect_potential_conflicts: {
                    if (name === void 0) {
                      break detect_potential_conflicts;
                    }
                    const hasPotentialConflict = nestedSelectorUsageTrackRecord.find((wrap) => wrap.name === name && wrap.idOfUseStyles !== idOfUseStyles && wrap.nestedSelectorRuleNames.has(ruleName)) !== void 0;
                    if (!hasPotentialConflict) {
                      break detect_potential_conflicts;
                    }
                    throw new Error([
                      `tss-react: There are in your codebase two different useStyles named "${name}" that`,
                      `both use use the nested selector ${ruleName}.
`,
                      `This may lead to CSS class name collisions, causing nested selectors to target elements outside of the intended scope.
`,
                      `Solution: Ensure each useStyles using nested selectors has a unique name.
`,
                      `Use: tss.withName("UniqueName").withNestedSelectors<...>()...`
                    ].join(" "));
                  }
                  return refClassesCache[ruleName] = `${cache.key}-${name !== void 0 ? name : idOfUseStyles}-${ruleName}-ref`;
                }
              })
            }
          });
          let classes2 = objectFromEntries(objectKeys(cssObjectByRuleName).map((ruleName) => {
            const cssObject = cssObjectByRuleName[ruleName];
            if (!cssObject.label) {
              cssObject.label = `${name !== void 0 ? `${name}-` : ""}${ruleName}`;
            }
            return [
              ruleName,
              `${css2(cssObject)}${typeGuard(ruleName, ruleName in refClassesCache) ? ` ${refClassesCache[ruleName]}` : ""}`
            ];
          }));
          objectKeys(refClassesCache).forEach((ruleName) => {
            if (ruleName in classes2) {
              return;
            }
            classes2[ruleName] = refClassesCache[ruleName];
          });
          classes2 = mergeClasses(classes2, classesOverrides, cx);
          return classes2;
        };
        const classes = runGetClassesOrUseCache({
          cache,
          cssObjectByRuleNameOrGetCssObjectByRuleName,
          "classesOverridesRef": getDependencyArrayRef(classesOverrides),
          "paramsAndPluginParamsRef": getDependencyArrayRef(paramsAndPluginParams),
          idOfUseStyles,
          context,
          getClasses: getClasses2
        });
        const pluginResultWrap = usePlugin({
          classes,
          css: css2,
          cx,
          idOfUseStyles,
          name,
          ...context,
          ...paramsAndPluginParams
        });
        return {
          "classes": (_a = pluginResultWrap.classes) !== null && _a !== void 0 ? _a : classes,
          "css": (_b = pluginResultWrap.css) !== null && _b !== void 0 ? _b : css2,
          "cx": (_c = pluginResultWrap.cx) !== null && _c !== void 0 ? _c : cx,
          ...context
        };
      };
    }
  };
}
var mapCache = /* @__PURE__ */ new WeakMap();
function runGetClassesOrUseCache(params) {
  const { cache, cssObjectByRuleNameOrGetCssObjectByRuleName, classesOverridesRef, paramsAndPluginParamsRef, idOfUseStyles, context, getClasses: getClasses2 } = params;
  use_cache: {
    const mapCache_in = mapCache.get(cache);
    if (mapCache_in === void 0) {
      break use_cache;
    }
    const mapCache_in_in = mapCache_in.get(cssObjectByRuleNameOrGetCssObjectByRuleName);
    if (mapCache_in_in === void 0) {
      break use_cache;
    }
    const mapCache_in_in_in = mapCache_in_in.get(classesOverridesRef);
    if (mapCache_in_in_in === void 0) {
      break use_cache;
    }
    const arr = mapCache_in_in_in.get(paramsAndPluginParamsRef);
    if (arr === void 0) {
      break use_cache;
    }
    const entry = arr.find(({ context: context_i }) => {
      if (context_i === context) {
        return true;
      }
      if (objectKeys(context_i).length !== objectKeys(context).length) {
        return false;
      }
      for (const key in context_i) {
        if (getDependencyArrayRef(context_i[key]) !== getDependencyArrayRef(context[key])) {
          return false;
        }
      }
      return true;
    });
    if (entry === void 0) {
      break use_cache;
    }
    if ((entry === null || entry === void 0 ? void 0 : entry.idOfUseStyles) !== idOfUseStyles) {
      arr.splice(arr.indexOf(entry), 1);
      break use_cache;
    }
    return entry.result;
  }
  const result = getClasses2();
  {
    if (!mapCache.has(cache)) {
      mapCache.set(cache, /* @__PURE__ */ new WeakMap());
    }
    const mapCache_in = mapCache.get(cache);
    assert(mapCache_in !== void 0);
    if (!mapCache_in.has(cssObjectByRuleNameOrGetCssObjectByRuleName)) {
      mapCache_in.set(cssObjectByRuleNameOrGetCssObjectByRuleName, /* @__PURE__ */ new Map());
    }
    const mapCache_in_in = mapCache_in.get(cssObjectByRuleNameOrGetCssObjectByRuleName);
    assert(mapCache_in_in !== void 0);
    if (!mapCache_in_in.has(classesOverridesRef)) {
      if (mapCache_in_in.size > 200) {
        mapCache_in_in.clear();
      }
      mapCache_in_in.set(classesOverridesRef, /* @__PURE__ */ new Map());
    }
    const mapCache_in_in_in = mapCache_in_in.get(classesOverridesRef);
    assert(mapCache_in_in_in !== void 0);
    if (!mapCache_in_in_in.has(paramsAndPluginParamsRef)) {
      clear_cache: {
        const threshold = typeof paramsAndPluginParamsRef === "string" ? 257 : 5;
        if (mapCache_in_in_in.size < threshold) {
          break clear_cache;
        }
        mapCache_in_in_in.clear();
      }
      mapCache_in_in_in.set(paramsAndPluginParamsRef, []);
    }
    let arr = mapCache_in_in_in.get(paramsAndPluginParamsRef);
    assert(arr !== void 0);
    if (arr.length > 5) {
      arr = [];
    }
    arr.push({ idOfUseStyles, context, result });
  }
  return result;
}

// node_modules/tss-react/esm/GlobalStyles.js
var import_react7 = __toESM(require_react());

// node_modules/tss-react/esm/index.js
function createMakeAndWithStyles(params) {
  return {
    ...createMakeStyles(params),
    ...createWithStyles(params)
  };
}
var { tss } = createTss({
  "useContext": () => ({})
});
var useStyles = tss.create({});

// node_modules/tss-react/esm/mui/mui.js
var { makeStyles, withStyles } = createMakeAndWithStyles({
  useTheme
});
var { tss: tss2 } = createTss({
  "useContext": function useContext2() {
    const theme = useTheme();
    return { theme };
  },
  "usePlugin": useMuiThemeStyleOverridesPlugin
});
var useStyles2 = tss2.create({});

// node_modules/mui-tiptap/dist/esm/styles.js
var import_omit = __toESM(require_omit());
var Z_INDEXES = {
  TABLE_ELEMENT: 1,
  // The menu bar must sit higher than the table components (like the
  // column-resize-handle and selectedCells) of the editor.
  MENU_BAR: 2,
  // The notched outline of the "outlined" field variant should be at the same z-index
  // as the menu-bar, so that it can contain/enclose it
  NOTCHED_OUTLINE: 2
};
function getEditorStyles(theme) {
  var _a, _b, _c, _d;
  const hasResponsiveStyles = Object.keys((_a = theme.typography.h1) !== null && _a !== void 0 ? _a : {}).some((key) => key.includes("@media"));
  const cursorDelayOpacityChangeAnimation = keyframes`
    0%, 95% {
      opacity: 1;
    }
    100% {
      opacity: 0;
    }
  `;
  return {
    // Include all of the body1 text styles except for line-height, since we want a
    // little less height (falling back to the default line-height)
    ...(0, import_omit.default)(theme.typography.body1, ["lineHeight"]),
    "&:focus": {
      outline: "none"
    },
    "& h1": {
      // We don't use MUI's default heading typography styles of h1-h6 here
      // since h1 and h2 are a bit too huge/dramatic. Instead, we use h3-h6,
      // subtitle1, and subtitle2.
      // For h1, we take our usual font family, set a bold font weight, and set
      // the font size based on a scaled-up 20% increase to `typography.h4`
      // (which we use as our next smaller header). Note that if the MUI
      // `responsiveFontSizes` theme utility was used, we increase the font size
      // at all responsive breakpoints.
      fontFamily: (_b = theme.typography.h3) === null || _b === void 0 ? void 0 : _b.fontFamily,
      fontWeight: "bold",
      ...hasResponsiveStyles ? {
        fontSize: `${(1.5625 * 1.2).toFixed(4)}rem`,
        [theme.breakpoints.up("sm")]: {
          fontSize: `${(1.8219 * 1.2).toFixed(4)}rem`
        },
        [theme.breakpoints.up("md")]: {
          fontSize: `${(2.0243 * 1.2).toFixed(4)}rem`
        },
        [theme.breakpoints.up("lg")]: {
          fontSize: `${(2.0243 * 1.2).toFixed(4)}rem`
        }
      } : {
        fontSize: `${(2.0243 * 1.2).toFixed(4)}rem`
      }
    },
    "& h2": {
      ...(0, import_omit.default)(theme.typography.h4, ["lineHeight"]),
      fontWeight: 500
    },
    "& h3": {
      ...(0, import_omit.default)(theme.typography.h5, ["lineHeight"]),
      fontWeight: 500
    },
    "& h4": {
      ...(0, import_omit.default)(theme.typography.h6, ["lineHeight"]),
      fontWeight: 500
    },
    "& h5": {
      ...(0, import_omit.default)(theme.typography.subtitle1, ["lineHeight"]),
      fontWeight: 500
    },
    "& h6": {
      ...(0, import_omit.default)(theme.typography.subtitle2, ["lineHeight"]),
      fontWeight: 500
    },
    // Remove above/below margins from all of our blocks
    "& h1, & h2, & h3, & h4, & h5, & h6, & p": {
      marginBlockStart: 0,
      marginBlockEnd: 0
    },
    '& a:not([data-type="mention"])': {
      color: theme.palette.primary.main,
      textDecoration: "none",
      "&:hover": {
        textDecoration: "underline"
      }
    },
    "& ul, & ol": {
      marginBlockStart: 0,
      marginBlockEnd: 0
    },
    "& ol": {
      listStyleType: "decimal",
      "& ol": {
        listStyleType: "lower-alpha",
        "& ol": {
          listStyleType: "lower-roman",
          "& ol": {
            listStyleType: "decimal",
            "& ol": {
              listStyleType: "lower-alpha",
              "& ol": {
                listStyleType: "lower-roman"
              }
            }
          }
        }
      }
    },
    // Note that although browsers would typically match for the first three
    // here (disc, circle, then square), this gets broken if the editor happens
    // to be rendering inside of some outer list. (We also improve the deeper
    // nested uls somewhat while we're at it).
    "& ul": {
      listStyleType: "disc",
      "& ul": {
        listStyleType: "circle",
        "& ul": {
          listStyleType: "square",
          "& ul": {
            listStyleType: "disc",
            "& ul": {
              listStyleType: "circle",
              "& ul": {
                listStyleType: "square"
              }
            }
          }
        }
      }
    },
    // These styles are based on the example here https://tiptap.dev/api/nodes/task-list
    '& ul[data-type="taskList"]': {
      listStyle: "none",
      padding: 0,
      "& li": {
        display: "flex",
        "& > label": {
          flex: "0 0 auto",
          marginRight: "0.5rem",
          userSelect: "none"
        },
        "& > div": {
          flex: "1 1 auto"
        }
      }
    },
    "& blockquote": {
      paddingLeft: "1rem",
      marginInlineStart: theme.spacing(1),
      marginInlineEnd: theme.spacing(1),
      position: "relative",
      "&:before": {
        // This pseudo-element approach mimics Slack's technique, which allows
        // for rounded edges
        position: "absolute",
        top: 0,
        bottom: 0,
        left: 0,
        display: "block",
        width: 4,
        borderRadius: theme.shape.borderRadius,
        background: theme.palette.text.disabled,
        content: '""'
      }
    },
    "& :not(pre) > code": {
      padding: "2px 3px 1px",
      borderWidth: 1,
      borderStyle: "solid",
      borderColor: theme.palette.divider,
      borderRadius: 3,
      backgroundColor: theme.palette.action.hover,
      color: theme.palette.mode === "dark" ? theme.palette.secondary.main : darken(theme.palette.secondary.dark, 0.1)
    },
    "& pre": {
      marginTop: theme.spacing(0.5),
      marginBottom: theme.spacing(0.5),
      padding: theme.spacing(1),
      borderWidth: 1,
      borderStyle: "solid",
      borderColor: theme.palette.divider,
      borderRadius: theme.shape.borderRadius,
      background: theme.palette.action.hover,
      // By default the line-height of some monospace fonts (like "Ubuntu Mono")
      // appears to be a bit taller than necessary in pre block format
      lineHeight: 1.4,
      overflowX: "auto",
      // Override the default Prosemirror styles, which use pre-wrap. We want code
      // blocks to be horizontally scrollable, like they are on GitHub or StackOverflow
      // (since that makes reading code, logs, etc. much easier), with no wrapping.
      whiteSpace: "pre !important"
    },
    '& [data-type="mention"]': {
      padding: "0 0.25rem",
      // Setting the line-height here prevents the at-mentions from bumping up against
      // one another on consecutive lines
      lineHeight: "1.3em",
      borderRadius: theme.shape.borderRadius,
      color: theme.palette.primary.main,
      background: theme.palette.mode === "dark" ? alpha(darken(theme.palette.primary.dark, 0.7), 0.5) : alpha(lighten(theme.palette.primary.light, 0.6), 0.3),
      textDecoration: "none"
    },
    // We style all images which are *not* the ProseMirror-separator (an element added
    // via Prosemirror, which is there for a hack to get contenteditable to appear
    // correctly for text blocks and line breaks; see
    // https://discuss.prosemirror.net/t/what-is-addhacknode/4254)
    "& img:not(.ProseMirror-separator)": {
      // TODO(Steven DeMartini): Decide if we should let folks make the images wider
      // than the doc. If so, we'll need to make the overall doc container hide overflow
      // and add a scrollbar
      maxWidth: "100%",
      height: "auto",
      // Using inline-flex allows the image to be correctly positioned, whether
      // the Image/ResizableImage extension is configured with `inline` as false
      // or true. In the former case (the default), it should have other
      // block-level elements on either side of it, allowing it to flow
      // correctly as a block.
      display: "inline-flex",
      ...getImageBackgroundColorStyles(theme),
      // Behavior when an image (node) is selected, at which point it can be deleted,
      // moved, etc.
      "&.ProseMirror-selectednode": {
        outline: `3px solid ${theme.palette.primary.main}`
      }
    },
    "& hr": {
      borderWidth: 0,
      borderTopWidth: "thin",
      borderStyle: "solid",
      borderColor: theme.palette.text.secondary,
      "&.ProseMirror-selectednode": {
        borderColor: theme.palette.primary.main
      }
    },
    "& table": {
      borderCollapse: "collapse",
      tableLayout: "fixed",
      // TODO(Steven DeMartini): Maybe we want to give the users a way to toggle the width of the
      // table to be 100% or not? Similar to what Confluence does with their "Responsive" option
      // width: "100%",
      margin: 0,
      overflowY: "hidden",
      // If we don't have enough horizontal space for a table (when in read-only mode),
      // we need it to add a horizontal scrollbar, which requires using display:block
      // instead of display:table.
      overflowX: "auto",
      display: "block",
      "& td, th": {
        minWidth: "1em",
        borderWidth: 1,
        borderStyle: "solid",
        borderColor: theme.palette.mode === "dark" ? theme.palette.grey[500] : theme.palette.grey[400],
        padding: "3px 5px",
        verticalAlign: "top",
        boxSizing: "border-box",
        position: "relative",
        "& > *": {
          marginBottom: 0
        }
      },
      "& th": {
        fontWeight: 500,
        textAlign: "left",
        backgroundColor: theme.palette.action.selected
      }
    },
    // When in editing mode, the <table> element is wrapped in a div with a
    // `tableWrapper` class. When we have that arrangement, we change how
    // overflow works on the table to instead overflow with the wrapper and
    // revert back to display:table, as we'd typically expect/want.
    "& .tableWrapper": {
      overflowX: "auto",
      "& table": {
        overflow: "hidden",
        display: "table"
      }
    },
    "& .selectedCell:after": {
      zIndex: Z_INDEXES.TABLE_ELEMENT,
      position: "absolute",
      content: '""',
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      background: "rgba(200, 200, 255, 0.4)",
      pointerEvents: "none"
    },
    // Only when the editor has `editable` set to `true` should the table column
    // resize tools should be revealed and be usable
    '&[contenteditable="true"]': {
      "& .column-resize-handle": {
        position: "absolute",
        right: -2,
        top: -1,
        bottom: -2,
        width: 4,
        // This z-index proved necessary to ensure the handle sits above the
        // background of any cell (header and non-header)
        zIndex: Z_INDEXES.TABLE_ELEMENT,
        backgroundColor: theme.palette.primary.light,
        pointerEvents: "none"
      },
      "&.resize-cursor": {
        cursor: "col-resize"
      }
    },
    '&[contenteditable="false"]': {
      "& .column-resize-handle": {
        display: "none"
      },
      "&.resize-cursor": {
        // To ensure that users cannot resize tables when the editor is supposed
        // to be read-only, we have to disable pointer events for the entire
        // editor whenever the resize-cursor class is added (i.e. when a user
        // hovers over a column border that would otherwise allow for dragging
        // and resizing when in editable mode). This is because the underlying
        // prosemirror-tables `columnResizing` plugin doesn't know/care about
        // `editable` state, and so adds the "resize-cursor" class and tries to
        // listen for events regardless.
        pointerEvents: "none"
      }
    },
    // Based on the example styles from https://tiptap.dev/api/extensions/placeholder,
    // this adds the placeholder text at the top
    "& p.is-editor-empty:first-of-type::before": {
      color: theme.palette.text.disabled,
      content: "attr(data-placeholder)",
      float: "left",
      height: 0,
      pointerEvents: "none"
    },
    "& .ProseMirror-gapcursor:after": {
      // Override the default color provided for the Gapcursor extension (for better
      // dark/light mode compatibility)
      // https://github.com/ueberdosis/tiptap/blob/ab4a0e2507b4b92c46d293a0bb06bb00a04af6e0/packages/core/src/style.ts#L47
      borderColor: theme.palette.text.primary
    },
    // These styles were based on Tiptap's example here
    // https://tiptap.dev/api/extensions/collaboration-cursor
    "& .collaboration-cursor__caret": {
      borderLeft: "1px solid #0d0d0d",
      borderRight: "1px solid #0d0d0d",
      marginLeft: "-1px",
      marginRight: "-1px",
      position: "relative",
      wordBreak: "normal",
      cursor: "text",
      // Add a larger dot at the top of the cursor, like Google Docs does, which helps
      // indicate that you can hover there and see the user's name label
      "&:after": {
        position: "absolute",
        content: '""',
        left: -3,
        right: 0,
        top: -2,
        borderWidth: 3,
        borderStyle: "solid",
        borderColor: "inherit"
      },
      // When hovering, show the user's name
      "&:hover .collaboration-cursor__label": {
        opacity: 1,
        // This transition will be used when fading in (after starting to hover), so
        // keep it brief and with no delay
        transition: theme.transitions.create("opacity", {
          delay: 0,
          duration: 100,
          easing: "linear"
        })
      }
    },
    // Render the user name above the caret
    "& .collaboration-cursor__label": {
      borderRadius: "3px 3px 3px 0",
      color: "#0d0d0d",
      fontSize: 12,
      fontStyle: "normal",
      fontWeight: 600,
      // Make sure we always use our standard font and don't take on the font of an
      // element this is showing up inside of (like <code>)
      fontFamily: (_d = (_c = theme.typography.body1) === null || _c === void 0 ? void 0 : _c.fontFamily) !== null && _d !== void 0 ? _d : "initial",
      left: -1,
      lineHeight: "normal",
      padding: "0.1rem 0.3rem",
      position: "absolute",
      top: "-1.4em",
      userSelect: "none",
      whiteSpace: "nowrap",
      // Don't use pointer-events, since that will end up making the entire user name
      // surface part of the parent's hover zone and prevent interaction with content
      // behind it
      pointerEvents: "none",
      // Hide the user name by default, so we can transition it in when hovering over
      // the cursor caret
      opacity: 0,
      // This transition will be used when fading out after no longer hovering, so
      // delay it a bit longer than default so the name doesn't immediately disappear
      transition: theme.transitions.create("opacity", {
        delay: 500,
        duration: 100,
        easing: "linear"
      }),
      // So that we initially show the user name above the caret on first render
      // (e.g. when a user clicks to move their cursor, and on page load), use
      // an animation to delay updating the opacity. We'll then use transitions
      // based on :hover selectors (above) on the caret to let users view the
      // name again while hovering thereafter. We start at fully visible, then
      // fade out after the user would've had a chance to see/read the user
      // name.
      animation: `${cursorDelayOpacityChangeAnimation} 3s linear 1`
    }
  };
}
function getImageBackgroundColorStyles(theme) {
  if (theme.palette.mode !== "dark") {
    return {};
  }
  const backgroundColor = theme.palette.grey[200];
  return {
    // We add a light grey background to the image when in dark mode, similar to what
    // Chrome does in dark mode when viewing an image in its own tab. (Chrome uses a
    // background color of "hsl(0, 0%, 90%)", or equivalently "#e6e6e6".)
    backgroundColor,
    // The "alt text" of an image will be shown if it fails to render (e.g. for
    // tif or other file formats that can't be rendered in-browser, like with a
    // pending image upload), so make sure the font color is readable
    color: theme.palette.getContrastText(backgroundColor)
  };
}
var UTILITY_CLASS_PREFIX_DEFAULT = "MuiTiptap-";
function getUtilityClass(componentName, slot) {
  return `${UTILITY_CLASS_PREFIX_DEFAULT}${componentName}-${slot}`;
}
function getUtilityClasses(componentName, slots) {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = getUtilityClass(componentName, slot);
  });
  return result;
}

// node_modules/mui-tiptap/dist/esm/ControlledBubbleMenu.js
var controlledBubbleMenuClasses = getUtilityClasses("ControlledBubbleMenu", ["root", "paper"]);
var useStyles3 = makeStyles({ name: { ControlledBubbleMenu } })((theme) => ({
  root: {
    // Ensure the bubble menu is above modals, in case the editor is rendered in
    // a modal, consistent with recommendations here
    // https://github.com/mui/material-ui/issues/14216. See
    // https://github.com/sjdemartini/mui-tiptap/issues/265.
    zIndex: theme.zIndex.tooltip
  },
  paper: {
    backgroundColor: theme.palette.background.default
  }
}));
function ControlledBubbleMenu({ editor, open, className, classes: overrideClasses = {}, sx, children, anchorEl, container, disablePortal, placement = "top", fallbackPlacements = [
  "top",
  "bottom",
  "top-start",
  "bottom-start",
  "top-end",
  "bottom-end"
], flipPadding = 8, PaperProps, ...popperProps }) {
  const { classes, cx } = useStyles3(void 0, {
    props: { classes: overrideClasses }
  });
  const theme = useTheme();
  const defaultAnchorEl = (0, import_react9.useCallback)(() => {
    const { ranges } = editor.state.selection;
    const from = Math.min(...ranges.map((range) => range.$from.pos));
    const to = Math.max(...ranges.map((range) => range.$to.pos));
    return {
      getBoundingClientRect: () => {
        if (isNodeSelection(editor.state.selection)) {
          const node = editor.view.nodeDOM(from);
          if (node instanceof HTMLElement) {
            return node.getBoundingClientRect();
          }
        }
        return posToDOMRect(editor.view, from, to);
      }
    };
  }, [editor]);
  return (0, import_jsx_runtime.jsx)(Popper_default, { open, placement, modifiers: [
    {
      name: "offset",
      options: {
        // Add a slight vertical offset for the popper from the current selection
        offset: [0, 6]
      }
    },
    {
      name: "flip",
      enabled: true,
      options: {
        // We'll reposition (to one of the below fallback placements) whenever our Popper goes
        // outside of the editor. (This is necessary since our children aren't actually rendered
        // here, but instead with a portal, so the editor DOM node isn't a parent.)
        boundary: editor.options.element,
        fallbackPlacements,
        padding: flipPadding
      }
    },
    {
      // Don't allow the bubble menu to overflow outside of the its clipping parents
      // or viewport
      name: "preventOverflow",
      enabled: true,
      options: {
        // Check for overflow in the y-axis direction instead of x-axis direction
        // (the default for top and bottom placements), since that's likely to be
        // the more problematic direction when scrolling. (Theoretically it would be
        // nice to have it check all axes which seemingly could be done with
        // `mainAxis: false`, but for an element that is wide and tall, this ends up
        // not placing the Popper in a visible location, so the behavior of
        // `altAxis: true` seems preferable.)
        altAxis: true,
        boundary: "clippingParents",
        padding: 8
      }
    }
    // If we want to add an arrow to the Popper, we'll seemingly need to implement a lot
    // of custom styling and whatnot, like in
    // https://github.com/mui-org/material-ui/blob/84671ab1d6db4f6901d60206f2375bd51862c66e/docs/src/pages/components/popper/ScrollPlayground.js#L19-L103,
    // which is probably not worth it
  ], anchorEl: anchorEl !== null && anchorEl !== void 0 ? anchorEl : defaultAnchorEl, className: cx(controlledBubbleMenuClasses.root, classes.root, className), sx, container, disablePortal, transition: true, ...popperProps, children: ({ TransitionProps }) => (0, import_jsx_runtime.jsx)(Fade_default, { ...TransitionProps, timeout: {
    enter: theme.transitions.duration.enteringScreen,
    // Exit immediately rather than using a transition, since the
    // content of the bubble menu will usually be updating as the editor
    // content and thus `open` state changes, and we don't want it to
    // "flash" with incorrect content during the transition
    exit: 0
  }, children: (0, import_jsx_runtime.jsx)(Paper_default, { elevation: 7, ...PaperProps, className: cx(controlledBubbleMenuClasses.paper, classes.paper, PaperProps === null || PaperProps === void 0 ? void 0 : PaperProps.className), children }) }) });
}

// node_modules/mui-tiptap/dist/esm/LinkBubbleMenu/index.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());

// node_modules/mui-tiptap/dist/esm/context.js
var import_react10 = __toESM(require_react());
var RichTextEditorContext = (0, import_react10.createContext)(void 0);
function useRichTextEditorContext() {
  const editor = (0, import_react10.useContext)(RichTextEditorContext);
  if (editor === void 0) {
    throw new Error("Tiptap editor not found in component context. Be sure to use <RichTextEditorProvider editor={editor} />!");
  }
  return editor;
}

// node_modules/mui-tiptap/dist/esm/extensions/LinkBubbleMenuHandler.js
var LinkMenuState;
(function(LinkMenuState2) {
  LinkMenuState2[LinkMenuState2["HIDDEN"] = 0] = "HIDDEN";
  LinkMenuState2[LinkMenuState2["VIEW_LINK_DETAILS"] = 1] = "VIEW_LINK_DETAILS";
  LinkMenuState2[LinkMenuState2["EDIT_LINK"] = 2] = "EDIT_LINK";
})(LinkMenuState || (LinkMenuState = {}));
var LinkBubbleMenuHandler = Extension.create({
  name: "linkBubbleMenuHandler",
  addStorage() {
    return {
      state: LinkMenuState.HIDDEN,
      bubbleMenuOptions: void 0
    };
  },
  addCommands() {
    return {
      openLinkBubbleMenu: (bubbleMenuOptions = {}) => ({ editor, chain, dispatch }) => {
        const currentMenuState = this.storage.state;
        let newMenuState;
        if (editor.isActive("link")) {
          if (currentMenuState !== LinkMenuState.VIEW_LINK_DETAILS) {
            chain().extendMarkRange("link").focus().run();
          }
          newMenuState = LinkMenuState.VIEW_LINK_DETAILS;
        } else {
          newMenuState = LinkMenuState.EDIT_LINK;
        }
        if (dispatch) {
          this.storage.state = newMenuState;
          this.storage.bubbleMenuOptions = bubbleMenuOptions;
        }
        return true;
      },
      editLinkInBubbleMenu: () => ({ dispatch }) => {
        const currentMenuState = this.storage.state;
        const newMenuState = LinkMenuState.EDIT_LINK;
        if (currentMenuState === newMenuState) {
          return false;
        }
        if (dispatch) {
          this.storage.state = newMenuState;
        }
        return true;
      },
      closeLinkBubbleMenu: () => ({ commands, dispatch }) => {
        const currentMenuState = this.storage.state;
        if (currentMenuState === LinkMenuState.HIDDEN) {
          return false;
        }
        commands.focus();
        if (dispatch) {
          this.storage.state = LinkMenuState.HIDDEN;
        }
        return true;
      }
    };
  },
  onSelectionUpdate() {
    if (this.storage.state === LinkMenuState.EDIT_LINK) {
      this.editor.commands.closeLinkBubbleMenu();
    } else if (this.storage.state === LinkMenuState.VIEW_LINK_DETAILS && !this.editor.isActive("link")) {
      this.editor.commands.closeLinkBubbleMenu();
    }
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-u": () => {
        this.editor.commands.openLinkBubbleMenu();
        return true;
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("handleClickLinkForMenu"),
        props: {
          handleClick: (view, pos, event) => {
            const attrs = getAttributes(view.state, "link");
            const link = event.target.closest("a");
            if (link && attrs.href && this.storage.state === LinkMenuState.HIDDEN) {
              this.editor.commands.openLinkBubbleMenu();
            } else {
              this.editor.commands.closeLinkBubbleMenu();
            }
            return false;
          }
        }
      })
    ];
  }
});
var LinkBubbleMenuHandler_default = LinkBubbleMenuHandler;

// node_modules/mui-tiptap/dist/esm/LinkBubbleMenu/EditLinkMenuContent.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_react12 = __toESM(require_react());

// node_modules/mui-tiptap/dist/esm/hooks/useKeyDown.js
var import_react11 = __toESM(require_react());
function useKeyDown(key, callback) {
  const callbackRef = (0, import_react11.useRef)(callback);
  (0, import_react11.useEffect)(() => {
    callbackRef.current = callback;
  }, [callback]);
  (0, import_react11.useEffect)(() => {
    function handleKeyDown2(event) {
      if (key === event.key) {
        callbackRef.current(event);
      }
    }
    document.addEventListener("keydown", handleKeyDown2);
    return () => {
      document.removeEventListener("keydown", handleKeyDown2);
    };
  }, [key]);
}

// node_modules/mui-tiptap/dist/esm/utils/links.js
var import_encodeurl = __toESM(require_encodeurl());
function formatHref(value) {
  let currentHrefValue = value.trim();
  if (currentHrefValue && !/^(https?:\/\/|mailto:|tel:|sms:|\/|#)/.test(currentHrefValue)) {
    currentHrefValue = `http://${currentHrefValue}`;
  }
  return (0, import_encodeurl.default)(currentHrefValue);
}

// node_modules/mui-tiptap/dist/esm/LinkBubbleMenu/EditLinkMenuContent.js
function EditLinkMenuContent({ editor, onCancel, onSave, labels, formatHref: formatHref2 = formatHref }) {
  var _a, _b, _c, _d, _e, _f;
  const existingHref = editor.isActive("link") ? editor.getAttributes("link").href : "";
  const linkRange = getMarkRange(editor.state.selection.$from, getMarkType("link", editor.schema));
  const linkText = linkRange ? editor.state.doc.textBetween(linkRange.from, linkRange.to) : "";
  const selectedText = editor.state.doc.textBetween(editor.state.selection.$from.pos, editor.state.selection.$to.pos);
  const initialText = linkText || selectedText;
  const [textValue, setTextValue] = (0, import_react12.useState)(initialText);
  const [hrefValue, setHrefValue] = (0, import_react12.useState)(existingHref);
  const textRef = (0, import_react12.useRef)(null);
  const hrefRef = (0, import_react12.useRef)(null);
  const isNewLink = !existingHref;
  const addLinkTitle = (_a = labels === null || labels === void 0 ? void 0 : labels.editLinkAddTitle) !== null && _a !== void 0 ? _a : "Add link";
  const editLinkTitle = (_b = labels === null || labels === void 0 ? void 0 : labels.editLinkEditTitle) !== null && _b !== void 0 ? _b : "Edit link";
  const editMenuTitle = isNewLink ? addLinkTitle : editLinkTitle;
  (0, import_react12.useEffect)(() => {
    var _a2, _b2;
    const autoFocusOnTextInput = !isNewLink || !initialText;
    if (autoFocusOnTextInput) {
      (_a2 = textRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus({ preventScroll: true });
    } else {
      (_b2 = hrefRef.current) === null || _b2 === void 0 ? void 0 : _b2.focus({ preventScroll: true });
    }
  }, [isNewLink, initialText]);
  useKeyDown("Escape", onCancel);
  function formatAndSetHref() {
    if (!hrefRef.current) {
      return;
    }
    setHrefValue(formatHref2(hrefRef.current.value));
  }
  const [isSubmitting, setIsSubmitting] = (0, import_react12.useState)(false);
  return (0, import_jsx_runtime2.jsxs)("form", { onSubmit: (event) => {
    var _a2, _b2, _c2, _d2;
    event.preventDefault();
    event.stopPropagation();
    setIsSubmitting(true);
    const text = (_b2 = (_a2 = textRef.current) === null || _a2 === void 0 ? void 0 : _a2.value) !== null && _b2 !== void 0 ? _b2 : "";
    const href = (_d2 = (_c2 = hrefRef.current) === null || _c2 === void 0 ? void 0 : _c2.value) !== null && _d2 !== void 0 ? _d2 : "";
    onSave({ text, link: href });
    setIsSubmitting(false);
  }, autoComplete: "off", children: [(0, import_jsx_runtime2.jsx)(Typography_default, { variant: "h6", children: editMenuTitle }), (0, import_jsx_runtime2.jsx)(TextField_default, { inputRef: textRef, value: textValue, disabled: isSubmitting, onChange: (event) => {
    setTextValue(event.target.value);
  }, label: (_c = labels === null || labels === void 0 ? void 0 : labels.editLinkTextInputLabel) !== null && _c !== void 0 ? _c : "Text", margin: "normal", size: "small", fullWidth: true, required: true }), (0, import_jsx_runtime2.jsx)(TextField_default, {
    inputRef: hrefRef,
    value: hrefValue,
    onChange: (event) => {
      setHrefValue(event.target.value);
    },
    disabled: isSubmitting,
    label: (_d = labels === null || labels === void 0 ? void 0 : labels.editLinkHrefInputLabel) !== null && _d !== void 0 ? _d : "Link",
    margin: "dense",
    size: "small",
    type: "text",
    onBlur: formatAndSetHref,
    onKeyDown: (event) => {
      if (event.key === "Enter") {
        formatAndSetHref();
      }
    },
    fullWidth: true,
    required: true
  }), (0, import_jsx_runtime2.jsxs)(DialogActions_default, { sx: { px: 0 }, children: [(0, import_jsx_runtime2.jsx)(Button_default, { onClick: onCancel, variant: "outlined", size: "small", children: (_e = labels === null || labels === void 0 ? void 0 : labels.editLinkCancelButtonLabel) !== null && _e !== void 0 ? _e : "Cancel" }), (0, import_jsx_runtime2.jsx)(Button_default, { type: "submit", color: "primary", variant: "outlined", size: "small", disabled: isSubmitting, children: (_f = labels === null || labels === void 0 ? void 0 : labels.editLinkSaveButtonLabel) !== null && _f !== void 0 ? _f : "Save" })] })] });
}

// node_modules/mui-tiptap/dist/esm/LinkBubbleMenu/ViewLinkMenuContent.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var import_truncate = __toESM(require_truncate());

// node_modules/mui-tiptap/dist/esm/utils/truncateMiddle.js
function truncateMiddle(text, length = 20) {
  if (text.length <= length) {
    return text;
  }
  const half = Math.floor(length / 2);
  return `${text.slice(0, half).trim()}…${text.slice(-half).trim()}`;
}

// node_modules/mui-tiptap/dist/esm/LinkBubbleMenu/ViewLinkMenuContent.js
var useStyles4 = makeStyles({ name: { ViewLinkMenuContent } })({
  linkPreviewText: {
    overflowWrap: "anywhere"
  }
});
function ViewLinkMenuContent({ editor, onCancel, onEdit, onRemove, labels }) {
  var _a, _b, _c;
  const { classes } = useStyles4();
  const linkRange = getMarkRange(editor.state.selection.$to, getMarkType("link", editor.schema));
  const linkText = linkRange ? editor.state.doc.textBetween(linkRange.from, linkRange.to) : "";
  const currentHref = (_a = editor.getAttributes("link").href) !== null && _a !== void 0 ? _a : "";
  useKeyDown("Escape", onCancel);
  return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [(0, import_jsx_runtime3.jsx)("div", { className: classes.linkPreviewText, children: (0, import_truncate.default)(linkText, {
    length: 50,
    omission: "…"
  }) }), (0, import_jsx_runtime3.jsx)("div", { className: classes.linkPreviewText, children: (0, import_jsx_runtime3.jsx)(Link_default, { href: currentHref, target: "_blank", rel: "noopener", children: truncateMiddle(currentHref, 50) }) }), (0, import_jsx_runtime3.jsxs)(DialogActions_default, { sx: { px: 0 }, children: [(0, import_jsx_runtime3.jsx)(Button_default, { onClick: onEdit, color: "primary", variant: "outlined", size: "small", children: (_b = labels === null || labels === void 0 ? void 0 : labels.viewLinkEditButtonLabel) !== null && _b !== void 0 ? _b : "Edit" }), (0, import_jsx_runtime3.jsx)(Button_default, { onClick: onRemove, color: "error", variant: "outlined", size: "small", children: (_c = labels === null || labels === void 0 ? void 0 : labels.viewLinkRemoveButtonLabel) !== null && _c !== void 0 ? _c : "Remove" })] })] });
}

// node_modules/mui-tiptap/dist/esm/LinkBubbleMenu/index.js
var useStyles5 = makeStyles({ name: { LinkBubbleMenu } })((theme) => ({
  content: {
    padding: theme.spacing(1.5, 2, 0.5)
  }
}));
function LinkBubbleMenu({ labels, formatHref: formatHref2, ...controlledBubbleMenuProps }) {
  const { classes } = useStyles5();
  const editor = useRichTextEditorContext();
  if (!(editor === null || editor === void 0 ? void 0 : editor.isEditable)) {
    return null;
  }
  if (!("linkBubbleMenuHandler" in editor.storage)) {
    throw new Error("You must add the LinkBubbleMenuHandler extension to the useEditor `extensions` array in order to use this component!");
  }
  const handlerStorage = editor.storage.linkBubbleMenuHandler;
  const menuState = handlerStorage.state;
  let linkMenuContent = null;
  if (menuState === LinkMenuState.VIEW_LINK_DETAILS) {
    linkMenuContent = (0, import_jsx_runtime4.jsx)(ViewLinkMenuContent, { editor, onCancel: editor.commands.closeLinkBubbleMenu, onEdit: editor.commands.editLinkInBubbleMenu, onRemove: () => {
      editor.chain().unsetLink().setTextSelection(editor.state.selection.to).focus().run();
    }, labels });
  } else if (menuState === LinkMenuState.EDIT_LINK) {
    linkMenuContent = (0, import_jsx_runtime4.jsx)(EditLinkMenuContent, { editor, onCancel: editor.commands.closeLinkBubbleMenu, onSave: ({ text, link }) => {
      editor.chain().extendMarkRange("link").insertContent({
        type: "text",
        marks: [
          {
            type: "link",
            attrs: {
              href: link
            }
          }
        ],
        text
      }).setLink({
        href: link
      }).focus().run();
      editor.commands.closeLinkBubbleMenu();
    }, labels, formatHref: formatHref2 });
  }
  return (0, import_jsx_runtime4.jsx)(ControlledBubbleMenu, { editor, open: menuState !== LinkMenuState.HIDDEN, ...handlerStorage.bubbleMenuOptions, ...controlledBubbleMenuProps, children: (0, import_jsx_runtime4.jsx)("div", { className: classes.content, children: linkMenuContent }) });
}

// node_modules/mui-tiptap/dist/esm/MenuBar.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var menuBarClasses = getUtilityClasses("MenuBar", [
  "root",
  "sticky",
  "nonSticky",
  "content"
]);
var useStyles6 = makeStyles({
  name: { MenuBar }
})((theme, { stickyOffset }) => {
  return {
    root: {
      borderBottomColor: theme.palette.divider,
      borderBottomStyle: "solid",
      borderBottomWidth: 1
    },
    sticky: {
      position: "sticky",
      top: stickyOffset !== null && stickyOffset !== void 0 ? stickyOffset : 0,
      zIndex: Z_INDEXES.MENU_BAR,
      background: theme.palette.background.default
    },
    nonSticky: {},
    content: {}
  };
});
function MenuBar({ hide, disableSticky, stickyOffset, children, className, classes: overrideClasses, unmountOnExit = true, ...collapseProps }) {
  const { classes, cx } = useStyles6({ stickyOffset }, {
    props: { classes: overrideClasses }
  });
  return (0, import_jsx_runtime5.jsx)(Collapse_default, {
    ...collapseProps,
    in: !hide,
    unmountOnExit,
    // Note that we have to apply the sticky CSS classes to the container
    // (rather than the menu bar itself) in order for it to behave
    // properly
    className: cx(menuBarClasses.root, classes.root, disableSticky ? [menuBarClasses.nonSticky, classes.nonSticky] : [menuBarClasses.sticky, classes.sticky], className),
    children: (0, import_jsx_runtime5.jsx)("div", { className: classes.content, children })
  });
}

// node_modules/mui-tiptap/dist/esm/MenuDivider.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var useStyles7 = makeStyles({ name: { MenuDivider } })((theme) => ({
  root: {
    height: 18,
    margin: theme.spacing(0, 0.5)
  }
}));
function MenuDivider(props) {
  const { classes, cx } = useStyles7();
  return (0, import_jsx_runtime6.jsx)(Divider_default, { orientation: "vertical", ...props, className: cx(classes.root, props.className) });
}

// node_modules/mui-tiptap/dist/esm/RichTextContent.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());

// node_modules/@tiptap/react/dist/index.js
var import_react13 = __toESM(require_react());
var import_react14 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var import_shim = __toESM(require_shim());
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var import_react15 = __toESM(require_react());
var import_shim2 = __toESM(require_shim());
var import_react16 = __toESM(require_react2());
var import_react17 = __toESM(require_react());
var import_with_selector = __toESM(require_with_selector());
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var import_react18 = __toESM(require_react());
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var import_react19 = __toESM(require_react());
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var import_react20 = __toESM(require_react());
var import_react21 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var import_react22 = __toESM(require_react());
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var mergeRefs = (...refs) => {
  return (node) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(node);
      } else if (ref) {
        ;
        ref.current = node;
      }
    });
  };
};
var Portals = ({ contentComponent }) => {
  const renderers = (0, import_shim.useSyncExternalStore)(
    contentComponent.subscribe,
    contentComponent.getSnapshot,
    contentComponent.getServerSnapshot
  );
  return (0, import_jsx_runtime7.jsx)(import_jsx_runtime7.Fragment, { children: Object.values(renderers) });
};
function getInstance() {
  const subscribers = /* @__PURE__ */ new Set();
  let renderers = {};
  return {
    /**
     * Subscribe to the editor instance's changes.
     */
    subscribe(callback) {
      subscribers.add(callback);
      return () => {
        subscribers.delete(callback);
      };
    },
    getSnapshot() {
      return renderers;
    },
    getServerSnapshot() {
      return renderers;
    },
    /**
     * Adds a new NodeView Renderer to the editor.
     */
    setRenderer(id, renderer) {
      renderers = {
        ...renderers,
        [id]: import_react_dom.default.createPortal(renderer.reactElement, renderer.element, id)
      };
      subscribers.forEach((subscriber) => subscriber());
    },
    /**
     * Removes a NodeView Renderer from the editor.
     */
    removeRenderer(id) {
      const nextRenderers = { ...renderers };
      delete nextRenderers[id];
      renderers = nextRenderers;
      subscribers.forEach((subscriber) => subscriber());
    }
  };
}
var PureEditorContent = class extends import_react14.default.Component {
  constructor(props) {
    var _a;
    super(props);
    this.editorContentRef = import_react14.default.createRef();
    this.initialized = false;
    this.state = {
      hasContentComponentInitialized: Boolean((_a = props.editor) == null ? void 0 : _a.contentComponent)
    };
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate() {
    this.init();
  }
  init() {
    const editor = this.props.editor;
    if (editor && !editor.isDestroyed && editor.options.element) {
      if (editor.contentComponent) {
        return;
      }
      const element = this.editorContentRef.current;
      element.append(...editor.options.element.childNodes);
      editor.setOptions({
        element
      });
      editor.contentComponent = getInstance();
      if (!this.state.hasContentComponentInitialized) {
        this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {
          this.setState((prevState) => {
            if (!prevState.hasContentComponentInitialized) {
              return {
                hasContentComponentInitialized: true
              };
            }
            return prevState;
          });
          if (this.unsubscribeToContentComponent) {
            this.unsubscribeToContentComponent();
          }
        });
      }
      editor.createNodeViews();
      this.initialized = true;
    }
  }
  componentWillUnmount() {
    var _a;
    const editor = this.props.editor;
    if (!editor) {
      return;
    }
    this.initialized = false;
    if (!editor.isDestroyed) {
      editor.view.setProps({
        nodeViews: {}
      });
    }
    if (this.unsubscribeToContentComponent) {
      this.unsubscribeToContentComponent();
    }
    editor.contentComponent = null;
    if (!((_a = editor.options.element) == null ? void 0 : _a.firstChild)) {
      return;
    }
    const newElement = document.createElement("div");
    newElement.append(...editor.options.element.childNodes);
    editor.setOptions({
      element: newElement
    });
  }
  render() {
    const { editor, innerRef, ...rest } = this.props;
    return (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
      (0, import_jsx_runtime7.jsx)("div", { ref: mergeRefs(innerRef, this.editorContentRef), ...rest }),
      (editor == null ? void 0 : editor.contentComponent) && (0, import_jsx_runtime7.jsx)(Portals, { contentComponent: editor.contentComponent })
    ] });
  }
};
var EditorContentWithKey = (0, import_react14.forwardRef)(
  (props, ref) => {
    const key = import_react14.default.useMemo(() => {
      return Math.floor(Math.random() * 4294967295).toString();
    }, [props.editor]);
    return import_react14.default.createElement(PureEditorContent, {
      key,
      innerRef: ref,
      ...props
    });
  }
);
var EditorContent = import_react14.default.memo(EditorContentWithKey);
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react17.useLayoutEffect : import_react17.useEffect;
var EditorStateManager = class {
  constructor(initialEditor) {
    this.transactionNumber = 0;
    this.lastTransactionNumber = 0;
    this.subscribers = /* @__PURE__ */ new Set();
    this.editor = initialEditor;
    this.lastSnapshot = { editor: initialEditor, transactionNumber: 0 };
    this.getSnapshot = this.getSnapshot.bind(this);
    this.getServerSnapshot = this.getServerSnapshot.bind(this);
    this.watch = this.watch.bind(this);
    this.subscribe = this.subscribe.bind(this);
  }
  /**
   * Get the current editor instance.
   */
  getSnapshot() {
    if (this.transactionNumber === this.lastTransactionNumber) {
      return this.lastSnapshot;
    }
    this.lastTransactionNumber = this.transactionNumber;
    this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber };
    return this.lastSnapshot;
  }
  /**
   * Always disable the editor on the server-side.
   */
  getServerSnapshot() {
    return { editor: null, transactionNumber: 0 };
  }
  /**
   * Subscribe to the editor instance's changes.
   */
  subscribe(callback) {
    this.subscribers.add(callback);
    return () => {
      this.subscribers.delete(callback);
    };
  }
  /**
   * Watch the editor instance for changes.
   */
  watch(nextEditor) {
    this.editor = nextEditor;
    if (this.editor) {
      const fn = () => {
        this.transactionNumber += 1;
        this.subscribers.forEach((callback) => callback());
      };
      const currentEditor = this.editor;
      currentEditor.on("transaction", fn);
      return () => {
        currentEditor.off("transaction", fn);
      };
    }
    return void 0;
  }
};
function useEditorState(options) {
  var _a;
  const [editorStateManager] = (0, import_react17.useState)(() => new EditorStateManager(options.editor));
  const selectedState = (0, import_with_selector.useSyncExternalStoreWithSelector)(
    editorStateManager.subscribe,
    editorStateManager.getSnapshot,
    editorStateManager.getServerSnapshot,
    options.selector,
    (_a = options.equalityFn) != null ? _a : import_react16.default
  );
  useIsomorphicLayoutEffect(() => {
    return editorStateManager.watch(options.editor);
  }, [options.editor, editorStateManager]);
  (0, import_react17.useDebugValue)(selectedState);
  return selectedState;
}
var isDev = true;
var isSSR2 = typeof window === "undefined";
var isNext = isSSR2 || Boolean(typeof window !== "undefined" && window.next);
var EditorInstanceManager = class _EditorInstanceManager {
  constructor(options) {
    this.editor = null;
    this.subscriptions = /* @__PURE__ */ new Set();
    this.isComponentMounted = false;
    this.previousDeps = null;
    this.instanceId = "";
    this.options = options;
    this.subscriptions = /* @__PURE__ */ new Set();
    this.setEditor(this.getInitialEditor());
    this.scheduleDestroy();
    this.getEditor = this.getEditor.bind(this);
    this.getServerSnapshot = this.getServerSnapshot.bind(this);
    this.subscribe = this.subscribe.bind(this);
    this.refreshEditorInstance = this.refreshEditorInstance.bind(this);
    this.scheduleDestroy = this.scheduleDestroy.bind(this);
    this.onRender = this.onRender.bind(this);
    this.createEditor = this.createEditor.bind(this);
  }
  setEditor(editor) {
    this.editor = editor;
    this.instanceId = Math.random().toString(36).slice(2, 9);
    this.subscriptions.forEach((cb) => cb());
  }
  getInitialEditor() {
    if (this.options.current.immediatelyRender === void 0) {
      if (isSSR2 || isNext) {
        if (isDev) {
          throw new Error(
            "Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches."
          );
        }
        return null;
      }
      return this.createEditor();
    }
    if (this.options.current.immediatelyRender && isSSR2 && isDev) {
      throw new Error(
        "Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches."
      );
    }
    if (this.options.current.immediatelyRender) {
      return this.createEditor();
    }
    return null;
  }
  /**
   * Create a new editor instance. And attach event listeners.
   */
  createEditor() {
    const optionsToApply = {
      ...this.options.current,
      // Always call the most recent version of the callback function by default
      onBeforeCreate: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onBeforeCreate) == null ? void 0 : _b.call(_a, ...args);
      },
      onBlur: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onBlur) == null ? void 0 : _b.call(_a, ...args);
      },
      onCreate: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onCreate) == null ? void 0 : _b.call(_a, ...args);
      },
      onDestroy: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onDestroy) == null ? void 0 : _b.call(_a, ...args);
      },
      onFocus: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onFocus) == null ? void 0 : _b.call(_a, ...args);
      },
      onSelectionUpdate: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onSelectionUpdate) == null ? void 0 : _b.call(_a, ...args);
      },
      onTransaction: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onTransaction) == null ? void 0 : _b.call(_a, ...args);
      },
      onUpdate: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onUpdate) == null ? void 0 : _b.call(_a, ...args);
      },
      onContentError: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onContentError) == null ? void 0 : _b.call(_a, ...args);
      },
      onDrop: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onDrop) == null ? void 0 : _b.call(_a, ...args);
      },
      onPaste: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onPaste) == null ? void 0 : _b.call(_a, ...args);
      },
      onDelete: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onDelete) == null ? void 0 : _b.call(_a, ...args);
      }
    };
    const editor = new Editor(optionsToApply);
    return editor;
  }
  /**
   * Get the current editor instance.
   */
  getEditor() {
    return this.editor;
  }
  /**
   * Always disable the editor on the server-side.
   */
  getServerSnapshot() {
    return null;
  }
  /**
   * Subscribe to the editor instance's changes.
   */
  subscribe(onStoreChange) {
    this.subscriptions.add(onStoreChange);
    return () => {
      this.subscriptions.delete(onStoreChange);
    };
  }
  static compareOptions(a2, b2) {
    return Object.keys(a2).every((key) => {
      if ([
        "onCreate",
        "onBeforeCreate",
        "onDestroy",
        "onUpdate",
        "onTransaction",
        "onFocus",
        "onBlur",
        "onSelectionUpdate",
        "onContentError",
        "onDrop",
        "onPaste"
      ].includes(key)) {
        return true;
      }
      if (key === "extensions" && a2.extensions && b2.extensions) {
        if (a2.extensions.length !== b2.extensions.length) {
          return false;
        }
        return a2.extensions.every((extension, index) => {
          var _a;
          if (extension !== ((_a = b2.extensions) == null ? void 0 : _a[index])) {
            return false;
          }
          return true;
        });
      }
      if (a2[key] !== b2[key]) {
        return false;
      }
      return true;
    });
  }
  /**
   * On each render, we will create, update, or destroy the editor instance.
   * @param deps The dependencies to watch for changes
   * @returns A cleanup function
   */
  onRender(deps) {
    return () => {
      this.isComponentMounted = true;
      clearTimeout(this.scheduledDestructionTimeout);
      if (this.editor && !this.editor.isDestroyed && deps.length === 0) {
        if (!_EditorInstanceManager.compareOptions(this.options.current, this.editor.options)) {
          this.editor.setOptions({
            ...this.options.current,
            editable: this.editor.isEditable
          });
        }
      } else {
        this.refreshEditorInstance(deps);
      }
      return () => {
        this.isComponentMounted = false;
        this.scheduleDestroy();
      };
    };
  }
  /**
   * Recreate the editor instance if the dependencies have changed.
   */
  refreshEditorInstance(deps) {
    if (this.editor && !this.editor.isDestroyed) {
      if (this.previousDeps === null) {
        this.previousDeps = deps;
        return;
      }
      const depsAreEqual = this.previousDeps.length === deps.length && this.previousDeps.every((dep, index) => dep === deps[index]);
      if (depsAreEqual) {
        return;
      }
    }
    if (this.editor && !this.editor.isDestroyed) {
      this.editor.destroy();
    }
    this.setEditor(this.createEditor());
    this.previousDeps = deps;
  }
  /**
   * Schedule the destruction of the editor instance.
   * This will only destroy the editor if it was not mounted on the next tick.
   * This is to avoid destroying the editor instance when it's actually still mounted.
   */
  scheduleDestroy() {
    const currentInstanceId = this.instanceId;
    const currentEditor = this.editor;
    this.scheduledDestructionTimeout = setTimeout(() => {
      if (this.isComponentMounted && this.instanceId === currentInstanceId) {
        if (currentEditor) {
          currentEditor.setOptions(this.options.current);
        }
        return;
      }
      if (currentEditor && !currentEditor.isDestroyed) {
        currentEditor.destroy();
        if (this.instanceId === currentInstanceId) {
          this.setEditor(null);
        }
      }
    }, 1);
  }
};
function useEditor(options = {}, deps = []) {
  const mostRecentOptions = (0, import_react15.useRef)(options);
  mostRecentOptions.current = options;
  const [instanceManager] = (0, import_react15.useState)(() => new EditorInstanceManager(mostRecentOptions));
  const editor = (0, import_shim2.useSyncExternalStore)(
    instanceManager.subscribe,
    instanceManager.getEditor,
    instanceManager.getServerSnapshot
  );
  (0, import_react15.useDebugValue)(editor);
  (0, import_react15.useEffect)(instanceManager.onRender(deps));
  useEditorState({
    editor,
    selector: ({ transactionNumber }) => {
      if (options.shouldRerenderOnTransaction === false || options.shouldRerenderOnTransaction === void 0) {
        return null;
      }
      if (options.immediatelyRender && transactionNumber === 0) {
        return 0;
      }
      return transactionNumber + 1;
    }
  });
  return editor;
}
var EditorContext = (0, import_react13.createContext)({
  editor: null
});
var EditorConsumer = EditorContext.Consumer;
var ReactNodeViewContext = (0, import_react18.createContext)({
  onDragStart: () => {
  },
  nodeViewContentChildren: void 0,
  nodeViewContentRef: () => {
  }
});
var useReactNodeView = () => (0, import_react18.useContext)(ReactNodeViewContext);
function NodeViewContent({
  as: Tag = "div",
  ...props
}) {
  const { nodeViewContentRef, nodeViewContentChildren } = useReactNodeView();
  return (
    // @ts-ignore
    (0, import_jsx_runtime9.jsx)(
      Tag,
      {
        ...props,
        ref: nodeViewContentRef,
        "data-node-view-content": "",
        style: {
          whiteSpace: "pre-wrap",
          ...props.style
        },
        children: nodeViewContentChildren
      }
    )
  );
}
var NodeViewWrapper = import_react19.default.forwardRef((props, ref) => {
  const { onDragStart } = useReactNodeView();
  const Tag = props.as || "div";
  return (
    // @ts-ignore
    (0, import_jsx_runtime10.jsx)(
      Tag,
      {
        ...props,
        ref,
        "data-node-view-wrapper": "",
        onDragStart,
        style: {
          whiteSpace: "normal",
          ...props.style
        }
      }
    )
  );
});
function isClassComponent(Component2) {
  return !!(typeof Component2 === "function" && Component2.prototype && Component2.prototype.isReactComponent);
}
function isForwardRefComponent(Component2) {
  return !!(typeof Component2 === "object" && Component2.$$typeof && (Component2.$$typeof.toString() === "Symbol(react.forward_ref)" || Component2.$$typeof.description === "react.forward_ref"));
}
function isMemoComponent(Component2) {
  return !!(typeof Component2 === "object" && Component2.$$typeof && (Component2.$$typeof.toString() === "Symbol(react.memo)" || Component2.$$typeof.description === "react.memo"));
}
function canReceiveRef(Component2) {
  if (isClassComponent(Component2)) {
    return true;
  }
  if (isForwardRefComponent(Component2)) {
    return true;
  }
  if (isMemoComponent(Component2)) {
    const wrappedComponent = Component2.type;
    if (wrappedComponent) {
      return isClassComponent(wrappedComponent) || isForwardRefComponent(wrappedComponent);
    }
  }
  return false;
}
function isReact19Plus() {
  try {
    if (import_react21.version) {
      const majorVersion = parseInt(import_react21.version.split(".")[0], 10);
      return majorVersion >= 19;
    }
  } catch {
  }
  return false;
}
var ReactRenderer = class {
  /**
   * Immediately creates element and renders the provided React component.
   */
  constructor(component, { editor, props = {}, as = "div", className = "" }) {
    this.ref = null;
    this.id = Math.floor(Math.random() * 4294967295).toString();
    this.component = component;
    this.editor = editor;
    this.props = props;
    this.element = document.createElement(as);
    this.element.classList.add("react-renderer");
    if (className) {
      this.element.classList.add(...className.split(" "));
    }
    if (this.editor.isInitialized) {
      (0, import_react_dom2.flushSync)(() => {
        this.render();
      });
    } else {
      queueMicrotask(() => {
        this.render();
      });
    }
  }
  /**
   * Render the React component.
   */
  render() {
    var _a;
    const Component2 = this.component;
    const props = this.props;
    const editor = this.editor;
    const isReact19 = isReact19Plus();
    const componentCanReceiveRef = canReceiveRef(Component2);
    const elementProps = { ...props };
    if (elementProps.ref && !(isReact19 || componentCanReceiveRef)) {
      delete elementProps.ref;
    }
    if (!elementProps.ref && (isReact19 || componentCanReceiveRef)) {
      elementProps.ref = (ref) => {
        this.ref = ref;
      };
    }
    this.reactElement = (0, import_jsx_runtime11.jsx)(Component2, { ...elementProps });
    (_a = editor == null ? void 0 : editor.contentComponent) == null ? void 0 : _a.setRenderer(this.id, this);
  }
  /**
   * Re-renders the React component with new props.
   */
  updateProps(props = {}) {
    this.props = {
      ...this.props,
      ...props
    };
    this.render();
  }
  /**
   * Destroy the React component.
   */
  destroy() {
    var _a;
    const editor = this.editor;
    (_a = editor == null ? void 0 : editor.contentComponent) == null ? void 0 : _a.removeRenderer(this.id);
  }
  /**
   * Update the attributes of the element that holds the React component.
   */
  updateAttributes(attributes) {
    Object.keys(attributes).forEach((key) => {
      this.element.setAttribute(key, attributes[key]);
    });
  }
};
var ReactMarkViewContext = import_react20.default.createContext({
  markViewContentRef: () => {
  }
});
var ReactNodeView = class extends NodeView {
  constructor(component, props, options) {
    super(component, props, options);
    if (!this.node.isLeaf) {
      if (this.options.contentDOMElementTag) {
        this.contentDOMElement = document.createElement(this.options.contentDOMElementTag);
      } else {
        this.contentDOMElement = document.createElement(this.node.isInline ? "span" : "div");
      }
      this.contentDOMElement.dataset.nodeViewContentReact = "";
      this.contentDOMElement.dataset.nodeViewWrapper = "";
      this.contentDOMElement.style.whiteSpace = "inherit";
      const contentTarget = this.dom.querySelector("[data-node-view-content]");
      if (!contentTarget) {
        return;
      }
      contentTarget.appendChild(this.contentDOMElement);
    }
  }
  /**
   * Setup the React component.
   * Called on initialization.
   */
  mount() {
    const props = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      innerDecorations: this.innerDecorations,
      view: this.view,
      selected: false,
      extension: this.extension,
      HTMLAttributes: this.HTMLAttributes,
      getPos: () => this.getPos(),
      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),
      deleteNode: () => this.deleteNode(),
      ref: (0, import_react22.createRef)()
    };
    if (!this.component.displayName) {
      const capitalizeFirstChar = (string) => {
        return string.charAt(0).toUpperCase() + string.substring(1);
      };
      this.component.displayName = capitalizeFirstChar(this.extension.name);
    }
    const onDragStart = this.onDragStart.bind(this);
    const nodeViewContentRef = (element) => {
      if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {
        if (element.hasAttribute("data-node-view-wrapper")) {
          element.removeAttribute("data-node-view-wrapper");
        }
        element.appendChild(this.contentDOMElement);
      }
    };
    const context = { onDragStart, nodeViewContentRef };
    const Component2 = this.component;
    const ReactNodeViewProvider = (0, import_react22.memo)((componentProps) => {
      return (0, import_jsx_runtime13.jsx)(ReactNodeViewContext.Provider, { value: context, children: (0, import_react22.createElement)(Component2, componentProps) });
    });
    ReactNodeViewProvider.displayName = "ReactNodeView";
    let as = this.node.isInline ? "span" : "div";
    if (this.options.as) {
      as = this.options.as;
    }
    const { className = "" } = this.options;
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);
    this.renderer = new ReactRenderer(ReactNodeViewProvider, {
      editor: this.editor,
      props,
      as,
      className: `node-${this.node.type.name} ${className}`.trim()
    });
    this.editor.on("selectionUpdate", this.handleSelectionUpdate);
    this.updateElementAttributes();
  }
  /**
   * Return the DOM element.
   * This is the element that will be used to display the node view.
   */
  get dom() {
    var _a;
    if (this.renderer.element.firstElementChild && !((_a = this.renderer.element.firstElementChild) == null ? void 0 : _a.hasAttribute("data-node-view-wrapper"))) {
      throw Error("Please use the NodeViewWrapper component for your node view.");
    }
    return this.renderer.element;
  }
  /**
   * Return the content DOM element.
   * This is the element that will be used to display the rich-text content of the node.
   */
  get contentDOM() {
    if (this.node.isLeaf) {
      return null;
    }
    return this.contentDOMElement;
  }
  /**
   * On editor selection update, check if the node is selected.
   * If it is, call `selectNode`, otherwise call `deselectNode`.
   */
  handleSelectionUpdate() {
    const { from, to } = this.editor.state.selection;
    const pos = this.getPos();
    if (typeof pos !== "number") {
      return;
    }
    if (from <= pos && to >= pos + this.node.nodeSize) {
      if (this.renderer.props.selected) {
        return;
      }
      this.selectNode();
    } else {
      if (!this.renderer.props.selected) {
        return;
      }
      this.deselectNode();
    }
  }
  /**
   * On update, update the React component.
   * To prevent unnecessary updates, the `update` option can be used.
   */
  update(node, decorations, innerDecorations) {
    const rerenderComponent = (props) => {
      this.renderer.updateProps(props);
      if (typeof this.options.attrs === "function") {
        this.updateElementAttributes();
      }
    };
    if (node.type !== this.node.type) {
      return false;
    }
    if (typeof this.options.update === "function") {
      const oldNode = this.node;
      const oldDecorations = this.decorations;
      const oldInnerDecorations = this.innerDecorations;
      this.node = node;
      this.decorations = decorations;
      this.innerDecorations = innerDecorations;
      return this.options.update({
        oldNode,
        oldDecorations,
        newNode: node,
        newDecorations: decorations,
        oldInnerDecorations,
        innerDecorations,
        updateProps: () => rerenderComponent({ node, decorations, innerDecorations })
      });
    }
    if (node === this.node && this.decorations === decorations && this.innerDecorations === innerDecorations) {
      return true;
    }
    this.node = node;
    this.decorations = decorations;
    this.innerDecorations = innerDecorations;
    rerenderComponent({ node, decorations, innerDecorations });
    return true;
  }
  /**
   * Select the node.
   * Add the `selected` prop and the `ProseMirror-selectednode` class.
   */
  selectNode() {
    this.renderer.updateProps({
      selected: true
    });
    this.renderer.element.classList.add("ProseMirror-selectednode");
  }
  /**
   * Deselect the node.
   * Remove the `selected` prop and the `ProseMirror-selectednode` class.
   */
  deselectNode() {
    this.renderer.updateProps({
      selected: false
    });
    this.renderer.element.classList.remove("ProseMirror-selectednode");
  }
  /**
   * Destroy the React component instance.
   */
  destroy() {
    this.renderer.destroy();
    this.editor.off("selectionUpdate", this.handleSelectionUpdate);
    this.contentDOMElement = null;
  }
  /**
   * Update the attributes of the top-level element that holds the React component.
   * Applying the attributes defined in the `attrs` option.
   */
  updateElementAttributes() {
    if (this.options.attrs) {
      let attrsObj = {};
      if (typeof this.options.attrs === "function") {
        const extensionAttributes = this.editor.extensionManager.attributes;
        const HTMLAttributes = getRenderedAttributes(this.node, extensionAttributes);
        attrsObj = this.options.attrs({ node: this.node, HTMLAttributes });
      } else {
        attrsObj = this.options.attrs;
      }
      this.renderer.updateAttributes(attrsObj);
    }
  }
};
function ReactNodeViewRenderer(component, options) {
  return (props) => {
    if (!props.editor.contentComponent) {
      return {};
    }
    return new ReactNodeView(component, props, options);
  };
}

// node_modules/mui-tiptap/dist/esm/RichTextContent.js
var import_react24 = __toESM(require_react());
var richTextContentClasses = getUtilityClasses("RichTextContent", ["root", "readonly", "editable"]);
var useStyles8 = makeStyles({
  name: { RichTextContent }
})((theme, { disableDefaultStyles = false }) => {
  return {
    root: disableDefaultStyles ? {} : {
      // We add `as CSSObject` to get around typing issues with our editor
      // styles function. For future reference, this old issue and its
      // solution are related, though not quite right
      // https://github.com/garronej/tss-react/issues/2
      // https://github.com/garronej/tss-react/commit/9dc3f6f9f70b6df0bd83cd5689c3313467fb4f06
      "& .ProseMirror": {
        ...getEditorStyles(theme)
      }
    },
    // Styles applied when the editor is in read-only mode (editable=false)
    readonly: {},
    // Styles applied when the editor is editable (editable=true)
    editable: {}
  };
});
function RichTextContent({ className, classes: overrideClasses = {}, disableDefaultStyles = false, ...boxProps }) {
  const { classes, cx } = useStyles8({ disableDefaultStyles }, {
    props: { classes: overrideClasses }
  });
  const editor = useRichTextEditorContext();
  const editorClasses = (0, import_react24.useMemo)(() => cx(richTextContentClasses.root, className, classes.root, (editor === null || editor === void 0 ? void 0 : editor.isEditable) ? [richTextContentClasses.editable, classes.editable] : [richTextContentClasses.readonly, classes.readonly]), [className, classes, cx, editor === null || editor === void 0 ? void 0 : editor.isEditable]);
  return (0, import_jsx_runtime14.jsx)(Box_default, { ...boxProps, className: editorClasses, component: EditorContent, editor });
}

// node_modules/mui-tiptap/dist/esm/RichTextEditor.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var import_react28 = __toESM(require_react());

// node_modules/mui-tiptap/dist/esm/RichTextEditorProvider.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
function RichTextEditorProvider({ editor, children }) {
  return (0, import_jsx_runtime15.jsx)(RichTextEditorContext.Provider, { value: editor, children });
}

// node_modules/mui-tiptap/dist/esm/RichTextField.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());

// node_modules/mui-tiptap/dist/esm/FieldContainer.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var fieldContainerClasses = getUtilityClasses("FieldContainer", ["root", "outlined", "standard", "focused", "disabled", "notchedOutline"]);
var useStyles9 = makeStyles({
  name: { FieldContainer },
  uniqId: "Os7ZPW"
  // https://docs.tss-react.dev/nested-selectors#ssr
})((theme, _params, classes) => {
  return {
    root: {},
    // Class/styles applied to the root element if the component is using the
    // "outlined" variant
    outlined: {
      borderRadius: theme.shape.borderRadius,
      padding: 1,
      position: "relative",
      [`&:hover .${classes.notchedOutline}`]: {
        borderColor: theme.palette.text.primary
      },
      [`&.${classes.focused} .${classes.notchedOutline}`]: {
        borderColor: theme.palette.primary.main,
        borderWidth: 2
      },
      [`&.${classes.disabled} .${classes.notchedOutline}`]: {
        borderColor: theme.palette.action.disabled
      }
    },
    // Class/styles applied to the root element if the component is using the
    // "standard" variant
    standard: {},
    // Class/styles applied to the root element if the component is focused (if the
    // `focused` prop is true)
    focused: {},
    // Styles applied to the root element if the component is disabled (if the
    // `disabled` prop is true)
    disabled: {},
    notchedOutline: {
      position: "absolute",
      inset: 0,
      borderRadius: "inherit",
      borderColor: theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)",
      borderStyle: "solid",
      borderWidth: 1,
      pointerEvents: "none",
      overflow: "hidden",
      zIndex: Z_INDEXES.NOTCHED_OUTLINE
    }
  };
});
function FieldContainer({ variant = "outlined", children, focused, disabled, classes: overrideClasses = {}, className, ...boxProps }) {
  const { classes, cx } = useStyles9(void 0, {
    props: { classes: overrideClasses }
  });
  return (0, import_jsx_runtime16.jsxs)(Box_default, { ...boxProps, className: cx(
    fieldContainerClasses.root,
    classes.root,
    variant === "outlined" ? [fieldContainerClasses.outlined, classes.outlined] : [fieldContainerClasses.standard, classes.standard],
    // Note that we want focused and disabled styles of equal specificity to
    // trump default root/outlined/standard styles, so they should be defined
    // in this order
    focused && [fieldContainerClasses.focused, classes.focused],
    disabled && [fieldContainerClasses.disabled, classes.disabled],
    className
  ), children: [children, variant === "outlined" && (0, import_jsx_runtime16.jsx)("div", { className: cx(fieldContainerClasses.notchedOutline, classes.notchedOutline), "aria-hidden": true })] });
}

// node_modules/mui-tiptap/dist/esm/hooks/useDebouncedFocus.js
var import_debounce = __toESM(require_debounce());
var import_react25 = __toESM(require_react());
function useDebouncedFocus({ editor, wait = 250 }) {
  const [isFocusedDebounced, setIsFocusedDebounced] = (0, import_react25.useState)(!!(editor === null || editor === void 0 ? void 0 : editor.isFocused));
  const updateIsFocusedDebounced = (0, import_react25.useMemo)(() => (0, import_debounce.default)((focused) => {
    setIsFocusedDebounced(focused);
  }, wait), [wait]);
  (0, import_react25.useEffect)(() => {
    const isFocused = !!(editor === null || editor === void 0 ? void 0 : editor.isFocused);
    updateIsFocusedDebounced(isFocused);
    if (isFocused) {
      updateIsFocusedDebounced.flush();
    }
    return () => {
      updateIsFocusedDebounced.cancel();
    };
  }, [editor === null || editor === void 0 ? void 0 : editor.isFocused, updateIsFocusedDebounced]);
  return isFocusedDebounced;
}

// node_modules/mui-tiptap/dist/esm/utils/DebounceRender.js
var import_debounce2 = __toESM(require_debounce());
var import_react26 = __toESM(require_react());
var DebounceRender = class extends import_react26.Component {
  constructor(props) {
    var _a, _b;
    super(props);
    this.updateDebounced = (0, import_debounce2.default)(
      // eslint-disable-next-line @typescript-eslint/unbound-method
      this.forceUpdate,
      (_a = props.wait) !== null && _a !== void 0 ? _a : 170,
      (_b = props.options) !== null && _b !== void 0 ? _b : {
        leading: true,
        trailing: true,
        maxWait: 300
      }
    );
  }
  shouldComponentUpdate() {
    this.updateDebounced();
    return false;
  }
  componentWillUnmount() {
    this.updateDebounced.cancel();
  }
  render() {
    return this.props.children;
  }
};

// node_modules/mui-tiptap/dist/esm/RichTextField.js
var richTextFieldClasses = getUtilityClasses("RichTextField", ["root", "standard", "outlined", "menuBar", "menuBarContent", "content"]);
var useStyles10 = makeStyles({
  name: { RichTextField },
  uniqId: "E2Alw3"
  // https://docs.tss-react.dev/nested-selectors#ssr
})((theme, _params, classes) => {
  return {
    // This first class is added to allow convenient user overrides. Users can
    // similarly override the other classes below.
    root: {},
    standard: {
      // We don't need horizontal spacing when not using the outlined variant
      [`& .${classes.content}`]: {
        padding: theme.spacing(1.5, 0)
      },
      [`& .${classes.menuBarContent}`]: {
        padding: theme.spacing(1, 0)
      }
    },
    outlined: {
      // Add padding around the input area and menu bar, since they're
      // contained in the outline
      [`& .${classes.content}`]: {
        padding: theme.spacing(1.5)
      },
      [`& .${classes.menuBarContent}`]: {
        padding: theme.spacing(1, 1.5)
      }
    },
    menuBar: {},
    menuBarContent: {},
    content: {}
  };
});
function RichTextField({ variant = "outlined", controls, disableDebounceRenderControls = false, disabled, className, classes: overrideClasses = {}, footer, MenuBarProps, RichTextContentProps, ...fieldContainerProps }) {
  var _a, _b;
  const { classes, cx } = useStyles10(void 0, {
    props: { classes: overrideClasses }
  });
  const editor = useRichTextEditorContext();
  const isFieldFocused = useDebouncedFocus({ editor });
  return (0, import_jsx_runtime17.jsxs)(FieldContainer, { ...fieldContainerProps, variant, focused: !disabled && isFieldFocused, disabled, className: cx(richTextFieldClasses.root, classes.root, variant === "outlined" ? [richTextFieldClasses.outlined, classes.outlined] : [richTextFieldClasses.standard, classes.standard], className), children: [controls && (0, import_jsx_runtime17.jsx)(MenuBar, { ...MenuBarProps, classes: {
    ...MenuBarProps === null || MenuBarProps === void 0 ? void 0 : MenuBarProps.classes,
    root: cx(richTextFieldClasses.menuBar, classes.menuBar, (_a = MenuBarProps === null || MenuBarProps === void 0 ? void 0 : MenuBarProps.classes) === null || _a === void 0 ? void 0 : _a.root),
    content: cx(richTextFieldClasses.content, classes.menuBarContent, (_b = MenuBarProps === null || MenuBarProps === void 0 ? void 0 : MenuBarProps.classes) === null || _b === void 0 ? void 0 : _b.content)
  }, children: disableDebounceRenderControls ? controls : (0, import_jsx_runtime17.jsx)(DebounceRender, { children: controls }) }), (0, import_jsx_runtime17.jsx)(RichTextContent, { ...RichTextContentProps, className: cx(richTextFieldClasses.content, classes.content, RichTextContentProps === null || RichTextContentProps === void 0 ? void 0 : RichTextContentProps.className) }), footer] });
}

// node_modules/mui-tiptap/dist/esm/RichTextEditor.js
var RichTextEditor = (0, import_react28.forwardRef)(function RichTextEditor2({
  className,
  renderControls,
  RichTextFieldProps = {},
  sx,
  children,
  editorDependencies = [],
  // We default to `editable=true` just like `useEditor` does
  editable = true,
  // In Tiptap v3, shouldRerenderOnTransaction is `false` by default, but
  // this package currently relies on rerenders to keep controls/children
  // reactive, as was the behavior in v2. Enabling here preserves v2
  // behavior without requiring consumer changes, and including it should be
  // harmless in v2 versions that predate this option.
  shouldRerenderOnTransaction = true,
  ...editorOptions
}, ref) {
  const mergedEditorOptions = {
    editable,
    shouldRerenderOnTransaction,
    ...editorOptions
  };
  const editor = useEditor(mergedEditorOptions, editorDependencies);
  (0, import_react28.useImperativeHandle)(ref, () => ({
    editor
  }), [editor]);
  (0, import_react28.useEffect)(() => {
    if (
      // Tiptap v2 allowed `useEditor` to return undefined, so we keep the
      // defensive check here.
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      !editor || editor.isDestroyed || editor.isEditable === editable
    ) {
      return;
    }
    queueMicrotask(() => {
      editor.setEditable(editable);
    });
  }, [editable, editor]);
  return (0, import_jsx_runtime18.jsxs)(RichTextEditorProvider, { editor, children: [(0, import_jsx_runtime18.jsx)(RichTextField, { disabled: !editable, controls: renderControls === null || renderControls === void 0 ? void 0 : renderControls(editor), className, sx, ...RichTextFieldProps }), children === null || children === void 0 ? void 0 : children(editor)] });
});
var RichTextEditor_default = RichTextEditor;

// node_modules/mui-tiptap/dist/esm/RichTextReadOnly.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var import_react30 = __toESM(require_react());
function RichTextReadOnlyInternal({ RichTextContentProps, sx, ...editorOptions }) {
  const editor = useEditor({
    ...editorOptions,
    editable: false
  });
  const previousContent = (0, import_react30.useRef)(editorOptions.content);
  (0, import_react30.useEffect)(() => {
    if (
      // Tiptap v2 allowed `useEditor` to return undefined, so we keep the
      // defensive check here.
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      !editor || editor.isDestroyed || editorOptions.content === void 0 || editorOptions.content === previousContent.current
    ) {
      return;
    }
    queueMicrotask(() => {
      if (editorOptions.content !== void 0) {
        editor.commands.setContent(editorOptions.content);
      }
    });
  }, [editorOptions.content, editor]);
  (0, import_react30.useEffect)(() => {
    previousContent.current = editorOptions.content;
  }, [editorOptions.content]);
  return (0, import_jsx_runtime19.jsx)(RichTextEditorProvider, { editor, children: (0, import_jsx_runtime19.jsx)(RichTextContent, { sx, ...RichTextContentProps }) });
}
function RichTextReadOnly(props) {
  if (!props.content) {
    return null;
  }
  return (0, import_jsx_runtime19.jsx)(RichTextReadOnlyInternal, { ...props });
}

// node_modules/mui-tiptap/dist/esm/TableBubbleMenu.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime());
var import_react32 = __toESM(require_react());

// node_modules/mui-tiptap/dist/esm/controls/TableMenuControls.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/FormatColorFill.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var FormatColorFill_default = createSvgIcon((0, import_jsx_runtime20.jsx)("path", {
  d: "M16.56 8.94 7.62 0 6.21 1.41l2.38 2.38-5.15 5.15c-.59.59-.59 1.54 0 2.12l5.5 5.5c.29.29.68.44 1.06.44s.77-.15 1.06-.44l5.5-5.5c.59-.58.59-1.53 0-2.12M5.21 10 10 5.21 14.79 10zM19 11.5s-2 2.17-2 3.5c0 1.1.9 2 2 2s2-.9 2-2c0-1.33-2-3.5-2-3.5M2 20h20v4H2z"
}), "FormatColorFill");

// node_modules/@mui/icons-material/esm/GridOff.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
var GridOff_default = createSvgIcon((0, import_jsx_runtime21.jsx)("path", {
  d: "M8 4v1.45l2 2V4h4v4h-3.45l2 2H14v1.45l2 2V10h4v4h-3.45l2 2H20v1.45l2 2V4c0-1.1-.9-2-2-2H4.55l2 2zm8 0h4v4h-4zM1.27 1.27 0 2.55l2 2V20c0 1.1.9 2 2 2h15.46l2 2 1.27-1.27zM10 12.55 11.45 14H10zm-6-6L5.45 8H4zM8 20H4v-4h4zm0-6H4v-4h3.45l.55.55zm6 6h-4v-4h3.45l.55.54zm2 0v-1.46L17.46 20z"
}), "GridOff");

// node_modules/mui-tiptap/dist/esm/icons/BorderColorNoBar.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
var BorderColorNoBar = createSvgIcon((0, import_jsx_runtime22.jsx)("path", { d: "M 13.06 5.19 l 3.75 3.75 L 7.75 18 H 4 v -3.75 l 9.06 -9.06 z m 4.82 2.68 l -3.75 -3.75 l 1.83 -1.83 c 0.39 -0.39 1.02 -0.39 1.41 0 l 2.34 2.34 c 0.39 0.39 0.39 1.02 0 1.41 l -1.83 1.83 z" }), "BorderColorNoBar");

// node_modules/mui-tiptap/dist/esm/icons/CodeBlock.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var CodeBlock = createSvgIcon(
  // From https://boxicons.com/ (https://github.com/atisawd/boxicons)
  (0, import_jsx_runtime23.jsxs)(import_jsx_runtime23.Fragment, { children: [(0, import_jsx_runtime23.jsx)("path", { d: "M20 3H4c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h16c1.103 0 2-.897 2-2V5c0-1.103-.897-2-2-2zM4 19V7h16l.002 12H4z" }), (0, import_jsx_runtime23.jsx)("path", { d: "M9.293 9.293 5.586 13l3.707 3.707 1.414-1.414L8.414 13l2.293-2.293zm5.414 0-1.414 1.414L15.586 13l-2.293 2.293 1.414 1.414L18.414 13z" })] }),
  "CodeBlock"
);
var CodeBlock_default = CodeBlock;

// node_modules/mui-tiptap/dist/esm/icons/DeleteColumn.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
var DeleteColumn = createSvgIcon(
  // From https://remixicon.com/ (https://github.com/Remix-Design/RemixIcon)
  (0, import_jsx_runtime24.jsx)("path", { d: "M12 3C12.5523 3 13 3.44772 13 4L12.9998 11.9998C13.8355 11.372 14.8743 11 16 11C18.7614 11 21 13.2386 21 16C21 18.7614 18.7614 21 16 21C14.9681 21 14.0092 20.6874 13.2129 20.1518L13 20C13 20.5523 12.5523 21 12 21H6C5.44772 21 5 20.5523 5 20V4C5 3.44772 5.44772 3 6 3H12ZM11 5H7V19H11V5ZM19 15H13V17H19V15Z" }),
  "DeleteColumn"
);
var DeleteColumn_default = DeleteColumn;

// node_modules/mui-tiptap/dist/esm/icons/DeleteRow.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
var DeleteRow = createSvgIcon(
  // From https://remixicon.com/ (https://github.com/Remix-Design/RemixIcon)
  (0, import_jsx_runtime25.jsx)("path", { d: "M20 5C20.5523 5 21 5.44772 21 6V12C21 12.5523 20.5523 13 20 13C20.628 13.8355 21 14.8743 21 16C21 18.7614 18.7614 21 16 21C13.2386 21 11 18.7614 11 16C11 14.8743 11.372 13.8355 11.9998 12.9998L4 13C3.44772 13 3 12.5523 3 12V6C3 5.44772 3.44772 5 4 5H20ZM13 15V17H19V15H13ZM19 7H5V11H19V7Z" }),
  "DeleteRow"
);
var DeleteRow_default = DeleteRow;

// node_modules/mui-tiptap/dist/esm/icons/FormatColorBar.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
var FormatColorBar = createSvgIcon((0, import_jsx_runtime26.jsx)("path", { d: "M 2 20 h 20 v 4 H 2 v -4 z" }), "FormatColorBar");
var FormatColorBar_default = FormatColorBar;

// node_modules/mui-tiptap/dist/esm/icons/FormatColorFillNoBar.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
var FormatColorFillNoBar = createSvgIcon((0, import_jsx_runtime27.jsx)("path", { d: "M 16.56 8.94 L 7.62 0 L 6.21 1.41 l 2.38 2.38 l -5.15 5.15 c -0.59 0.59 -0.59 1.54 0 2.12 l 5.5 5.5 c 0.29 0.29 0.68 0.44 1.06 0.44 s 0.77 -0.15 1.06 -0.44 l 5.5 -5.5 c 0.59 -0.58 0.59 -1.53 0 -2.12 z M 5.21 10 L 10 5.21 L 14.79 10 H 5.21 z M 19 11.5 s -2 2.17 -2 3.5 c 0 1.1 0.9 2 2 2 s 2 -0.9 2 -2 c 0 -1.33 -2 -3.5 -2 -3.5 z" }), "FormatColorFillNoBar");

// node_modules/mui-tiptap/dist/esm/icons/FormatColorTextNoBar.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
var FormatColorTextNoBar = createSvgIcon((0, import_jsx_runtime28.jsx)("path", { d: "M 5.49 17 h 2.42 l 1.27 -3.58 h 5.65 L 16.09 17 h 2.42 L 13.25 3 h -2.5 L 5.49 17 z m 4.42 -5.61 l 2.03 -5.79 h 0.12 l 2.03 5.79 H 9.91 z" }), "FormatColorTextNoBar");
var FormatColorTextNoBar_default = FormatColorTextNoBar;

// node_modules/mui-tiptap/dist/esm/icons/FormatInkHighlighter.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
var FormatInkHighlighter = createSvgIcon(
  // Part of Material Symbols (and so unfortunately not in @mui/icons-material),
  // this SVG was downloaded from https://iconbuddy.app, and a similar source
  // version can be found here
  // https://fonts.google.com/icons?icon.query=highlight&icon.set=Material+Symbols.
  (0, import_jsx_runtime29.jsx)("path", { d: "M2 24v-4h20v4H2Zm8.6-16l5.4 5.425l-4 4q-.6.6-1.413.6t-1.412-.6L8.5 18h-5l3.15-3.125q-.6-.6-.625-1.438T6.6 12l4-4ZM12 6.575L16 2.6q.6-.6 1.413-.6t1.412.6l2.6 2.575q.6.6.6 1.413T21.425 8l-4 4L12 6.575Z" }),
  "FormatInkHighlighter"
);
var FormatInkHighlighter_default = FormatInkHighlighter;

// node_modules/mui-tiptap/dist/esm/icons/FormatInkHighlighterNoBar.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime());
var FormatInkHighlighterNoBar = createSvgIcon((0, import_jsx_runtime30.jsx)("path", { d: "M 10.6 8 l 5.4 5.425 l -4 4 q -0.6 0.6 -1.413 0.6 t -1.412 -0.6 L 8.5 18 h -5 l 3.15 -3.125 q -0.6 -0.6 -0.625 -1.438 T 6.6 12 l 4 -4 Z M 12 6.575 L 16 2.6 q 0.6 -0.6 1.413 -0.6 t 1.412 0.6 l 2.6 2.575 q 0.6 0.6 0.6 1.413 T 21.425 8 l -4 4 L 12 6.575 Z" }), "FormatInkHighlighterNoBar");
var FormatInkHighlighterNoBar_default = FormatInkHighlighterNoBar;

// node_modules/mui-tiptap/dist/esm/icons/InsertColumnLeft.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime());
var InsertColumnLeft = createSvgIcon(
  // From https://remixicon.com/ (https://github.com/Remix-Design/RemixIcon)
  (0, import_jsx_runtime31.jsx)("path", { d: "M20 3C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H14C13.4477 21 13 20.5523 13 20V4C13 3.44772 13.4477 3 14 3H20ZM19 5H15V19H19V5ZM6 7C8.76142 7 11 9.23858 11 12C11 14.7614 8.76142 17 6 17C3.23858 17 1 14.7614 1 12C1 9.23858 3.23858 7 6 7ZM7 9H5V10.999L3 11V13L5 12.999V15H7V12.999L9 13V11L7 10.999V9Z" }),
  "InsertColumnLeft"
);
var InsertColumnLeft_default = InsertColumnLeft;

// node_modules/mui-tiptap/dist/esm/icons/InsertColumnRight.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime());
var InsertColumnRight = createSvgIcon(
  // From https://remixicon.com/ (https://github.com/Remix-Design/RemixIcon)
  (0, import_jsx_runtime32.jsx)("path", { d: "M10 3C10.5523 3 11 3.44772 11 4V20C11 20.5523 10.5523 21 10 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3H10ZM9 5H5V19H9V5ZM18 7C20.7614 7 23 9.23858 23 12C23 14.7614 20.7614 17 18 17C15.2386 17 13 14.7614 13 12C13 9.23858 15.2386 7 18 7ZM19 9H17V10.999L15 11V13L17 12.999V15H19V12.999L21 13V11L19 10.999V9Z" }),
  "InsertColumnRight"
);
var InsertColumnRight_default = InsertColumnRight;

// node_modules/mui-tiptap/dist/esm/icons/InsertRowBottom.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime());
var InsertRowBottom = createSvgIcon(
  // From https://remixicon.com/ (https://github.com/Remix-Design/RemixIcon)
  (0, import_jsx_runtime33.jsx)("path", { d: "M12 13C14.7614 13 17 15.2386 17 18C17 20.7614 14.7614 23 12 23C9.23858 23 7 20.7614 7 18C7 15.2386 9.23858 13 12 13ZM13 15H11V16.999L9 17V19L11 18.999V21H13V18.999L15 19V17L13 16.999V15ZM20 3C20.5523 3 21 3.44772 21 4V10C21 10.5523 20.5523 11 20 11H4C3.44772 11 3 10.5523 3 10V4C3 3.44772 3.44772 3 4 3H20ZM5 5V9H19V5H5Z" }),
  "InsertRowBottom"
);
var InsertRowBottom_default = InsertRowBottom;

// node_modules/mui-tiptap/dist/esm/icons/InsertRowTop.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime());
var InsertRowTop = createSvgIcon(
  // From https://remixicon.com/ (https://github.com/Remix-Design/RemixIcon)
  (0, import_jsx_runtime34.jsx)("path", { d: "M20 13C20.5523 13 21 13.4477 21 14V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V14C3 13.4477 3.44772 13 4 13H20ZM19 15H5V19H19V15ZM12 1C14.7614 1 17 3.23858 17 6C17 8.76142 14.7614 11 12 11C9.23858 11 7 8.76142 7 6C7 3.23858 9.23858 1 12 1ZM13 3H11V4.999L9 5V7L11 6.999V9H13V6.999L15 7V5L13 4.999V3Z" }),
  "InsertRowTop"
);
var InsertRowTop_default = InsertRowTop;

// node_modules/mui-tiptap/dist/esm/icons/LayoutColumnFill.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime());
var LayoutColumnFill = createSvgIcon(
  // From https://remixicon.com/ (https://github.com/Remix-Design/RemixIcon)
  (0, import_jsx_runtime35.jsx)("path", { d: "M12 5V19H19V5H12ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3Z" }),
  "LayoutColumnFill"
);
var LayoutColumnFill_default = LayoutColumnFill;

// node_modules/mui-tiptap/dist/esm/icons/LayoutRowFill.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime());
var LayoutRowFill = createSvgIcon(
  // From https://remixicon.com/ (https://github.com/Remix-Design/RemixIcon)
  (0, import_jsx_runtime36.jsx)("path", { d: "M19 12H5V19H19V12ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3Z" }),
  "LayoutRowFill"
);
var LayoutRowFill_default = LayoutRowFill;

// node_modules/mui-tiptap/dist/esm/icons/MergeCellsHorizontal.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime());
var MergeCellsHorizontal = createSvgIcon(
  // From https://remixicon.com/ (https://github.com/Remix-Design/RemixIcon)
  (0, import_jsx_runtime37.jsx)("path", { d: "M20 3C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3H20ZM11 5H5V10.999H7V9L10 12L7 15V13H5V19H11V17H13V19H19V13H17V15L14 12L17 9V10.999H19V5H13V7H11V5ZM13 13V15H11V13H13ZM13 9V11H11V9H13Z" }),
  "MergeCellsHorizontal"
);
var MergeCellsHorizontal_default = MergeCellsHorizontal;

// node_modules/mui-tiptap/dist/esm/icons/SplitCellsHorizontal.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime());
var SplitCellsHorizontal = createSvgIcon(
  // From https://remixicon.com/ (https://github.com/Remix-Design/RemixIcon)
  (0, import_jsx_runtime38.jsx)("path", { d: "M20 3C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3H20ZM11 5H5V19H11V15H13V19H19V5H13V9H11V5ZM15 9L18 12L15 15V13H9V15L6 12L9 9V11H15V9Z" }),
  "SplitCellsHorizontal"
);
var SplitCellsHorizontal_default = SplitCellsHorizontal;

// node_modules/mui-tiptap/dist/esm/icons/Table.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime());
var Table = createSvgIcon(
  // From https://boxicons.com/ (https://github.com/atisawd/boxicons)
  (0, import_jsx_runtime39.jsx)("path", { d: "M4 21h15.893c1.103 0 2-.897 2-2V5c0-1.103-.897-2-2-2H4c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2zm0-2v-5h4v5H4zM14 7v5h-4V7h4zM8 7v5H4V7h4zm2 12v-5h4v5h-4zm6 0v-5h3.894v5H16zm3.893-7H16V7h3.893v5z" }),
  "Table"
);
var Table_default = Table;

// node_modules/mui-tiptap/dist/esm/controls/MenuButton.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime());

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonTooltip.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime());

// node_modules/mui-tiptap/dist/esm/utils/platform.js
var isMacResult;
var isTouchDeviceResult;
function isMac() {
  if (isMacResult === void 0) {
    isMacResult = navigator.platform.includes("Mac");
  }
  return isMacResult;
}
function getModShortcutKey() {
  return isMac() ? "⌘" : "Ctrl";
}
function isTouchDevice() {
  if (isTouchDeviceResult === void 0) {
    isTouchDeviceResult = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    window && "ontouchstart" in window || navigator.maxTouchPoints > 0 || // @ts-expect-error: msMaxTouchPoints is IE-specific, so needs to be ignored
    navigator.msMaxTouchPoints > 0;
  }
  return isTouchDeviceResult;
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonTooltip.js
var useStyles11 = makeStyles({ name: { MenuButtonTooltip } })((theme) => ({
  titleContainer: {
    textAlign: "center"
  },
  label: {
    fontSize: theme.typography.pxToRem(13)
  },
  shortcutKey: {
    fontSize: theme.typography.pxToRem(12),
    border: `1px solid ${alpha(theme.palette.text.secondary, 0.2)}`,
    backgroundColor: alpha(theme.palette.background.paper, 0.3),
    height: "19px",
    lineHeight: "19px",
    padding: "0 4px",
    minWidth: 17,
    borderRadius: theme.shape.borderRadius,
    display: "inline-block",
    "&:not(:first-of-type)": {
      marginLeft: 1
    }
  }
}));
function MenuButtonTooltip({ label, shortcutKeys, placement = "top", contentWrapperClassName, children, ...otherTooltipProps }) {
  const { classes } = useStyles11();
  return (0, import_jsx_runtime40.jsx)(Tooltip_default, { title: label || shortcutKeys && shortcutKeys.length > 0 ? (0, import_jsx_runtime40.jsxs)("div", { className: classes.titleContainer, children: [(0, import_jsx_runtime40.jsx)("div", { className: classes.label, children: label }), shortcutKeys && shortcutKeys.length > 0 && (0, import_jsx_runtime40.jsx)(Typography_default, { variant: "body2", component: "div", children: shortcutKeys.map((shortcutKey, index) => (0, import_jsx_runtime40.jsx)("span", { className: classes.shortcutKey, children: shortcutKey === "mod" ? getModShortcutKey() : shortcutKey }, index)) })] }) : "", placement, arrow: true, ...otherTooltipProps, children: (0, import_jsx_runtime40.jsx)("span", { className: contentWrapperClassName, children }) });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButton.js
var MENU_BUTTON_FONT_SIZE_DEFAULT = "1.25rem";
var useStyles12 = makeStyles({ name: { MenuButton } })({
  root: {
    // Use && for additional specificity, since MUI's conditional "disabled"
    // styles also set the border
    [`&& .${toggleButtonClasses_default.root}`]: {
      border: "none",
      padding: 5
    }
  },
  menuButtonIcon: {
    fontSize: MENU_BUTTON_FONT_SIZE_DEFAULT
  }
});
function MenuButton({ tooltipLabel, tooltipShortcutKeys, IconComponent, buttonRef, children, ...toggleButtonProps }) {
  const { classes } = useStyles12();
  return (0, import_jsx_runtime41.jsx)("span", { className: classes.root, children: (0, import_jsx_runtime41.jsx)(MenuButtonTooltip, { label: tooltipLabel, shortcutKeys: tooltipShortcutKeys, children: (0, import_jsx_runtime41.jsx)(ToggleButton_default, { ref: buttonRef, size: "small", value: tooltipLabel, ...toggleButtonProps, children: children !== null && children !== void 0 ? children : IconComponent && (0, import_jsx_runtime41.jsx)(IconComponent, { className: classes.menuButtonIcon }) }) }) });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuControlsContainer.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime());
var useStyles13 = makeStyles({
  name: { MenuControlsContainer }
})((theme) => {
  return {
    root: {
      display: "flex",
      rowGap: theme.spacing(0.3),
      columnGap: theme.spacing(0.3),
      alignItems: "center",
      flexWrap: "wrap"
    }
  };
});
function MenuControlsContainer({ children, className, debounced, DebounceProps, ...boxProps }) {
  const { classes, cx } = useStyles13();
  const content = (0, import_jsx_runtime42.jsx)(Box_default, { ...boxProps, className: cx(classes.root, className), children });
  return debounced ? (0, import_jsx_runtime42.jsx)(DebounceRender, { ...DebounceProps, children: content }) : content;
}

// node_modules/mui-tiptap/dist/esm/controls/TableMenuControls.js
function TableMenuControls({ className, labels }) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime43.jsxs)(MenuControlsContainer, { className, children: [(0, import_jsx_runtime43.jsx)(MenuButton, { tooltipLabel: (_a = labels === null || labels === void 0 ? void 0 : labels.insertColumnBefore) !== null && _a !== void 0 ? _a : "Insert column before", IconComponent: InsertColumnLeft_default, onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().addColumnBefore().run(), disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().addColumnBefore()) }), (0, import_jsx_runtime43.jsx)(MenuButton, { tooltipLabel: (_b = labels === null || labels === void 0 ? void 0 : labels.insertColumnAfter) !== null && _b !== void 0 ? _b : "Insert column after", IconComponent: InsertColumnRight_default, onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().addColumnAfter().run(), disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().addColumnAfter()) }), (0, import_jsx_runtime43.jsx)(MenuButton, { tooltipLabel: (_c = labels === null || labels === void 0 ? void 0 : labels.deleteColumn) !== null && _c !== void 0 ? _c : "Delete column", IconComponent: DeleteColumn_default, onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().deleteColumn().run(), disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().deleteColumn()) }), (0, import_jsx_runtime43.jsx)(MenuDivider, {}), (0, import_jsx_runtime43.jsx)(MenuButton, { tooltipLabel: (_d = labels === null || labels === void 0 ? void 0 : labels.insertRowAbove) !== null && _d !== void 0 ? _d : "Insert row above", IconComponent: InsertRowTop_default, onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().addRowBefore().run(), disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().addRowBefore()) }), (0, import_jsx_runtime43.jsx)(MenuButton, { tooltipLabel: (_e = labels === null || labels === void 0 ? void 0 : labels.insertRowBelow) !== null && _e !== void 0 ? _e : "Insert row below", IconComponent: InsertRowBottom_default, onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().addRowAfter().run(), disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().addRowAfter()) }), (0, import_jsx_runtime43.jsx)(MenuButton, { tooltipLabel: (_f = labels === null || labels === void 0 ? void 0 : labels.deleteRow) !== null && _f !== void 0 ? _f : "Delete row", IconComponent: DeleteRow_default, onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().deleteRow().run(), disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().deleteRow()) }), (0, import_jsx_runtime43.jsx)(MenuDivider, {}), (0, import_jsx_runtime43.jsx)(MenuButton, { tooltipLabel: (_g = labels === null || labels === void 0 ? void 0 : labels.mergeCells) !== null && _g !== void 0 ? _g : "Merge cells", IconComponent: MergeCellsHorizontal_default, onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().mergeCells().run(), disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().mergeCells()) }), (0, import_jsx_runtime43.jsx)(MenuButton, { tooltipLabel: (_h = labels === null || labels === void 0 ? void 0 : labels.splitCell) !== null && _h !== void 0 ? _h : "Split cell", IconComponent: SplitCellsHorizontal_default, onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().splitCell().run(), disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().splitCell()) }), (0, import_jsx_runtime43.jsx)(MenuDivider, {}), (0, import_jsx_runtime43.jsx)(MenuButton, { tooltipLabel: (_j = labels === null || labels === void 0 ? void 0 : labels.toggleHeaderRow) !== null && _j !== void 0 ? _j : "Toggle header row", IconComponent: LayoutRowFill_default, onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleHeaderRow().run(), disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().toggleHeaderRow()) }), (0, import_jsx_runtime43.jsx)(MenuButton, { tooltipLabel: (_k = labels === null || labels === void 0 ? void 0 : labels.toggleHeaderColumn) !== null && _k !== void 0 ? _k : "Toggle header column", IconComponent: LayoutColumnFill_default, onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleHeaderColumn().run(), disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().toggleHeaderColumn()) }), (0, import_jsx_runtime43.jsx)(MenuButton, { tooltipLabel: (_l = labels === null || labels === void 0 ? void 0 : labels.toggleHeaderCell) !== null && _l !== void 0 ? _l : "Toggle header cell", IconComponent: FormatColorFill_default, onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleHeaderCell().run(), disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().toggleHeaderCell()), selected: (_m = editor === null || editor === void 0 ? void 0 : editor.isActive("tableHeader")) !== null && _m !== void 0 ? _m : false }), (0, import_jsx_runtime43.jsx)(MenuDivider, {}), (0, import_jsx_runtime43.jsx)(MenuButton, { tooltipLabel: (_o = labels === null || labels === void 0 ? void 0 : labels.deleteTable) !== null && _o !== void 0 ? _o : "Delete table", IconComponent: GridOff_default, onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().deleteTable().run(), disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().deleteTable()) })] });
}

// node_modules/mui-tiptap/dist/esm/hooks/useEditorOnEditableUpdate.js
var import_react31 = __toESM(require_react());
function useEditorOnEditableUpdate({ editor, callback }) {
  const callbackRef = (0, import_react31.useRef)(callback);
  const isEditableRef = (0, import_react31.useRef)(editor === null || editor === void 0 ? void 0 : editor.isEditable);
  (0, import_react31.useEffect)(() => {
    callbackRef.current = callback;
  }, [callback]);
  const hasCallback = !!callback;
  (0, import_react31.useEffect)(() => {
    if (!editor || editor.isDestroyed || !hasCallback) {
      return;
    }
    isEditableRef.current = editor.isEditable;
    function handleUpdate(props) {
      var _a;
      if (!editor || editor.isDestroyed || editor.isEditable === isEditableRef.current) {
        return;
      }
      isEditableRef.current = editor.isEditable;
      (_a = callbackRef.current) === null || _a === void 0 ? void 0 : _a.call(callbackRef, props);
    }
    editor.on("update", handleUpdate);
    return () => {
      editor.off("update", handleUpdate);
    };
  }, [editor, hasCallback]);
}

// node_modules/mui-tiptap/dist/esm/TableBubbleMenu.js
var useStyles14 = makeStyles({
  name: { TableBubbleMenu }
})((theme) => ({
  controls: {
    maxWidth: "90vw",
    padding: theme.spacing(0.5, 1)
  }
}));
function TableBubbleMenu({ disableDebounce = false, DebounceProps, labels, ...controlledBubbleMenuProps }) {
  const editor = useRichTextEditorContext();
  const { classes } = useStyles14();
  const isEditorFocusedDebounced = useDebouncedFocus({ editor });
  const bubbleMenuAnchorEl = (0, import_react32.useMemo)(() => editor ? {
    getBoundingClientRect: () => {
      const nearestTableParent = editor.isActive("table") ? findParentNodeClosestToPos(editor.state.selection.$anchor, (node) => node.type.name === "table") : null;
      if (nearestTableParent) {
        const wrapperDomNode = editor.view.nodeDOM(nearestTableParent.pos);
        const tableDomNode = wrapperDomNode === null || wrapperDomNode === void 0 ? void 0 : wrapperDomNode.querySelector("table");
        if (tableDomNode) {
          return tableDomNode.getBoundingClientRect();
        }
      }
      const { ranges } = editor.state.selection;
      const from = Math.min(...ranges.map((range) => range.$from.pos));
      const to = Math.max(...ranges.map((range) => range.$to.pos));
      return posToDOMRect(editor.view, from, to);
    }
  } : null, [editor]);
  if (!(editor === null || editor === void 0 ? void 0 : editor.isEditable)) {
    return null;
  }
  const controls = (0, import_jsx_runtime44.jsx)(TableMenuControls, { className: classes.controls, labels });
  return (0, import_jsx_runtime44.jsx)(ControlledBubbleMenu, {
    editor,
    open: isEditorFocusedDebounced && editor.isActive("table"),
    anchorEl: bubbleMenuAnchorEl,
    // So the menu doesn't move as columns are added, removed, or resized, we
    // prefer "foo-start" rather than the centered "foo" placement. Similarly,
    // we prefer "top" to "bottom" so that the menu doesn't move as the number
    // and size of rows changes.
    placement: "top-start",
    fallbackPlacements: [
      "bottom-start",
      "top",
      "bottom",
      "top-end",
      "bottom-end"
    ],
    // Though we prefer for the menu to stay on top if there's room, we
    // definitely do not want the table bubble menu to cover up the main
    // editor menu bar, which is typically going to be above the editor, since
    // users are likely to want to change styles of elements within a table
    // while using/editing a table. This overlap could happen if the Table is
    // the first element within the editor content, or if the content is long
    // and the menu bar is sticky, with the user having scrolled such that a
    // table is at the top of the page. What would be nice is if PopperJS let
    // you specify a placement to use if the `placement` *and none of the
    // fallbacks* are satisfied, so that we could default to "bottom-start" in
    // that scenario rather than the main `placement` value of "top-start".
    // Since that is not an option, we add an artificial infinite negative
    // bottom padding (so that it's like we actually have infinite extra room
    // below our table bubble menu within the editor) as a way to ensure we
    // only fall back to bottom placements if the top has no room. Similarly
    // we add a top padding equal to what should give us enough room to avoid
    // overlapping the main menu bar.
    flipPadding: { top: 35, left: 8, right: 8, bottom: -Infinity },
    ...controlledBubbleMenuProps,
    children: disableDebounce ? controls : (0, import_jsx_runtime44.jsx)(DebounceRender, { ...DebounceProps, children: controls })
  });
}

// node_modules/mui-tiptap/dist/esm/controls/ColorPicker.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime());
var import_react35 = __toESM(require_react());

// node_modules/react-colorful/dist/index.mjs
var import_react33 = __toESM(require_react(), 1);
function u() {
  return (u = Object.assign || function(e2) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = arguments[r2];
      for (var n2 in t2) Object.prototype.hasOwnProperty.call(t2, n2) && (e2[n2] = t2[n2]);
    }
    return e2;
  }).apply(this, arguments);
}
function c(e2, r2) {
  if (null == e2) return {};
  var t2, n2, o2 = {}, a2 = Object.keys(e2);
  for (n2 = 0; n2 < a2.length; n2++) r2.indexOf(t2 = a2[n2]) >= 0 || (o2[t2] = e2[t2]);
  return o2;
}
function i(e2) {
  var t2 = (0, import_react33.useRef)(e2), n2 = (0, import_react33.useRef)(function(e3) {
    t2.current && t2.current(e3);
  });
  return t2.current = e2, n2.current;
}
var s = function(e2, r2, t2) {
  return void 0 === r2 && (r2 = 0), void 0 === t2 && (t2 = 1), e2 > t2 ? t2 : e2 < r2 ? r2 : e2;
};
var f = function(e2) {
  return "touches" in e2;
};
var v = function(e2) {
  return e2 && e2.ownerDocument.defaultView || self;
};
var d = function(e2, r2, t2) {
  var n2 = e2.getBoundingClientRect(), o2 = f(r2) ? function(e3, r3) {
    for (var t3 = 0; t3 < e3.length; t3++) if (e3[t3].identifier === r3) return e3[t3];
    return e3[0];
  }(r2.touches, t2) : r2;
  return { left: s((o2.pageX - (n2.left + v(e2).pageXOffset)) / n2.width), top: s((o2.pageY - (n2.top + v(e2).pageYOffset)) / n2.height) };
};
var h = function(e2) {
  !f(e2) && e2.preventDefault();
};
var m = import_react33.default.memo(function(o2) {
  var a2 = o2.onMove, l2 = o2.onKey, s2 = c(o2, ["onMove", "onKey"]), m2 = (0, import_react33.useRef)(null), g2 = i(a2), p2 = i(l2), b2 = (0, import_react33.useRef)(null), _2 = (0, import_react33.useRef)(false), x2 = (0, import_react33.useMemo)(function() {
    var e2 = function(e3) {
      h(e3), (f(e3) ? e3.touches.length > 0 : e3.buttons > 0) && m2.current ? g2(d(m2.current, e3, b2.current)) : t2(false);
    }, r2 = function() {
      return t2(false);
    };
    function t2(t3) {
      var n2 = _2.current, o3 = v(m2.current), a3 = t3 ? o3.addEventListener : o3.removeEventListener;
      a3(n2 ? "touchmove" : "mousemove", e2), a3(n2 ? "touchend" : "mouseup", r2);
    }
    return [function(e3) {
      var r3 = e3.nativeEvent, n2 = m2.current;
      if (n2 && (h(r3), !function(e4, r4) {
        return r4 && !f(e4);
      }(r3, _2.current) && n2)) {
        if (f(r3)) {
          _2.current = true;
          var o3 = r3.changedTouches || [];
          o3.length && (b2.current = o3[0].identifier);
        }
        n2.focus(), g2(d(n2, r3, b2.current)), t2(true);
      }
    }, function(e3) {
      var r3 = e3.which || e3.keyCode;
      r3 < 37 || r3 > 40 || (e3.preventDefault(), p2({ left: 39 === r3 ? 0.05 : 37 === r3 ? -0.05 : 0, top: 40 === r3 ? 0.05 : 38 === r3 ? -0.05 : 0 }));
    }, t2];
  }, [p2, g2]), C2 = x2[0], E = x2[1], H = x2[2];
  return (0, import_react33.useEffect)(function() {
    return H;
  }, [H]), import_react33.default.createElement("div", u({}, s2, { onTouchStart: C2, onMouseDown: C2, className: "react-colorful__interactive", ref: m2, onKeyDown: E, tabIndex: 0, role: "slider" }));
});
var g = function(e2) {
  return e2.filter(Boolean).join(" ");
};
var p = function(r2) {
  var t2 = r2.color, n2 = r2.left, o2 = r2.top, a2 = void 0 === o2 ? 0.5 : o2, l2 = g(["react-colorful__pointer", r2.className]);
  return import_react33.default.createElement("div", { className: l2, style: { top: 100 * a2 + "%", left: 100 * n2 + "%" } }, import_react33.default.createElement("div", { className: "react-colorful__pointer-fill", style: { backgroundColor: t2 } }));
};
var b = function(e2, r2, t2) {
  return void 0 === r2 && (r2 = 0), void 0 === t2 && (t2 = Math.pow(10, r2)), Math.round(t2 * e2) / t2;
};
var _ = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
var x = function(e2) {
  return L(C(e2));
};
var C = function(e2) {
  return "#" === e2[0] && (e2 = e2.substring(1)), e2.length < 6 ? { r: parseInt(e2[0] + e2[0], 16), g: parseInt(e2[1] + e2[1], 16), b: parseInt(e2[2] + e2[2], 16), a: 4 === e2.length ? b(parseInt(e2[3] + e2[3], 16) / 255, 2) : 1 } : { r: parseInt(e2.substring(0, 2), 16), g: parseInt(e2.substring(2, 4), 16), b: parseInt(e2.substring(4, 6), 16), a: 8 === e2.length ? b(parseInt(e2.substring(6, 8), 16) / 255, 2) : 1 };
};
var w = function(e2) {
  return K(I(e2));
};
var y = function(e2) {
  var r2 = e2.s, t2 = e2.v, n2 = e2.a, o2 = (200 - r2) * t2 / 100;
  return { h: b(e2.h), s: b(o2 > 0 && o2 < 200 ? r2 * t2 / 100 / (o2 <= 100 ? o2 : 200 - o2) * 100 : 0), l: b(o2 / 2), a: b(n2, 2) };
};
var q = function(e2) {
  var r2 = y(e2);
  return "hsl(" + r2.h + ", " + r2.s + "%, " + r2.l + "%)";
};
var k = function(e2) {
  var r2 = y(e2);
  return "hsla(" + r2.h + ", " + r2.s + "%, " + r2.l + "%, " + r2.a + ")";
};
var I = function(e2) {
  var r2 = e2.h, t2 = e2.s, n2 = e2.v, o2 = e2.a;
  r2 = r2 / 360 * 6, t2 /= 100, n2 /= 100;
  var a2 = Math.floor(r2), l2 = n2 * (1 - t2), u2 = n2 * (1 - (r2 - a2) * t2), c2 = n2 * (1 - (1 - r2 + a2) * t2), i2 = a2 % 6;
  return { r: b(255 * [n2, u2, l2, l2, c2, n2][i2]), g: b(255 * [c2, n2, n2, u2, l2, l2][i2]), b: b(255 * [l2, l2, c2, n2, n2, u2][i2]), a: b(o2, 2) };
};
var D = function(e2) {
  var r2 = e2.toString(16);
  return r2.length < 2 ? "0" + r2 : r2;
};
var K = function(e2) {
  var r2 = e2.r, t2 = e2.g, n2 = e2.b, o2 = e2.a, a2 = o2 < 1 ? D(b(255 * o2)) : "";
  return "#" + D(r2) + D(t2) + D(n2) + a2;
};
var L = function(e2) {
  var r2 = e2.r, t2 = e2.g, n2 = e2.b, o2 = e2.a, a2 = Math.max(r2, t2, n2), l2 = a2 - Math.min(r2, t2, n2), u2 = l2 ? a2 === r2 ? (t2 - n2) / l2 : a2 === t2 ? 2 + (n2 - r2) / l2 : 4 + (r2 - t2) / l2 : 0;
  return { h: b(60 * (u2 < 0 ? u2 + 6 : u2)), s: b(a2 ? l2 / a2 * 100 : 0), v: b(a2 / 255 * 100), a: o2 };
};
var S = import_react33.default.memo(function(r2) {
  var t2 = r2.hue, n2 = r2.onChange, o2 = g(["react-colorful__hue", r2.className]);
  return import_react33.default.createElement("div", { className: o2 }, import_react33.default.createElement(m, { onMove: function(e2) {
    n2({ h: 360 * e2.left });
  }, onKey: function(e2) {
    n2({ h: s(t2 + 360 * e2.left, 0, 360) });
  }, "aria-label": "Hue", "aria-valuenow": b(t2), "aria-valuemax": "360", "aria-valuemin": "0" }, import_react33.default.createElement(p, { className: "react-colorful__hue-pointer", left: t2 / 360, color: q({ h: t2, s: 100, v: 100, a: 1 }) })));
});
var T = import_react33.default.memo(function(r2) {
  var t2 = r2.hsva, n2 = r2.onChange, o2 = { backgroundColor: q({ h: t2.h, s: 100, v: 100, a: 1 }) };
  return import_react33.default.createElement("div", { className: "react-colorful__saturation", style: o2 }, import_react33.default.createElement(m, { onMove: function(e2) {
    n2({ s: 100 * e2.left, v: 100 - 100 * e2.top });
  }, onKey: function(e2) {
    n2({ s: s(t2.s + 100 * e2.left, 0, 100), v: s(t2.v - 100 * e2.top, 0, 100) });
  }, "aria-label": "Color", "aria-valuetext": "Saturation " + b(t2.s) + "%, Brightness " + b(t2.v) + "%" }, import_react33.default.createElement(p, { className: "react-colorful__saturation-pointer", top: 1 - t2.v / 100, left: t2.s / 100, color: q(t2) })));
});
var F = function(e2, r2) {
  if (e2 === r2) return true;
  for (var t2 in e2) if (e2[t2] !== r2[t2]) return false;
  return true;
};
var X = function(e2, r2) {
  return e2.toLowerCase() === r2.toLowerCase() || F(C(e2), C(r2));
};
function Y(e2, t2, l2) {
  var u2 = i(l2), c2 = (0, import_react33.useState)(function() {
    return e2.toHsva(t2);
  }), s2 = c2[0], f2 = c2[1], v2 = (0, import_react33.useRef)({ color: t2, hsva: s2 });
  (0, import_react33.useEffect)(function() {
    if (!e2.equal(t2, v2.current.color)) {
      var r2 = e2.toHsva(t2);
      v2.current = { hsva: r2, color: t2 }, f2(r2);
    }
  }, [t2, e2]), (0, import_react33.useEffect)(function() {
    var r2;
    F(s2, v2.current.hsva) || e2.equal(r2 = e2.fromHsva(s2), v2.current.color) || (v2.current = { hsva: s2, color: r2 }, u2(r2));
  }, [s2, e2, u2]);
  var d2 = (0, import_react33.useCallback)(function(e3) {
    f2(function(r2) {
      return Object.assign({}, r2, e3);
    });
  }, []);
  return [s2, d2];
}
var R;
var V = "undefined" != typeof window ? import_react33.useLayoutEffect : import_react33.useEffect;
var $ = function() {
  return R || ("undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : void 0);
};
var J = /* @__PURE__ */ new Map();
var Q = function(e2) {
  V(function() {
    var r2 = e2.current ? e2.current.ownerDocument : document;
    if (void 0 !== r2 && !J.has(r2)) {
      var t2 = r2.createElement("style");
      t2.innerHTML = `.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}`, J.set(r2, t2);
      var n2 = $();
      n2 && t2.setAttribute("nonce", n2), r2.head.appendChild(t2);
    }
  }, []);
};
var U = function(t2) {
  var n2 = t2.className, o2 = t2.colorModel, a2 = t2.color, l2 = void 0 === a2 ? o2.defaultColor : a2, i2 = t2.onChange, s2 = c(t2, ["className", "colorModel", "color", "onChange"]), f2 = (0, import_react33.useRef)(null);
  Q(f2);
  var v2 = Y(o2, l2, i2), d2 = v2[0], h2 = v2[1], m2 = g(["react-colorful", n2]);
  return import_react33.default.createElement("div", u({}, s2, { ref: f2, className: m2 }), import_react33.default.createElement(T, { hsva: d2, onChange: h2 }), import_react33.default.createElement(S, { hue: d2.h, onChange: h2, className: "react-colorful__last-control" }));
};
var W = { defaultColor: "000", toHsva: x, fromHsva: function(e2) {
  return w({ h: e2.h, s: e2.s, v: e2.v, a: 1 });
}, equal: X };
var Z = function(r2) {
  return import_react33.default.createElement(U, u({}, r2, { colorModel: W }));
};
var ee = function(r2) {
  var t2 = r2.className, n2 = r2.hsva, o2 = r2.onChange, a2 = { backgroundImage: "linear-gradient(90deg, " + k(Object.assign({}, n2, { a: 0 })) + ", " + k(Object.assign({}, n2, { a: 1 })) + ")" }, l2 = g(["react-colorful__alpha", t2]), u2 = b(100 * n2.a);
  return import_react33.default.createElement("div", { className: l2 }, import_react33.default.createElement("div", { className: "react-colorful__alpha-gradient", style: a2 }), import_react33.default.createElement(m, { onMove: function(e2) {
    o2({ a: e2.left });
  }, onKey: function(e2) {
    o2({ a: s(n2.a + e2.left) });
  }, "aria-label": "Alpha", "aria-valuetext": u2 + "%", "aria-valuenow": u2, "aria-valuemin": "0", "aria-valuemax": "100" }, import_react33.default.createElement(p, { className: "react-colorful__alpha-pointer", left: n2.a, color: k(n2) })));
};
var re = function(t2) {
  var n2 = t2.className, o2 = t2.colorModel, a2 = t2.color, l2 = void 0 === a2 ? o2.defaultColor : a2, i2 = t2.onChange, s2 = c(t2, ["className", "colorModel", "color", "onChange"]), f2 = (0, import_react33.useRef)(null);
  Q(f2);
  var v2 = Y(o2, l2, i2), d2 = v2[0], h2 = v2[1], m2 = g(["react-colorful", n2]);
  return import_react33.default.createElement("div", u({}, s2, { ref: f2, className: m2 }), import_react33.default.createElement(T, { hsva: d2, onChange: h2 }), import_react33.default.createElement(S, { hue: d2.h, onChange: h2 }), import_react33.default.createElement(ee, { hsva: d2, onChange: h2, className: "react-colorful__last-control" }));
};
var te = { defaultColor: "0001", toHsva: x, fromHsva: w, equal: X };
var ne = function(r2) {
  return import_react33.default.createElement(re, u({}, r2, { colorModel: te }));
};

// node_modules/mui-tiptap/dist/esm/utils/color.js
function colorToHex(color) {
  try {
    return rgbToHex(color);
  } catch (_a) {
    return null;
  }
}

// node_modules/mui-tiptap/dist/esm/controls/ColorSwatchButton.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/Check.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime());
var Check_default = createSvgIcon((0, import_jsx_runtime45.jsx)("path", {
  d: "M9 16.17 4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"
}), "Check");

// node_modules/mui-tiptap/dist/esm/controls/ColorSwatchButton.js
var import_react34 = __toESM(require_react());
var ColorSwatchButton = (0, import_react34.forwardRef)(({ value: colorValue, label, padding, active, ...buttonProps }, ref) => {
  const { classes, cx, theme } = useStyles15();
  return (0, import_jsx_runtime46.jsx)("button", { ref, type: "button", style: { backgroundColor: colorValue, padding }, "aria-label": label !== null && label !== void 0 ? label : colorValue, value: colorValue, ...buttonProps, className: cx(classes.root, !colorValue && classes.colorNotSet, buttonProps.className), children: active && (0, import_jsx_runtime46.jsx)(Check_default, { fontSize: "small", className: classes.activeIcon, style: {
    color: colorValue ? theme.palette.getContrastText(colorValue) : void 0
  } }) });
});
var useStyles15 = makeStyles({ name: { ColorSwatchButton } })((theme) => ({
  root: {
    height: theme.spacing(2.5),
    width: theme.spacing(2.5),
    minWidth: theme.spacing(2.5),
    borderRadius: theme.shape.borderRadius,
    borderColor: theme.palette.mode === "dark" ? theme.palette.grey[700] : theme.palette.grey[400],
    borderStyle: "solid",
    borderWidth: 1,
    cursor: "pointer",
    // Use background-clip with content-box so that if a `padding` is specified by the
    // user, it adds a gap between the color and the border.
    padding: 0,
    backgroundClip: "content-box"
  },
  activeIcon: {
    height: "100%",
    width: "80%",
    verticalAlign: "middle"
  },
  colorNotSet: {
    // To indicate that a color hasn't been chosen, we'll use a checkerboard pattern
    // (https://stackoverflow.com/a/65129916/4543977)
    background: `repeating-conic-gradient(
      ${theme.palette.grey[400]} 0% 25%, ${theme.palette.common.white} 0% 50%)
      50% / 12px 12px`,
    backgroundClip: "content-box"
  }
}));
ColorSwatchButton.displayName = "ColorSwatchButton";

// node_modules/mui-tiptap/dist/esm/controls/ColorPicker.js
var colorPickerUtilityClasses = getUtilityClasses("ColorPicker", ["gradientPicker", "colorTextInput", "swatchContainer"]);
var useStyles16 = makeStyles({ name: { ColorPicker } })((theme) => ({
  gradientPicker: {
    // Increase specificity to override the styles
    "&&": {
      width: "100%"
    }
  },
  colorTextInput: {
    marginTop: theme.spacing(1)
  },
  swatchContainer: {
    display: "flex",
    flexWrap: "wrap",
    gap: 5,
    marginTop: theme.spacing(1)
  }
}));
function ColorPicker({ value, onChange, swatchColors, colorToHex: colorToHex2 = colorToHex, disableAlpha = false, labels = {}, classes: overrideClasses = {} }) {
  const { classes, cx } = useStyles16(void 0, {
    props: { classes: overrideClasses }
  });
  const { textFieldPlaceholder = 'Ex: "#7cb5ec"' } = labels;
  const inputRef = (0, import_react35.useRef)(null);
  (0, import_react35.useEffect)(() => {
    if (inputRef.current && inputRef.current !== document.activeElement) {
      inputRef.current.value = value;
    }
  }, [value]);
  const swatchColorObjects = (swatchColors !== null && swatchColors !== void 0 ? swatchColors : []).map((swatchColor) => typeof swatchColor === "string" ? { value: swatchColor } : swatchColor);
  const colorValueAsHex = colorToHex2(value);
  return (0, import_jsx_runtime47.jsxs)(import_jsx_runtime47.Fragment, { children: [disableAlpha ? (0, import_jsx_runtime47.jsx)(Z, { color: colorValueAsHex !== null && colorValueAsHex !== void 0 ? colorValueAsHex : "#000000", className: cx(colorPickerUtilityClasses.gradientPicker, classes.gradientPicker), onChange: (color) => {
    onChange(color, "gradient");
  } }) : (0, import_jsx_runtime47.jsx)(ne, { color: colorValueAsHex !== null && colorValueAsHex !== void 0 ? colorValueAsHex : "#000000", className: cx(colorPickerUtilityClasses.gradientPicker, classes.gradientPicker), onChange: (color) => {
    onChange(color, "gradient");
  } }), (0, import_jsx_runtime47.jsx)(TextField_default, { placeholder: textFieldPlaceholder, variant: "outlined", size: "small", defaultValue: value || "", inputRef, spellCheck: false, className: cx(colorPickerUtilityClasses.colorTextInput, classes.colorTextInput), onChange: (event) => {
    const newColor = event.target.value;
    const newHexColor = colorToHex2(newColor);
    if (newHexColor) {
      onChange(newHexColor, "text");
    }
  }, fullWidth: true }), swatchColorObjects.length > 0 && (0, import_jsx_runtime47.jsx)("div", { className: cx(colorPickerUtilityClasses.swatchContainer, classes.swatchContainer), children: swatchColorObjects.map((swatchColor) => (0, import_jsx_runtime47.jsx)(ColorSwatchButton, {
    value: swatchColor.value,
    label: swatchColor.label,
    onClick: () => {
      var _a;
      onChange((_a = swatchColor.value) !== null && _a !== void 0 ? _a : "", "swatch");
    },
    // We'll show the swatch as active if this swatch color is naively
    // equal to the current color, if this swatch is for "transparent"
    // and no color is set, or if the color matches when parsing and
    // converting both colors to hex.
    active: swatchColor.value == value || !swatchColor.value && !value || !!swatchColor.value && !!colorValueAsHex && colorToHex2(swatchColor.value) === colorValueAsHex
  }, swatchColor.value)) })] });
}

// node_modules/mui-tiptap/dist/esm/controls/ColorPickerPopper.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime());
var import_react36 = __toESM(require_react());
function ColorPickerPopperBody({ value, onCancel, onSave, swatchColors, labels = {}, ColorPickerProps }) {
  const { removeColorButton = "None", removeColorButtonTooltipTitle = "", cancelButton = "Cancel", saveButton = "OK" } = labels;
  const [localColor, setLocalColor] = (0, import_react36.useState)(value);
  (0, import_react36.useEffect)(() => {
    setLocalColor(value);
  }, [value]);
  return (0, import_jsx_runtime48.jsxs)(import_jsx_runtime48.Fragment, { children: [(0, import_jsx_runtime48.jsx)(ColorPicker, { swatchColors, value: localColor, onChange: (newColor) => {
    setLocalColor(newColor);
  }, labels, ...ColorPickerProps }), (0, import_jsx_runtime48.jsxs)(Stack_default, { direction: "row", justifyContent: "space-between", sx: { mt: 1 }, children: [(0, import_jsx_runtime48.jsx)(Tooltip_default, { title: removeColorButtonTooltipTitle, arrow: true, children: (0, import_jsx_runtime48.jsx)(Button_default, { onClick: () => {
    onSave("");
  }, size: "small", children: removeColorButton }) }), (0, import_jsx_runtime48.jsx)(Button_default, { onClick: onCancel, size: "small", children: cancelButton }), (0, import_jsx_runtime48.jsx)(Button_default, { onClick: () => {
    onSave(localColor);
  }, size: "small", children: saveButton })] })] });
}
var useStyles17 = makeStyles({ name: { ColorPickerPopper } })((theme) => ({
  root: {
    // Ensure the popper is above modals, in case the editor is rendered in a
    // modal, consistent with recommendations here
    // https://github.com/mui/material-ui/issues/14216. See
    // https://github.com/sjdemartini/mui-tiptap/issues/206.
    zIndex: theme.zIndex.tooltip,
    // This width seems to work well to allow exactly 8 swatches, as well as the
    // default button content
    width: 235
  }
}));
function ColorPickerPopper({ value, onSave, onCancel, swatchColors, ColorPickerProps, labels, ...popperProps }) {
  const { classes, cx } = useStyles17();
  return (0, import_jsx_runtime48.jsx)(Popper_default, { transition: true, placement: "bottom-start", ...popperProps, className: cx(classes.root, popperProps.className), children: ({ TransitionProps }) => (0, import_jsx_runtime48.jsx)(Fade_default, { ...TransitionProps, timeout: 100, children: (0, import_jsx_runtime48.jsx)("div", { children: (0, import_jsx_runtime48.jsx)(
    ClickAwayListener,
    {
      // Listen for "leading" events (the start of a click or touch)
      // rather than the trailing events (the end of a click) which is
      // the default, since it's easy to accidentally drag the
      // color-picker saturation/hue gradients beyond the edge of the
      // Popper, and we don't want to close in that situation.
      mouseEvent: "onMouseDown",
      touchEvent: "onTouchStart",
      onClickAway: onCancel,
      children: (0, import_jsx_runtime48.jsx)(Paper_default, { elevation: 5, sx: { p: 2.5, pb: 1 }, children: (0, import_jsx_runtime48.jsx)(ColorPickerPopperBody, { value: value || "", onSave, onCancel, swatchColors, ColorPickerProps, labels }) })
    }
  ) }) }) });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonAddImage.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/AddPhotoAlternate.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime());
var AddPhotoAlternate_default = createSvgIcon((0, import_jsx_runtime49.jsx)("path", {
  d: "M19 7v2.99s-1.99.01-2 0V7h-3s.01-1.99 0-2h3V2h2v3h3v2zm-3 4V8h-3V5H5c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-8zM5 19l3-4 2 3 3-4 4 5z"
}), "AddPhotoAlternate");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonAddImage.js
function MenuButtonAddImage({ ...props }) {
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime50.jsx)(MenuButton, { tooltipLabel: "Insert image", IconComponent: AddPhotoAlternate_default, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || // We can use any URL here for testing `can` (to see if an image can be
  // added to the editor currently)
  !editor.can().setImage({ src: "http://example.com" }), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonAddTable.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime());
function MenuButtonAddTable(props) {
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime51.jsx)(MenuButton, { tooltipLabel: "Insert table", IconComponent: Table_default, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().insertTable(), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: true }).run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonAlignCenter.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/FormatAlignCenter.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime());
var FormatAlignCenter_default = createSvgIcon((0, import_jsx_runtime52.jsx)("path", {
  d: "M7 15v2h10v-2zm-4 6h18v-2H3zm0-8h18v-2H3zm4-6v2h10V7zM3 3v2h18V3z"
}), "FormatAlignCenter");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonAlignCenter.js
function MenuButtonAlignCenter(props) {
  var _a;
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime53.jsx)(MenuButton, { tooltipLabel: "Center align", tooltipShortcutKeys: ["mod", "Shift", "E"], IconComponent: FormatAlignCenter_default, selected: (_a = editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: "center" })) !== null && _a !== void 0 ? _a : false, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().setTextAlign("center"), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().setTextAlign("center").run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonAlignJustify.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/FormatAlignJustify.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime());
var FormatAlignJustify_default = createSvgIcon((0, import_jsx_runtime54.jsx)("path", {
  d: "M3 21h18v-2H3zm0-4h18v-2H3zm0-4h18v-2H3zm0-4h18V7H3zm0-6v2h18V3z"
}), "FormatAlignJustify");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonAlignJustify.js
function MenuButtonAlignJustify(props) {
  var _a;
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime55.jsx)(MenuButton, { tooltipLabel: "Justify", tooltipShortcutKeys: ["mod", "Shift", "J"], IconComponent: FormatAlignJustify_default, selected: (_a = editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: "justify" })) !== null && _a !== void 0 ? _a : false, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().setTextAlign("justify"), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().setTextAlign("justify").run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonAlignLeft.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/FormatAlignLeft.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime());
var FormatAlignLeft_default = createSvgIcon((0, import_jsx_runtime56.jsx)("path", {
  d: "M15 15H3v2h12zm0-8H3v2h12zM3 13h18v-2H3zm0 8h18v-2H3zM3 3v2h18V3z"
}), "FormatAlignLeft");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonAlignLeft.js
function MenuButtonAlignLeft(props) {
  var _a;
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime57.jsx)(MenuButton, { tooltipLabel: "Left align", tooltipShortcutKeys: ["mod", "Shift", "L"], IconComponent: FormatAlignLeft_default, selected: (_a = editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: "left" })) !== null && _a !== void 0 ? _a : false, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().setTextAlign("left"), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().setTextAlign("left").run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonAlignRight.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/FormatAlignRight.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime());
var FormatAlignRight_default = createSvgIcon((0, import_jsx_runtime58.jsx)("path", {
  d: "M3 21h18v-2H3zm6-4h12v-2H9zm-6-4h18v-2H3zm6-4h12V7H9zM3 3v2h18V3z"
}), "FormatAlignRight");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonAlignRight.js
function MenuButtonAlignRight(props) {
  var _a;
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime59.jsx)(MenuButton, { tooltipLabel: "Right align", tooltipShortcutKeys: ["mod", "Shift", "R"], IconComponent: FormatAlignRight_default, selected: (_a = editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: "right" })) !== null && _a !== void 0 ? _a : false, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().setTextAlign("right"), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().setTextAlign("right").run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonBlockquote.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/FormatQuote.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime());
var FormatQuote_default = createSvgIcon((0, import_jsx_runtime60.jsx)("path", {
  d: "M6 17h3l2-4V7H5v6h3zm8 0h3l2-4V7h-6v6h3z"
}), "FormatQuote");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonBlockquote.js
function MenuButtonBlockquote(props) {
  var _a;
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime61.jsx)(MenuButton, { tooltipLabel: "Blockquote", tooltipShortcutKeys: ["mod", "Shift", "B"], IconComponent: FormatQuote_default, selected: (_a = editor === null || editor === void 0 ? void 0 : editor.isActive("blockquote")) !== null && _a !== void 0 ? _a : false, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().toggleBlockquote(), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleBlockquote().run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonBold.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/FormatBold.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime());
var FormatBold_default = createSvgIcon((0, import_jsx_runtime62.jsx)("path", {
  d: "M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42M10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5"
}), "FormatBold");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonBold.js
function MenuButtonBold(props) {
  var _a;
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime63.jsx)(MenuButton, { tooltipLabel: "Bold", tooltipShortcutKeys: ["mod", "B"], IconComponent: FormatBold_default, selected: (_a = editor === null || editor === void 0 ? void 0 : editor.isActive("bold")) !== null && _a !== void 0 ? _a : false, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().toggleBold(), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleBold().run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonBulletedList.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/FormatListBulleted.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime());
var FormatListBulleted_default = createSvgIcon((0, import_jsx_runtime64.jsx)("path", {
  d: "M4 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5m0-6c-.83 0-1.5.67-1.5 1.5S3.17 7.5 4 7.5 5.5 6.83 5.5 6 4.83 4.5 4 4.5m0 12c-.83 0-1.5.68-1.5 1.5s.68 1.5 1.5 1.5 1.5-.68 1.5-1.5-.67-1.5-1.5-1.5M7 19h14v-2H7zm0-6h14v-2H7zm0-8v2h14V5z"
}), "FormatListBulleted");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonBulletedList.js
function MenuButtonBulletedList(props) {
  var _a;
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime65.jsx)(MenuButton, { tooltipLabel: "Bulleted list", tooltipShortcutKeys: ["mod", "Shift", "8"], IconComponent: FormatListBulleted_default, selected: (_a = editor === null || editor === void 0 ? void 0 : editor.isActive("bulletList")) !== null && _a !== void 0 ? _a : false, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().toggleBulletList(), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleBulletList().run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonCode.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/Code.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime());
var Code_default = createSvgIcon((0, import_jsx_runtime66.jsx)("path", {
  d: "M9.4 16.6 4.8 12l4.6-4.6L8 6l-6 6 6 6zm5.2 0 4.6-4.6-4.6-4.6L16 6l6 6-6 6z"
}), "Code");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonCode.js
function MenuButtonCode(props) {
  var _a;
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime67.jsx)(MenuButton, { tooltipLabel: "Code", tooltipShortcutKeys: ["mod", "E"], IconComponent: Code_default, selected: (_a = editor === null || editor === void 0 ? void 0 : editor.isActive("code")) !== null && _a !== void 0 ? _a : false, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().toggleCode(), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleCode().run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonCodeBlock.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime());
function MenuButtonCodeBlock(props) {
  var _a;
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime68.jsx)(MenuButton, { tooltipLabel: "Code block", tooltipShortcutKeys: ["mod", "Alt", "C"], IconComponent: CodeBlock_default, selected: (_a = editor === null || editor === void 0 ? void 0 : editor.isActive("codeBlock")) !== null && _a !== void 0 ? _a : false, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().toggleCodeBlock(), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleCodeBlock().run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonColorPicker.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime());
var import_react37 = __toESM(require_react());
var useStyles18 = makeStyles({ name: { MenuButtonColorPicker } })((theme) => ({
  menuButtonIcon: {
    fontSize: MENU_BUTTON_FONT_SIZE_DEFAULT
  },
  colorIndicatorIcon: {
    position: "absolute"
  },
  colorIndicatorIconDisabled: {
    color: theme.palette.action.disabled
  }
}));
function MenuButtonColorPicker({ value: colorValue, onChange, swatchColors, labels, hideColorIndicator = false, popperId, PopperProps, ColorPickerProps, ...menuButtonProps }) {
  const { classes, cx } = useStyles18();
  const [anchorEl, setAnchorEl] = (0, import_react37.useState)(null);
  const handleClose = () => {
    setAnchorEl(null);
  };
  const { IconComponent, children, ...otherMenuButtonProps } = menuButtonProps;
  return (0, import_jsx_runtime69.jsxs)(import_jsx_runtime69.Fragment, { children: [(0, import_jsx_runtime69.jsx)(MenuButton, { onClick: (e2) => {
    if (anchorEl) {
      handleClose();
    } else {
      setAnchorEl(e2.currentTarget);
    }
  }, "aria-describedby": popperId, ...otherMenuButtonProps, children: children !== null && children !== void 0 ? children : (0, import_jsx_runtime69.jsxs)(import_jsx_runtime69.Fragment, { children: [IconComponent && (0, import_jsx_runtime69.jsx)(IconComponent, { className: classes.menuButtonIcon }), !hideColorIndicator && colorValue && (0, import_jsx_runtime69.jsx)(FormatColorBar_default, { className: cx(classes.menuButtonIcon, classes.colorIndicatorIcon, menuButtonProps.disabled && classes.colorIndicatorIconDisabled), style: menuButtonProps.disabled ? void 0 : { color: colorValue } })] }) }), (0, import_jsx_runtime69.jsx)(ColorPickerPopper, { id: popperId, open: !!anchorEl, anchorEl, value: colorValue !== null && colorValue !== void 0 ? colorValue : "", onSave: (newColor) => {
    onChange(newColor);
    handleClose();
  }, onCancel: handleClose, swatchColors, ColorPickerProps, labels, ...PopperProps })] });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonEditLink.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/Link.js
var import_jsx_runtime70 = __toESM(require_jsx_runtime());
var Link_default2 = createSvgIcon((0, import_jsx_runtime70.jsx)("path", {
  d: "M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1M8 13h8v-2H8zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5"
}), "Link");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonEditLink.js
var import_react38 = __toESM(require_react());
function MenuButtonEditLink(props) {
  const editor = useRichTextEditorContext();
  const buttonRef = (0, import_react38.useRef)(null);
  return (0, import_jsx_runtime71.jsx)(MenuButton, { buttonRef, tooltipLabel: "Link", tooltipShortcutKeys: ["mod", "Shift", "U"], IconComponent: Link_default2, selected: editor === null || editor === void 0 ? void 0 : editor.isActive("link"), disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable), onClick: () => (
    // When clicking the button to open the bubble menu, we'll place the
    // menu below the button
    editor === null || editor === void 0 ? void 0 : editor.commands.openLinkBubbleMenu({
      anchorEl: buttonRef.current,
      placement: "bottom"
    })
  ), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonHighlightColor.js
var import_jsx_runtime72 = __toESM(require_jsx_runtime());
function MenuButtonHighlightColor({ defaultMarkColor = "#ffff00", ...menuButtonProps }) {
  const editor = useRichTextEditorContext();
  const currentHighlightColor = (editor === null || editor === void 0 ? void 0 : editor.isActive("highlight")) ? (
    // If there's no color set for the highlight (as can happen with the
    // highlight keyboard shortcut, toggleHighlight/setHighlight when no
    // explicit color is provided, and the "==thing==" syntax), fall back to
    // the provided defaultMarkColor
    editor.getAttributes("highlight").color || defaultMarkColor
  ) : "";
  return (0, import_jsx_runtime72.jsx)(MenuButtonColorPicker, { IconComponent: FormatInkHighlighterNoBar_default, tooltipLabel: "Highlight color", tooltipShortcutKeys: ["mod", "Shift", "H"], value: currentHighlightColor, onChange: (newColor) => {
    if (newColor) {
      editor === null || editor === void 0 ? void 0 : editor.chain().focus().setHighlight({ color: newColor }).run();
    } else {
      editor === null || editor === void 0 ? void 0 : editor.chain().focus().unsetHighlight().run();
    }
  }, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().toggleHighlight(), ...menuButtonProps, labels: {
    removeColorButton: "None",
    removeColorButtonTooltipTitle: "Remove highlighting from this text",
    ...menuButtonProps.labels
  } });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonHighlightToggle.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime());
function MenuButtonHighlightToggle({ ...menuButtonProps }) {
  var _a;
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime73.jsx)(MenuButton, { IconComponent: FormatInkHighlighter_default, tooltipLabel: "Highlight", tooltipShortcutKeys: ["mod", "Shift", "H"], selected: (_a = editor === null || editor === void 0 ? void 0 : editor.isActive("highlight")) !== null && _a !== void 0 ? _a : false, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().toggleHighlight(), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleHighlight().run(), ...menuButtonProps });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonHorizontalRule.js
var import_jsx_runtime75 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/HorizontalRule.js
var import_jsx_runtime74 = __toESM(require_jsx_runtime());
var HorizontalRule_default = createSvgIcon((0, import_jsx_runtime74.jsx)("path", {
  fillRule: "evenodd",
  d: "M4 11h16v2H4z"
}), "HorizontalRule");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonHorizontalRule.js
function MenuButtonHorizontalRule(props) {
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime75.jsx)(MenuButton, { tooltipLabel: "Insert horizontal line", IconComponent: HorizontalRule_default, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().setHorizontalRule(), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().setHorizontalRule().run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonImageUpload.js
var import_jsx_runtime76 = __toESM(require_jsx_runtime());
var import_react39 = __toESM(require_react());

// node_modules/mui-tiptap/dist/esm/utils/getAttributesForMarks.js
function getAttributesForMarks(state, typeOrName) {
  const type = getMarkType(typeOrName, state.schema);
  const { from, to, empty } = state.selection;
  const marks = [];
  if (empty) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from, to, (node) => {
      marks.push(...node.marks);
    });
  }
  return marks.filter((markItem) => markItem.type.name === type.name).map((mark) => ({ ...mark.attrs }));
}

// node_modules/mui-tiptap/dist/esm/utils/getAttributesForNodes.js
function getAttributesForNodes(state, typeOrName) {
  const type = getNodeType(typeOrName, state.schema);
  const { from, to } = state.selection;
  const nodes = [];
  state.doc.nodesBetween(from, to, (node) => {
    nodes.push(node);
  });
  return nodes.reverse().filter((nodeItem) => nodeItem.type.name === type.name).map((node) => ({ ...node.attrs }));
}

// node_modules/mui-tiptap/dist/esm/utils/getAttributesForEachSelected.js
function getAttributesForEachSelected(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (schemaType === "node") {
    return getAttributesForNodes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getAttributesForMarks(state, typeOrName);
  }
  return [];
}

// node_modules/mui-tiptap/dist/esm/utils/images.js
function insertImages({ images, editor, position }) {
  if (!editor || editor.isDestroyed || images.length === 0) {
    return;
  }
  const imageContentToInsert = images.filter((imageAttrs) => !!imageAttrs.src).map((imageAttrs) => ({
    type: editor.schema.nodes.image.name,
    attrs: imageAttrs
  }));
  editor.chain().command(({ commands }) => {
    if (position == null) {
      return commands.insertContent(imageContentToInsert);
    } else {
      return commands.insertContentAt(position, imageContentToInsert);
    }
  }).focus().run();
}

// node_modules/mui-tiptap/dist/esm/utils/keymapPluginFactory.js
function keymapPluginFactory(bindings, key) {
  return new Plugin({
    key,
    props: {
      handleKeyDown: keydownHandler(bindings)
    }
  });
}

// node_modules/mui-tiptap/dist/esm/utils/slugify.js
function slugify(text) {
  return text.toLowerCase().normalize("NFKD").replace(/[^\w\s-]+/g, "").replace(/[-\s]+/g, "-").replace(/^[\s-_]+|[\s-_]+$/g, "");
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonImageUpload.js
function MenuButtonImageUpload({ onUploadFiles, inputProps, insertImages: insertImages2 = insertImages, ...props }) {
  const editor = useRichTextEditorContext();
  const fileInput = (0, import_react39.useRef)(null);
  const handleAndInsertNewFiles = async (files) => {
    if (!editor || editor.isDestroyed || files.length === 0) {
      return;
    }
    const attributesForImages = await onUploadFiles(Array.from(files));
    insertImages2({
      editor,
      images: attributesForImages
    });
  };
  return (0, import_jsx_runtime76.jsxs)(import_jsx_runtime76.Fragment, { children: [(0, import_jsx_runtime76.jsx)(MenuButtonAddImage, { tooltipLabel: "Upload images", onClick: () => {
    var _a;
    return (_a = fileInput.current) === null || _a === void 0 ? void 0 : _a.click();
  }, ...props }), (0, import_jsx_runtime76.jsx)("input", { ref: fileInput, type: "file", accept: "image/*", multiple: true, onChange: async (event) => {
    if (event.target.files) {
      await handleAndInsertNewFiles(event.target.files);
    }
    event.target.value = "";
  }, style: { display: "none" }, ...inputProps })] });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonIndent.js
var import_jsx_runtime78 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/FormatIndentIncrease.js
var import_jsx_runtime77 = __toESM(require_jsx_runtime());
var FormatIndentIncrease_default = createSvgIcon((0, import_jsx_runtime77.jsx)("path", {
  d: "M3 21h18v-2H3zM3 8v8l4-4zm8 9h10v-2H11zM3 3v2h18V3zm8 6h10V7H11zm0 4h10v-2H11z"
}), "FormatIndentIncrease");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonIndent.js
function MenuButtonIndent(props) {
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime78.jsx)(MenuButton, { tooltipLabel: "Indent", tooltipShortcutKeys: ["Tab"], IconComponent: FormatIndentIncrease_default, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().sinkListItem("listItem"), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().sinkListItem("listItem").run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonItalic.js
var import_jsx_runtime80 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/FormatItalic.js
var import_jsx_runtime79 = __toESM(require_jsx_runtime());
var FormatItalic_default = createSvgIcon((0, import_jsx_runtime79.jsx)("path", {
  d: "M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z"
}), "FormatItalic");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonItalic.js
function MenuButtonItalic(props) {
  var _a;
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime80.jsx)(MenuButton, { tooltipLabel: "Italic", tooltipShortcutKeys: ["mod", "I"], IconComponent: FormatItalic_default, selected: (_a = editor === null || editor === void 0 ? void 0 : editor.isActive("italic")) !== null && _a !== void 0 ? _a : false, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().toggleItalic(), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleItalic().run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonOrderedList.js
var import_jsx_runtime82 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/FormatListNumbered.js
var import_jsx_runtime81 = __toESM(require_jsx_runtime());
var FormatListNumbered_default = createSvgIcon((0, import_jsx_runtime81.jsx)("path", {
  d: "M2 17h2v.5H3v1h1v.5H2v1h3v-4H2zm1-9h1V4H2v1h1zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2zm5-6v2h14V5zm0 14h14v-2H7zm0-6h14v-2H7z"
}), "FormatListNumbered");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonOrderedList.js
function MenuButtonOrderedList(props) {
  var _a;
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime82.jsx)(MenuButton, { tooltipLabel: "Ordered list", tooltipShortcutKeys: ["mod", "Shift", "7"], IconComponent: FormatListNumbered_default, selected: (_a = editor === null || editor === void 0 ? void 0 : editor.isActive("orderedList")) !== null && _a !== void 0 ? _a : false, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().toggleOrderedList(), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleOrderedList().run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonRedo.js
var import_jsx_runtime84 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/Redo.js
var import_jsx_runtime83 = __toESM(require_jsx_runtime());
var Redo_default = createSvgIcon((0, import_jsx_runtime83.jsx)("path", {
  d: "M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7z"
}), "Redo");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonRedo.js
function MenuButtonRedo(props) {
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime84.jsx)(MenuButton, { tooltipLabel: "Redo", tooltipShortcutKeys: ["mod", "Shift", "Z"], IconComponent: Redo_default, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().redo(), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().redo().run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonRemoveFormatting.js
var import_jsx_runtime86 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/FormatClear.js
var import_jsx_runtime85 = __toESM(require_jsx_runtime());
var FormatClear_default = createSvgIcon((0, import_jsx_runtime85.jsx)("path", {
  d: "M3.27 5 2 6.27l6.97 6.97L6.5 19h3l1.57-3.66L16.73 21 18 19.73 3.55 5.27zM6 5v.18L8.82 8h2.4l-.72 1.68 2.1 2.1L14.21 8H20V5z"
}), "FormatClear");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonRemoveFormatting.js
function MenuButtonRemoveFormatting(props) {
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime86.jsx)(MenuButton, { tooltipLabel: "Remove inline formatting", IconComponent: FormatClear_default, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().unsetAllMarks(), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().unsetAllMarks().run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonStrikethrough.js
var import_jsx_runtime88 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/StrikethroughS.js
var import_jsx_runtime87 = __toESM(require_jsx_runtime());
var StrikethroughS_default = createSvgIcon((0, import_jsx_runtime87.jsx)("path", {
  d: "M6.85 7.08C6.85 4.37 9.45 3 12.24 3c1.64 0 3 .49 3.9 1.28.77.65 1.46 1.73 1.46 3.24h-3.01c0-.31-.05-.59-.15-.85-.29-.86-1.2-1.28-2.25-1.28-1.86 0-2.34 1.02-2.34 1.7 0 .48.25.88.74 1.21.38.25.77.48 1.41.7H7.39c-.21-.34-.54-.89-.54-1.92M21 12v-2H3v2h9.62c1.15.45 1.96.75 1.96 1.97 0 1-.81 1.67-2.28 1.67-1.54 0-2.93-.54-2.93-2.51H6.4c0 .55.08 1.13.24 1.58.81 2.29 3.29 3.3 5.67 3.3 2.27 0 5.3-.89 5.3-4.05 0-.3-.01-1.16-.48-1.94H21z"
}), "StrikethroughS");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonStrikethrough.js
function MenuButtonStrikethrough(props) {
  var _a;
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime88.jsx)(MenuButton, { tooltipLabel: "Strikethrough", tooltipShortcutKeys: ["mod", "Shift", "S"], IconComponent: StrikethroughS_default, selected: (_a = editor === null || editor === void 0 ? void 0 : editor.isActive("strike")) !== null && _a !== void 0 ? _a : false, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().toggleStrike(), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleStrike().run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonSubscript.js
var import_jsx_runtime90 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/Subscript.js
var import_jsx_runtime89 = __toESM(require_jsx_runtime());
var Subscript_default = createSvgIcon((0, import_jsx_runtime89.jsx)("path", {
  d: "M22 18h-2v1h3v1h-4v-2c0-.55.45-1 1-1h2v-1h-3v-1h3c.55 0 1 .45 1 1v1c0 .55-.45 1-1 1M5.88 18h2.66l3.4-5.42h.12l3.4 5.42h2.66l-4.65-7.27L17.81 4h-2.68l-3.07 4.99h-.12L8.85 4H6.19l4.32 6.73z"
}), "Subscript");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonSubscript.js
function MenuButtonSubscript(props) {
  var _a;
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime90.jsx)(MenuButton, { tooltipLabel: "Subscript", tooltipShortcutKeys: ["mod", ","], IconComponent: Subscript_default, selected: (_a = editor === null || editor === void 0 ? void 0 : editor.isActive("subscript")) !== null && _a !== void 0 ? _a : false, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().toggleSubscript(), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleSubscript().run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonSuperscript.js
var import_jsx_runtime92 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/Superscript.js
var import_jsx_runtime91 = __toESM(require_jsx_runtime());
var Superscript_default = createSvgIcon((0, import_jsx_runtime91.jsx)("path", {
  d: "M22 7h-2v1h3v1h-4V7c0-.55.45-1 1-1h2V5h-3V4h3c.55 0 1 .45 1 1v1c0 .55-.45 1-1 1M5.88 20h2.66l3.4-5.42h.12l3.4 5.42h2.66l-4.65-7.27L17.81 6h-2.68l-3.07 4.99h-.12L8.85 6H6.19l4.32 6.73z"
}), "Superscript");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonSuperscript.js
function MenuButtonSuperscript(props) {
  var _a;
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime92.jsx)(MenuButton, { tooltipLabel: "Superscript", tooltipShortcutKeys: ["mod", "."], IconComponent: Superscript_default, selected: (_a = editor === null || editor === void 0 ? void 0 : editor.isActive("superscript")) !== null && _a !== void 0 ? _a : false, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().toggleSuperscript(), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleSuperscript().run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonTaskList.js
var import_jsx_runtime94 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/Checklist.js
var import_jsx_runtime93 = __toESM(require_jsx_runtime());
var Checklist_default = createSvgIcon((0, import_jsx_runtime93.jsx)("path", {
  d: "M22 7h-9v2h9zm0 8h-9v2h9zM5.54 11 2 7.46l1.41-1.41 2.12 2.12 4.24-4.24 1.41 1.41zm0 8L2 15.46l1.41-1.41 2.12 2.12 4.24-4.24 1.41 1.41z"
}), "Checklist");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonTaskList.js
function MenuButtonTaskList(props) {
  var _a;
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime94.jsx)(MenuButton, { tooltipLabel: "Task checklist", tooltipShortcutKeys: ["mod", "Shift", "9"], IconComponent: Checklist_default, selected: (_a = editor === null || editor === void 0 ? void 0 : editor.isActive("taskList")) !== null && _a !== void 0 ? _a : false, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().toggleTaskList(), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleTaskList().run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonTextColor.js
var import_jsx_runtime95 = __toESM(require_jsx_runtime());
function MenuButtonTextColor({ IconComponent = FormatColorTextNoBar_default, tooltipLabel = "Text color", defaultTextColor = "", ...menuButtonProps }) {
  const editor = useRichTextEditorContext();
  const allCurrentTextStyleAttrs = editor ? getAttributesForEachSelected(editor.state, "textStyle") : [];
  const isTextStyleAppliedToEntireSelection = !!(editor === null || editor === void 0 ? void 0 : editor.isActive("textStyle"));
  const currentColors = allCurrentTextStyleAttrs.map(
    // Treat any null/missing color as the default color
    (attrs) => attrs.color || defaultTextColor
  );
  if (!isTextStyleAppliedToEntireSelection) {
    currentColors.push(defaultTextColor);
  }
  const numUniqueCurrentColors = new Set(currentColors).size;
  let currentColor;
  if (numUniqueCurrentColors === 1) {
    currentColor = currentColors[0];
  } else if (numUniqueCurrentColors > 1) {
    currentColor = "";
  } else {
    currentColor = defaultTextColor;
  }
  return (0, import_jsx_runtime95.jsx)(MenuButtonColorPicker, { IconComponent, tooltipLabel, value: currentColor, onChange: (newColor) => {
    editor === null || editor === void 0 ? void 0 : editor.chain().focus().setColor(newColor).run();
  }, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().setColor("#000"), ...menuButtonProps, labels: { removeColorButton: "Reset", ...menuButtonProps.labels } });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonUnderline.js
var import_jsx_runtime97 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/FormatUnderlined.js
var import_jsx_runtime96 = __toESM(require_jsx_runtime());
var FormatUnderlined_default = createSvgIcon((0, import_jsx_runtime96.jsx)("path", {
  d: "M12 17c3.31 0 6-2.69 6-6V3h-2.5v8c0 1.93-1.57 3.5-3.5 3.5S8.5 12.93 8.5 11V3H6v8c0 3.31 2.69 6 6 6m-7 2v2h14v-2z"
}), "FormatUnderlined");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonUnderline.js
function MenuButtonUnderline(props) {
  var _a;
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime97.jsx)(MenuButton, { tooltipLabel: "Underline", tooltipShortcutKeys: ["mod", "U"], IconComponent: FormatUnderlined_default, selected: (_a = editor === null || editor === void 0 ? void 0 : editor.isActive("underline")) !== null && _a !== void 0 ? _a : false, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().toggleUnderline(), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleUnderline().run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonUndo.js
var import_jsx_runtime99 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/Undo.js
var import_jsx_runtime98 = __toESM(require_jsx_runtime());
var Undo_default = createSvgIcon((0, import_jsx_runtime98.jsx)("path", {
  d: "M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8"
}), "Undo");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonUndo.js
function MenuButtonUndo(props) {
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime99.jsx)(MenuButton, { tooltipLabel: "Undo", tooltipShortcutKeys: ["mod", "Z"], IconComponent: Undo_default, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().undo(), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().undo().run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonUnindent.js
var import_jsx_runtime101 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/FormatIndentDecrease.js
var import_jsx_runtime100 = __toESM(require_jsx_runtime());
var FormatIndentDecrease_default = createSvgIcon((0, import_jsx_runtime100.jsx)("path", {
  d: "M11 17h10v-2H11zm-8-5 4 4V8zm0 9h18v-2H3zM3 3v2h18V3zm8 6h10V7H11zm0 4h10v-2H11z"
}), "FormatIndentDecrease");

// node_modules/mui-tiptap/dist/esm/controls/MenuButtonUnindent.js
function MenuButtonUnindent(props) {
  const editor = useRichTextEditorContext();
  return (0, import_jsx_runtime101.jsx)(MenuButton, { tooltipLabel: "Unindent", tooltipShortcutKeys: ["Shift", "Tab"], IconComponent: FormatIndentDecrease_default, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().liftListItem("listItem"), onClick: () => editor === null || editor === void 0 ? void 0 : editor.chain().focus().liftListItem("listItem").run(), ...props });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuSelect.js
var import_jsx_runtime102 = __toESM(require_jsx_runtime());
var import_react40 = __toESM(require_react());
var useStyles19 = makeStyles({ name: { MenuSelect } })((theme) => {
  return {
    rootTooltipWrapper: {
      display: "inline-flex"
    },
    selectRoot: {
      // Don't show the default outline when not hovering or focused, for better
      // style consistency with the MenuButtons
      [`&:not(:hover):not(.${outlinedInputClasses_default.focused}) .${outlinedInputClasses_default.notchedOutline}`]: {
        borderWidth: 0
      },
      [`& .${svgIconClasses_default.root}`]: {
        // Ensure that if an icon is used as the `renderValue` result, it uses
        // the same color as the default ToggleButton icon and the Select
        // dropdown arrow icon
        // https://github.com/mui/material-ui/blob/2cb9664b16d5a862a3796add7c8e3b088b47acb5/packages/mui-material/src/ToggleButton/ToggleButton.js#L60,
        // https://github.com/mui/material-ui/blob/0b7beb93c9015da6e35c2a31510f679126cf0de1/packages/mui-material/src/NativeSelect/NativeSelectInput.js#L96
        color: theme.palette.action.active
      },
      [`&.${selectClasses_default.disabled} .${svgIconClasses_default.root}`]: {
        // Matching
        // https://github.com/mui/material-ui/blob/2cb9664b16d5a862a3796add7c8e3b088b47acb5/packages/mui-material/src/ToggleButton/ToggleButton.js#L65
        color: theme.palette.action.disabled
      }
    },
    select: {
      // Increase specificity to override MUI's styles
      "&&&": {
        paddingLeft: theme.spacing(1),
        paddingRight: theme.spacing(3)
      }
    },
    selectDropdownIcon: {
      // Move the caret icon closer to the right than default so the button is
      // more compact
      right: 1
    },
    input: {
      paddingTop: "3px",
      paddingBottom: "3px",
      fontSize: "0.9em"
    }
  };
});
function MenuSelect({ tooltipTitle, ...selectProps }) {
  var _a, _b, _c;
  const { classes, cx } = useStyles19();
  const [tooltipOpen, setTooltipOpen] = (0, import_react40.useState)(false);
  const select = (0, import_jsx_runtime102.jsx)(Select_default, {
    margin: "none",
    variant: "outlined",
    size: "small",
    ...selectProps,
    onMouseEnter: (...args) => {
      var _a2;
      setTooltipOpen(true);
      (_a2 = selectProps.onMouseEnter) === null || _a2 === void 0 ? void 0 : _a2.call(selectProps, ...args);
    },
    onMouseLeave: (...args) => {
      var _a2;
      setTooltipOpen(false);
      (_a2 = selectProps.onMouseLeave) === null || _a2 === void 0 ? void 0 : _a2.call(selectProps, ...args);
    },
    onClick: (...args) => {
      var _a2;
      setTooltipOpen(false);
      (_a2 = selectProps.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(selectProps, ...args);
    },
    onOpen: (...args) => {
      var _a2;
      setTooltipOpen(false);
      (_a2 = selectProps.onOpen) === null || _a2 === void 0 ? void 0 : _a2.call(selectProps, ...args);
    },
    inputProps: {
      ...selectProps.inputProps,
      className: cx(classes.input, (_a = selectProps.inputProps) === null || _a === void 0 ? void 0 : _a.className)
    },
    // Always show the dropdown options directly below the select input,
    // aligned to left-most edge
    MenuProps: {
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "left"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "left"
      },
      ...selectProps.MenuProps
    },
    className: cx(classes.selectRoot, selectProps.className),
    classes: {
      ...selectProps.classes,
      select: cx(classes.select, (_b = selectProps.classes) === null || _b === void 0 ? void 0 : _b.select),
      icon: cx(classes.selectDropdownIcon, (_c = selectProps.classes) === null || _c === void 0 ? void 0 : _c.icon)
    }
  });
  return tooltipTitle ? (0, import_jsx_runtime102.jsx)(MenuButtonTooltip, { label: tooltipTitle, contentWrapperClassName: classes.rootTooltipWrapper, open: tooltipOpen, children: select }) : select;
}

// node_modules/mui-tiptap/dist/esm/controls/MenuSelectFontFamily.js
var import_jsx_runtime103 = __toESM(require_jsx_runtime());
var useStyles20 = makeStyles({ name: { MenuSelectFontFamily } })({
  selectInput: {
    // We use a fixed width so that the Select element won't change sizes as
    // the selected option changes
    width: 55
  }
});
var MULTIPLE_FAMILIES_SELECTED_VALUE = "MULTIPLE";
function MenuSelectFontFamily({ options, hideUnsetOption = false, unsetOptionLabel = "Default", emptyLabel = "Font", ...menuSelectProps }) {
  var _a;
  const { classes, cx } = useStyles20();
  const editor = useRichTextEditorContext();
  const allCurrentTextStyleAttrs = editor ? getAttributesForEachSelected(editor.state, "textStyle") : [];
  const isTextStyleAppliedToEntireSelection = !!(editor === null || editor === void 0 ? void 0 : editor.isActive("textStyle"));
  const currentFontFamilies = allCurrentTextStyleAttrs.map((attrs) => {
    var _a2;
    return (_a2 = attrs.fontFamily) !== null && _a2 !== void 0 ? _a2 : "";
  });
  if (!isTextStyleAppliedToEntireSelection) {
    currentFontFamilies.push("");
  }
  const numUniqueCurrentFontFamilies = new Set(currentFontFamilies).size;
  let currentFontFamily;
  if (numUniqueCurrentFontFamilies === 1) {
    currentFontFamily = currentFontFamilies[0];
  } else if (numUniqueCurrentFontFamilies > 1) {
    currentFontFamily = MULTIPLE_FAMILIES_SELECTED_VALUE;
  } else {
    currentFontFamily = "";
  }
  return (0, import_jsx_runtime103.jsxs)(MenuSelect, {
    onChange: (event) => {
      const value = event.target.value;
      if (value) {
        editor === null || editor === void 0 ? void 0 : editor.chain().setFontFamily(value).focus().run();
      } else {
        editor === null || editor === void 0 ? void 0 : editor.chain().unsetFontFamily().focus().run();
      }
    },
    disabled: (
      // Pass an arbitrary value just to check `can()`
      !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().setFontFamily("serif")
    ),
    renderValue: (value) => {
      var _a2, _b;
      if (!value || value === MULTIPLE_FAMILIES_SELECTED_VALUE) {
        return emptyLabel;
      }
      return (_b = (_a2 = options.find((option) => option.value === value)) === null || _a2 === void 0 ? void 0 : _a2.label) !== null && _b !== void 0 ? _b : value;
    },
    displayEmpty: true,
    "aria-label": "Font families",
    tooltipTitle: "Font",
    ...menuSelectProps,
    // We don't want to pass any non-string falsy values here, always falling
    // back to ""
    value: currentFontFamily || "",
    inputProps: {
      ...menuSelectProps.inputProps,
      className: cx(classes.selectInput, (_a = menuSelectProps.inputProps) === null || _a === void 0 ? void 0 : _a.className)
    },
    children: [!hideUnsetOption && // Allow users to unset the font-family
    (0, import_jsx_runtime103.jsx)(MenuItem_default, { value: "", children: unsetOptionLabel }), (0, import_jsx_runtime103.jsx)(MenuItem_default, { style: { display: "none" }, value: MULTIPLE_FAMILIES_SELECTED_VALUE }), options.map((fontFamilyOption) => {
      var _a2;
      return (0, import_jsx_runtime103.jsx)(MenuItem_default, { value: fontFamilyOption.value, children: (0, import_jsx_runtime103.jsx)("span", { style: { fontFamily: fontFamilyOption.value }, children: (_a2 = fontFamilyOption.label) !== null && _a2 !== void 0 ? _a2 : fontFamilyOption.value }) }, fontFamilyOption.value);
    })]
  });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuSelectFontSize.js
var import_jsx_runtime105 = __toESM(require_jsx_runtime());

// node_modules/@mui/icons-material/esm/FormatSize.js
var import_jsx_runtime104 = __toESM(require_jsx_runtime());
var FormatSize_default = createSvgIcon((0, import_jsx_runtime104.jsx)("path", {
  d: "M9 4v3h5v12h3V7h5V4zm-6 8h3v7h3v-7h3V9H3z"
}), "FormatSize");

// node_modules/mui-tiptap/dist/esm/controls/MenuSelectFontSize.js
var useStyles21 = makeStyles({ name: { MenuSelectFontSize } })({
  selectInput: {
    // We use a fixed width so that the Select element won't change sizes as
    // the selected option changes (which would shift other elements in the
    // menu bar), since the options may be different sizes
    width: 17,
    // Ensure that if we render an icon as the value, it's vertically aligned
    // properly
    display: "flex",
    alignItems: "center"
  },
  fontSizeIcon: {
    fontSize: MENU_BUTTON_FONT_SIZE_DEFAULT
  }
});
var DEFAULT_FONT_SIZE_SELECT_OPTIONS = [
  "8px",
  "9px",
  "10px",
  "11px",
  "12px",
  "14px",
  "16px",
  "18px",
  "24px",
  "30px",
  "36px",
  "48px",
  "60px",
  "72px",
  "96px"
];
function stripPxFromValue(value) {
  return value.replace("px", "");
}
var MULTIPLE_SIZES_SELECTED_VALUE = "MULTIPLE";
function MenuSelectFontSize({
  options = DEFAULT_FONT_SIZE_SELECT_OPTIONS,
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  sizeOptions,
  hideUnsetOption = false,
  unsetOptionLabel = "Default",
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  unsetOptionContent,
  emptyLabel,
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  emptyValue,
  ...menuSelectProps
}) {
  var _a;
  const { classes, cx } = useStyles21();
  const editor = useRichTextEditorContext();
  emptyLabel = emptyValue !== null && emptyValue !== void 0 ? emptyValue : emptyLabel;
  unsetOptionLabel = unsetOptionContent !== null && unsetOptionContent !== void 0 ? unsetOptionContent : unsetOptionLabel;
  options = sizeOptions !== null && sizeOptions !== void 0 ? sizeOptions : options;
  const optionObjects = (options !== null && options !== void 0 ? options : []).map((option) => typeof option === "string" ? { value: option } : option);
  const allCurrentTextStyleAttrs = editor ? getAttributesForEachSelected(editor.state, "textStyle") : [];
  const isTextStyleAppliedToEntireSelection = !!(editor === null || editor === void 0 ? void 0 : editor.isActive("textStyle"));
  const currentFontSizes = allCurrentTextStyleAttrs.map((attrs) => {
    var _a2;
    return (_a2 = attrs.fontSize) !== null && _a2 !== void 0 ? _a2 : "";
  });
  if (!isTextStyleAppliedToEntireSelection) {
    currentFontSizes.push("");
  }
  const numUniqueCurrentFontSizes = new Set(currentFontSizes).size;
  let currentFontSize;
  if (numUniqueCurrentFontSizes === 1) {
    currentFontSize = currentFontSizes[0];
  } else if (numUniqueCurrentFontSizes > 1) {
    currentFontSize = MULTIPLE_SIZES_SELECTED_VALUE;
  } else {
    currentFontSize = "";
  }
  return (0, import_jsx_runtime105.jsxs)(MenuSelect, {
    onChange: (event) => {
      const value = event.target.value;
      if (value) {
        editor === null || editor === void 0 ? void 0 : editor.chain().setFontSize(value).focus().run();
      } else {
        editor === null || editor === void 0 ? void 0 : editor.chain().unsetFontSize().focus().run();
      }
    },
    disabled: (
      // Pass an arbitrary value to can().setFontSize() just to check `can()`
      !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !editor.can().setFontSize("12px")
    ),
    renderValue: (value) => {
      if (!value || value === MULTIPLE_SIZES_SELECTED_VALUE) {
        return emptyLabel !== null && emptyLabel !== void 0 ? emptyLabel : (0, import_jsx_runtime105.jsx)(FormatSize_default, { className: classes.fontSizeIcon });
      }
      return stripPxFromValue(value);
    },
    displayEmpty: true,
    "aria-label": "Font sizes",
    tooltipTitle: "Font size",
    ...menuSelectProps,
    // We don't want to pass any non-string falsy values here, always falling
    // back to ""
    value: currentFontSize || "",
    inputProps: {
      ...menuSelectProps.inputProps,
      className: cx(classes.selectInput, (_a = menuSelectProps.inputProps) === null || _a === void 0 ? void 0 : _a.className)
    },
    children: [!hideUnsetOption && // Allow users to unset the font size
    (0, import_jsx_runtime105.jsx)(MenuItem_default, { value: "", children: unsetOptionLabel }), (0, import_jsx_runtime105.jsx)(MenuItem_default, { style: { display: "none" }, value: MULTIPLE_SIZES_SELECTED_VALUE }), optionObjects.map((option) => {
      var _a2;
      return (0, import_jsx_runtime105.jsx)(MenuItem_default, { value: option.value, children: (_a2 = option.label) !== null && _a2 !== void 0 ? _a2 : stripPxFromValue(option.value) }, option.value);
    })]
  });
}

// node_modules/mui-tiptap/dist/esm/controls/MenuSelectHeading.js
var import_jsx_runtime106 = __toESM(require_jsx_runtime());
var import_react41 = __toESM(require_react());
var useStyles22 = makeStyles({ name: { MenuSelectHeading } })((theme) => {
  const editorStyles = getEditorStyles(theme);
  return {
    selectInput: {
      // We use a fixed width so that the Select element won't change sizes as
      // the selected option changes (which would shift other elements in the
      // menu bar)
      width: 77
    },
    menuOption: {
      // These styles ensure the item fills its MenuItem container, and the
      // tooltip appears in the same place when hovering over the item generally
      // (not just the text of the item)
      display: "block",
      width: "100%"
    },
    headingOption: {
      marginBlockStart: 0,
      marginBlockEnd: 0,
      fontWeight: "bold"
    },
    headingOption1: {
      fontSize: editorStyles["& h1"].fontSize
    },
    headingOption2: {
      fontSize: editorStyles["& h2"].fontSize
    },
    headingOption3: {
      fontSize: editorStyles["& h3"].fontSize
    },
    headingOption4: {
      fontSize: editorStyles["& h4"].fontSize
    },
    headingOption5: {
      fontSize: editorStyles["& h5"].fontSize
    },
    headingOption6: {
      fontSize: editorStyles["& h6"].fontSize
    }
  };
});
var HEADING_OPTION_VALUES = {
  Paragraph: "Paragraph",
  Heading1: "Heading 1",
  Heading2: "Heading 2",
  Heading3: "Heading 3",
  Heading4: "Heading 4",
  Heading5: "Heading 5",
  Heading6: "Heading 6"
};
var HEADING_OPTION_VALUE_TO_LEVEL = {
  [HEADING_OPTION_VALUES.Heading1]: 1,
  [HEADING_OPTION_VALUES.Heading2]: 2,
  [HEADING_OPTION_VALUES.Heading3]: 3,
  [HEADING_OPTION_VALUES.Heading4]: 4,
  [HEADING_OPTION_VALUES.Heading5]: 5,
  [HEADING_OPTION_VALUES.Heading6]: 6
};
var LEVEL_TO_HEADING_OPTION_VALUE = {
  1: HEADING_OPTION_VALUES.Heading1,
  2: HEADING_OPTION_VALUES.Heading2,
  3: HEADING_OPTION_VALUES.Heading3,
  4: HEADING_OPTION_VALUES.Heading4,
  5: HEADING_OPTION_VALUES.Heading5,
  6: HEADING_OPTION_VALUES.Heading6
};
function MenuSelectHeading({ labels, hideShortcuts = false, ...menuSelectProps }) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const { classes, cx } = useStyles22();
  const editor = useRichTextEditorContext();
  const handleHeadingType = (0, import_react41.useCallback)((event) => {
    const value = event.target.value;
    if (value === HEADING_OPTION_VALUES.Paragraph) {
      editor === null || editor === void 0 ? void 0 : editor.chain().setParagraph().focus().run();
    } else if (value in HEADING_OPTION_VALUE_TO_LEVEL) {
      editor === null || editor === void 0 ? void 0 : editor.chain().setHeading({
        level: HEADING_OPTION_VALUE_TO_LEVEL[value]
      }).focus().run();
    }
  }, [editor]);
  let selectedValue = "";
  let currentLevel;
  if (editor === null || editor === void 0 ? void 0 : editor.isActive("paragraph")) {
    selectedValue = HEADING_OPTION_VALUES.Paragraph;
  } else if (editor === null || editor === void 0 ? void 0 : editor.isActive("heading")) {
    const currentNodeHeadingAttributes = getAttributesForEachSelected(editor.state, "heading");
    const currentNodeLevels = currentNodeHeadingAttributes.map((attrs) => attrs.level);
    const numCurrentNodeLevels = new Set(currentNodeLevels).size;
    currentLevel = numCurrentNodeLevels === 1 ? currentNodeLevels[0] : void 0;
    if (currentLevel && currentLevel in LEVEL_TO_HEADING_OPTION_VALUE) {
      selectedValue = LEVEL_TO_HEADING_OPTION_VALUE[currentLevel];
    }
  }
  const isCurrentlyParagraphOrHeading = selectedValue !== "";
  const canSetParagraph = !!(editor === null || editor === void 0 ? void 0 : editor.can().setParagraph());
  const enabledHeadingLevels = (0, import_react41.useMemo)(() => {
    var _a2;
    const headingExtension = editor === null || editor === void 0 ? void 0 : editor.extensionManager.extensions.find((extension) => extension.name == "heading");
    return new Set((_a2 = headingExtension === null || headingExtension === void 0 ? void 0 : headingExtension.options.levels) !== null && _a2 !== void 0 ? _a2 : []);
  }, [editor]);
  const firstEnabledHeadingResult = enabledHeadingLevels.values().next();
  const firstEnabledHeading = firstEnabledHeadingResult.done ? void 0 : firstEnabledHeadingResult.value;
  const canSetHeading = firstEnabledHeading !== void 0 && (currentLevel === firstEnabledHeading || !!(editor === null || editor === void 0 ? void 0 : editor.can().setHeading({ level: firstEnabledHeading })));
  return (
    // We currently have to specify that the value is of type
    // `HeadingOptionValue | ""` rather than just `HeadingOptionValue` due to
    // the bug reported here https://github.com/mui/material-ui/issues/34083. We
    // need it to support "" as a possible value in the `renderValue` function
    // below since we have `displayEmpty=true`, and the types don't properly
    // handle that scenario.
    (0, import_jsx_runtime106.jsxs)(MenuSelect, { onChange: handleHeadingType, disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !isCurrentlyParagraphOrHeading && !canSetParagraph && !canSetHeading, displayEmpty: true, renderValue: (selected) => {
      var _a2, _b2;
      let result;
      if (selected === "") {
        result = (_b2 = (_a2 = labels === null || labels === void 0 ? void 0 : labels.emptyValue) !== null && _a2 !== void 0 ? _a2 : labels === null || labels === void 0 ? void 0 : labels.empty) !== null && _b2 !== void 0 ? _b2 : (0, import_jsx_runtime106.jsx)("em", { children: "Change to…" });
      } else if (selected === HEADING_OPTION_VALUES.Paragraph) {
        result = labels === null || labels === void 0 ? void 0 : labels.paragraph;
      } else if (selected === HEADING_OPTION_VALUES.Heading1) {
        result = labels === null || labels === void 0 ? void 0 : labels.heading1;
      } else if (selected === HEADING_OPTION_VALUES.Heading2) {
        result = labels === null || labels === void 0 ? void 0 : labels.heading2;
      } else if (selected === HEADING_OPTION_VALUES.Heading3) {
        result = labels === null || labels === void 0 ? void 0 : labels.heading3;
      } else if (selected === HEADING_OPTION_VALUES.Heading4) {
        result = labels === null || labels === void 0 ? void 0 : labels.heading4;
      } else if (selected === HEADING_OPTION_VALUES.Heading5) {
        result = labels === null || labels === void 0 ? void 0 : labels.heading5;
      } else if (selected === HEADING_OPTION_VALUES.Heading6) {
        result = labels === null || labels === void 0 ? void 0 : labels.heading6;
      }
      return result !== null && result !== void 0 ? result : selected;
    }, "aria-label": "Text headings", tooltipTitle: "Styles", ...menuSelectProps, value: selectedValue, inputProps: {
      ...menuSelectProps.inputProps,
      className: cx(classes.selectInput, (_a = menuSelectProps.inputProps) === null || _a === void 0 ? void 0 : _a.className)
    }, children: [(0, import_jsx_runtime106.jsx)(MenuItem_default, { value: HEADING_OPTION_VALUES.Paragraph, disabled: !isCurrentlyParagraphOrHeading && !canSetParagraph, children: (0, import_jsx_runtime106.jsx)(MenuButtonTooltip, { label: "", shortcutKeys: hideShortcuts ? void 0 : ["mod", "alt", "0"], placement: "right", contentWrapperClassName: classes.menuOption, children: (_b = labels === null || labels === void 0 ? void 0 : labels.paragraph) !== null && _b !== void 0 ? _b : HEADING_OPTION_VALUES.Paragraph }) }), enabledHeadingLevels.has(1) && (0, import_jsx_runtime106.jsx)(MenuItem_default, { value: HEADING_OPTION_VALUES.Heading1, disabled: !canSetHeading, children: (0, import_jsx_runtime106.jsx)(MenuButtonTooltip, { label: "", shortcutKeys: hideShortcuts ? void 0 : ["mod", "alt", "1"], placement: "right", contentWrapperClassName: cx(classes.menuOption, classes.headingOption, classes.headingOption1), children: (_c = labels === null || labels === void 0 ? void 0 : labels.heading1) !== null && _c !== void 0 ? _c : HEADING_OPTION_VALUES.Heading1 }) }), enabledHeadingLevels.has(2) && (0, import_jsx_runtime106.jsx)(MenuItem_default, { value: HEADING_OPTION_VALUES.Heading2, disabled: !canSetHeading, children: (0, import_jsx_runtime106.jsx)(MenuButtonTooltip, { label: "", shortcutKeys: hideShortcuts ? void 0 : ["mod", "alt", "2"], placement: "right", contentWrapperClassName: cx(classes.menuOption, classes.headingOption, classes.headingOption2), children: (_d = labels === null || labels === void 0 ? void 0 : labels.heading2) !== null && _d !== void 0 ? _d : HEADING_OPTION_VALUES.Heading2 }) }), enabledHeadingLevels.has(3) && (0, import_jsx_runtime106.jsx)(MenuItem_default, { value: HEADING_OPTION_VALUES.Heading3, disabled: !canSetHeading, children: (0, import_jsx_runtime106.jsx)(MenuButtonTooltip, { label: "", shortcutKeys: hideShortcuts ? void 0 : ["mod", "alt", "3"], placement: "right", contentWrapperClassName: cx(classes.menuOption, classes.headingOption, classes.headingOption3), children: (_e = labels === null || labels === void 0 ? void 0 : labels.heading3) !== null && _e !== void 0 ? _e : HEADING_OPTION_VALUES.Heading3 }) }), enabledHeadingLevels.has(4) && (0, import_jsx_runtime106.jsx)(MenuItem_default, { value: HEADING_OPTION_VALUES.Heading4, disabled: !canSetHeading, children: (0, import_jsx_runtime106.jsx)(MenuButtonTooltip, { label: "", shortcutKeys: hideShortcuts ? void 0 : ["mod", "alt", "4"], placement: "right", contentWrapperClassName: cx(classes.menuOption, classes.headingOption, classes.headingOption4), children: (_f = labels === null || labels === void 0 ? void 0 : labels.heading4) !== null && _f !== void 0 ? _f : HEADING_OPTION_VALUES.Heading4 }) }), enabledHeadingLevels.has(5) && (0, import_jsx_runtime106.jsx)(MenuItem_default, { value: HEADING_OPTION_VALUES.Heading5, disabled: !canSetHeading, children: (0, import_jsx_runtime106.jsx)(MenuButtonTooltip, { label: "", shortcutKeys: hideShortcuts ? void 0 : ["mod", "alt", "5"], placement: "right", contentWrapperClassName: cx(classes.menuOption, classes.headingOption, classes.headingOption5), children: (_g = labels === null || labels === void 0 ? void 0 : labels.heading5) !== null && _g !== void 0 ? _g : HEADING_OPTION_VALUES.Heading5 }) }), enabledHeadingLevels.has(6) && (0, import_jsx_runtime106.jsx)(MenuItem_default, { value: HEADING_OPTION_VALUES.Heading6, disabled: !canSetHeading, children: (0, import_jsx_runtime106.jsx)(MenuButtonTooltip, { label: "", shortcutKeys: hideShortcuts ? void 0 : ["mod", "alt", "6"], placement: "right", contentWrapperClassName: cx(classes.menuOption, classes.headingOption, classes.headingOption6), children: (_h = labels === null || labels === void 0 ? void 0 : labels.heading6) !== null && _h !== void 0 ? _h : HEADING_OPTION_VALUES.Heading6 }) })] })
  );
}

// node_modules/mui-tiptap/dist/esm/controls/MenuSelectTextAlign.js
var import_jsx_runtime107 = __toESM(require_jsx_runtime());
var import_react42 = __toESM(require_react());
var useStyles23 = makeStyles({ name: { MenuSelectTextAlign } })((theme) => ({
  selectInput: {
    // We use a fixed width equal to the size of the menu button icon so that
    // the Select element won't change sizes even if we show the "blank"
    // interface when the selected content contains multiple different text
    // alignments.
    width: MENU_BUTTON_FONT_SIZE_DEFAULT
  },
  menuItem: {
    paddingLeft: 0,
    paddingRight: 0
  },
  menuOption: {
    // These styles ensure the item fills its MenuItem container, and the
    // tooltip appears in the same place when hovering over the item generally
    // (not just the text of the item)
    display: "flex",
    width: "100%",
    justifyContent: "center"
  },
  menuButtonIcon: {
    fontSize: MENU_BUTTON_FONT_SIZE_DEFAULT,
    // For consistency with toggle button default icon color and the Select
    // dropdown arrow icon color
    // https://github.com/mui/material-ui/blob/2cb9664b16d5a862a3796add7c8e3b088b47acb5/packages/mui-material/src/ToggleButton/ToggleButton.js#L60,
    // https://github.com/mui/material-ui/blob/0b7beb93c9015da6e35c2a31510f679126cf0de1/packages/mui-material/src/NativeSelect/NativeSelectInput.js#L96
    color: theme.palette.action.active
  }
}));
var DEFAULT_ALIGNMENT_OPTIONS = [
  {
    value: "left",
    label: "Left",
    shortcutKeys: ["mod", "Shift", "L"],
    IconComponent: FormatAlignLeft_default
  },
  {
    value: "center",
    label: "Center",
    shortcutKeys: ["mod", "Shift", "E"],
    IconComponent: FormatAlignCenter_default
  },
  {
    value: "right",
    label: "Right",
    shortcutKeys: ["mod", "Shift", "R"],
    IconComponent: FormatAlignRight_default
  },
  {
    value: "justify",
    label: "Justify",
    shortcutKeys: ["mod", "Shift", "J"],
    IconComponent: FormatAlignJustify_default
  }
];
function MenuSelectTextAlign({
  options = DEFAULT_ALIGNMENT_OPTIONS,
  emptyLabel = "",
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  alignmentOptions,
  ...menuSelectProps
}) {
  var _a, _b, _c;
  const { classes, cx } = useStyles23();
  const editor = useRichTextEditorContext();
  options = (_a = alignmentOptions === null || alignmentOptions === void 0 ? void 0 : alignmentOptions.map((option) => ({
    ...option,
    value: option.alignment
  }))) !== null && _a !== void 0 ? _a : options;
  const handleAlignmentSelect = (0, import_react42.useCallback)((event) => {
    const alignment = event.target.value;
    editor === null || editor === void 0 ? void 0 : editor.chain().setTextAlign(alignment).focus().run();
  }, [editor]);
  const textAlignExtensionOptions = (0, import_react42.useMemo)(() => {
    const textAlignExtension = editor === null || editor === void 0 ? void 0 : editor.extensionManager.extensions.find((extension) => extension.name == "textAlign");
    return textAlignExtension === null || textAlignExtension === void 0 ? void 0 : textAlignExtension.options;
  }, [editor]);
  const enabledAlignments = (0, import_react42.useMemo)(() => {
    return new Set(textAlignExtensionOptions === null || textAlignExtensionOptions === void 0 ? void 0 : textAlignExtensionOptions.alignments);
  }, [textAlignExtensionOptions]);
  const selectedValue = (_b = Array.from(enabledAlignments).find((alignment) => editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: alignment }))) !== null && _b !== void 0 ? _b : "";
  return (0, import_jsx_runtime107.jsx)(MenuSelect, {
    onChange: handleAlignmentSelect,
    disabled: !(editor === null || editor === void 0 ? void 0 : editor.isEditable) || !Array.from(enabledAlignments).some((alignment) => editor.can().setTextAlign(alignment)),
    // Override the rendering of the selected value so that we don't show
    // tooltips on hovering (like we do for the menu options)
    renderValue: (value) => {
      let content;
      if (value) {
        const alignmentOptionForValue = options.find((option) => option.value === value);
        content = alignmentOptionForValue ? (0, import_jsx_runtime107.jsx)(alignmentOptionForValue.IconComponent, { className: classes.menuButtonIcon }) : value;
      } else {
        content = emptyLabel;
      }
      return (0, import_jsx_runtime107.jsx)("span", { className: classes.menuOption, children: content });
    },
    "aria-label": "Text alignments",
    tooltipTitle: "Align",
    value: selectedValue,
    displayEmpty: true,
    ...menuSelectProps,
    inputProps: {
      ...menuSelectProps.inputProps,
      className: cx(classes.selectInput, (_c = menuSelectProps.inputProps) === null || _c === void 0 ? void 0 : _c.className)
    },
    children: options.filter((alignmentOption) => enabledAlignments.has(alignmentOption.value)).map((alignmentOption) => {
      var _a2;
      return (0, import_jsx_runtime107.jsx)(MenuItem_default, { value: alignmentOption.value, disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().setTextAlign(alignmentOption.value)), className: classes.menuItem, children: (0, import_jsx_runtime107.jsx)(MenuButtonTooltip, { label: (_a2 = alignmentOption.label) !== null && _a2 !== void 0 ? _a2 : "", shortcutKeys: alignmentOption.shortcutKeys, placement: "right", contentWrapperClassName: classes.menuOption, children: (0, import_jsx_runtime107.jsx)(alignmentOption.IconComponent, { className: classes.menuButtonIcon }) }) }, alignmentOption.value);
    })
  });
}

// node_modules/mui-tiptap/dist/esm/extensions/FontSize.js
var FontSize = Extension.create({
  name: "fontSize",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontSize: {
            default: null,
            parseHTML: (element) => element.style.fontSize.replace(/['"]+/g, ""),
            renderHTML: (attributes) => {
              if (!attributes.fontSize) {
                return {};
              }
              return {
                style: `font-size: ${attributes.fontSize}`
              };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontSize: (fontSize) => ({ chain }) => {
        return chain().setMark("textStyle", { fontSize }).run();
      },
      unsetFontSize: () => ({ chain }) => {
        return chain().setMark("textStyle", { fontSize: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
var FontSize_default = FontSize;

// node_modules/mui-tiptap/dist/esm/extensions/HeadingWithAnchorComponent.js
var import_jsx_runtime108 = __toESM(require_jsx_runtime());
var import_react44 = __toESM(require_react());
var useStyles24 = makeStyles({
  name: { HeadingWithAnchorComponent },
  uniqId: "kNc4LD"
  // https://docs.tss-react.dev/nested-selectors#ssr
})((theme, _params, classes) => ({
  root: {
    // Reference the "link" class defined below so that when the header is
    // hovered over, we make the anchor link visible.
    [`&:hover .${classes.link}`]: {
      opacity: 100
    }
  },
  container: {
    // Use inline-block so that the container is only as big as the inner
    // heading content
    display: "inline-block",
    // Use relative position so that the link is positioned relative to
    // the inner heading content position (via this common container)
    position: "relative"
  },
  link: {
    position: "absolute",
    left: -21,
    color: `${theme.palette.text.secondary} !important`,
    opacity: 0,
    transition: theme.transitions.create("opacity"),
    textDecoration: "none",
    outline: "none",
    [theme.breakpoints.down("sm")]: {
      left: -18
    },
    // As described here https://github.com/ueberdosis/tiptap/issues/3775,
    // updates to editor isEditable do not trigger re-rendering of node views.
    // Even editor state changes external to a given ReactNodeView component
    // will not trigger re-render (which is probably a good thing most of the
    // time, in terms of performance). As such, we always render the link in the
    // DOM, but hide it with CSS when the editor is editable.
    '.ProseMirror[contenteditable="true"] &': {
      display: "none"
    }
  },
  linkIcon: {
    // Looks better to have at an angle, similar to the GitHub icon
    transform: "rotate(-45deg)",
    fontSize: "1.25rem",
    [theme.breakpoints.down("sm")]: {
      fontSize: "1.15rem"
    }
  }
}));
var headingWithAnchorComponentClasses = getUtilityClasses("HeadingWithAnchorComponent", [
  "root",
  "container",
  "link",
  "linkIcon"
]);
function HeadingWithAnchorComponent({ editor, node, extension }) {
  const { classes, cx } = useStyles24();
  const hasLevel = extension.options.levels.includes(node.attrs.level);
  const level = hasLevel ? node.attrs.level : extension.options.levels[0];
  const HeadingTag = `h${level}`;
  const textSerializers = (0, import_react44.useMemo)(() => getTextSerializersFromSchema(editor.schema), [editor.schema]);
  const headingId = slugify(getText(node, {
    textSerializers
  }));
  return (0, import_jsx_runtime108.jsx)(NodeViewWrapper, {
    as: HeadingTag,
    id: headingId,
    ...extension.options.HTMLAttributes,
    className: cx(headingWithAnchorComponentClasses.root, classes.root),
    // Handle @tiptap/extension-text-align. Ideally we'd be able to inherit
    // this style from TextAlign's GlobalAttributes directly, but those are
    // only applied via `renderHTML` and not the `NodeView` renderer
    // (https://github.com/ueberdosis/tiptap/blob/6c34dec33ac39c9f037a0a72e4525f3fc6d422bf/packages/extension-text-align/src/text-align.ts#L43-L49),
    // so we have to do this manually/redundantly here.
    style: { textAlign: node.attrs.textAlign },
    children: (0, import_jsx_runtime108.jsxs)("span", { className: cx(headingWithAnchorComponentClasses.container, classes.container), children: [(0, import_jsx_runtime108.jsx)("a", { href: `#${headingId}`, contentEditable: false, className: cx(headingWithAnchorComponentClasses.link, classes.link), children: (0, import_jsx_runtime108.jsx)(Link_default2, { className: cx(headingWithAnchorComponentClasses.linkIcon, classes.linkIcon) }) }), (0, import_jsx_runtime108.jsx)(NodeViewContent, { as: "span" })] })
  });
}

// node_modules/mui-tiptap/dist/esm/extensions/HeadingWithAnchor.js
var HeadingWithAnchor = Heading.extend({
  addOptions() {
    var _a;
    return {
      // Tiptap claims and TS indicates that `this.parent` can be undefined
      // (https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#extend-existing-attributes),
      // but `Heading` does define `addOptions`, so add a type cast
      // (https://github.com/ueberdosis/tiptap/blob/7b4e6f5d11f8213e43d8eab4299f407f79eeb515/packages/extension-heading/src/heading.ts#L50-L55).
      ...(_a = this.parent) === null || _a === void 0 ? void 0 : _a.call(this),
      scrollToAnchorOnMount: true
    };
  },
  onCreate() {
    if (this.options.scrollToAnchorOnMount) {
      setTimeout(() => {
        scrollToCurrentHeadingAnchor(this.editor);
      });
    }
  },
  // Although we could render this using just HTML presumably (via `renderHTML`)
  // and don't need any fancy interaction with React, doing so allows us to use
  // a MUI SVG icon as well as MUI styling
  addNodeView() {
    return ReactNodeViewRenderer(HeadingWithAnchorComponent);
  }
});
var HeadingWithAnchor_default = HeadingWithAnchor;
function scrollToCurrentHeadingAnchor(editor) {
  var _a;
  if (editor.isDestroyed || !("heading" in editor.storage)) {
    return;
  }
  const currentHash = window.location.hash;
  const elementId = currentHash.slice(1);
  if (!elementId) {
    return;
  }
  const elementForHash = window.document.getElementById(elementId);
  if (elementForHash && ((_a = editor.options.element) === null || _a === void 0 ? void 0 : _a.contains(elementForHash))) {
    elementForHash.scrollIntoView({
      behavior: "smooth",
      block: "start",
      inline: "nearest"
    });
  }
}

// node_modules/@tiptap/extension-image/dist/index.js
var inputRegex = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/;
var Image = Node3.create({
  name: "image",
  addOptions() {
    return {
      inline: false,
      allowBase64: false,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: true,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      },
      width: {
        default: null
      },
      height: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["img", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setImage: (options) => ({ commands }) => {
        return commands.insertContent({
          type: this.name,
          attrs: options
        });
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: inputRegex,
        type: this.type,
        getAttributes: (match) => {
          const [, , alt, src, title] = match;
          return { src, alt, title };
        }
      })
    ];
  }
});

// node_modules/mui-tiptap/dist/esm/extensions/ResizableImageComponent.js
var import_jsx_runtime110 = __toESM(require_jsx_runtime());
var import_throttle = __toESM(require_throttle());
var import_react48 = __toESM(require_react());

// node_modules/mui-tiptap/dist/esm/extensions/ResizableImageResizer.js
var import_jsx_runtime109 = __toESM(require_jsx_runtime());
var import_react46 = __toESM(require_react());
var useStyles25 = makeStyles({ name: { ResizableImageResizer } })((theme) => ({
  root: {
    position: "absolute",
    // The `outline` styles of the selected image add 3px to the edges, so we'll
    // position this offset by 3px outside to the bottom right
    bottom: -3,
    right: -3,
    width: 12,
    height: 12,
    background: theme.palette.primary.main,
    cursor: "nwse-resize"
  }
}));
function ResizableImageResizer({ onResize, className, mouseDown, setMouseDown }) {
  const { classes, cx } = useStyles25();
  (0, import_react46.useEffect)(() => {
    if (!mouseDown) {
      return;
    }
    const handleMouseMove2 = (event) => {
      onResize(event);
    };
    window.addEventListener("mousemove", handleMouseMove2);
    return () => {
      window.removeEventListener("mousemove", handleMouseMove2);
    };
  }, [mouseDown, onResize]);
  (0, import_react46.useEffect)(() => {
    const handleMouseUp = () => {
      setMouseDown(false);
    };
    window.addEventListener("mouseup", handleMouseUp);
    return () => {
      window.removeEventListener("mouseup", handleMouseUp);
    };
  }, [setMouseDown]);
  const handleMouseDown3 = (0, import_react46.useCallback)((event) => {
    event.preventDefault();
    event.stopPropagation();
    setMouseDown(true);
  }, [setMouseDown]);
  return (
    // There isn't a great role to use here (perhaps role="separator" is the
    // closest, as described here https://stackoverflow.com/a/43022983/4543977,
    // but we don't do keyboard-based resizing at this time so it doesn't make
    // sense to have it keyboard focusable)
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    (0, import_jsx_runtime109.jsx)("div", {
      // TODO(Steven DeMartini): Add keyboard support and better accessibility
      // here, and allow users to override the aria-label when that happens to
      // support localization.
      // aria-label="resize image"
      className: cx(classes.root, className),
      onMouseDown: handleMouseDown3
    })
  );
}

// node_modules/mui-tiptap/dist/esm/extensions/ResizableImageComponent.js
var IMAGE_MINIMUM_WIDTH_PIXELS = 15;
var useStyles26 = makeStyles({ name: { ResizableImageComponent } })((theme) => ({
  imageContainer: {
    // Use inline-flex so that the container is only as big as the inner img
    display: "inline-flex",
    // Use relative position so that the resizer is positioned relative to
    // the img dimensions (via their common container)
    position: "relative"
  },
  image: {
    // We need display:block in order for the container element to be
    // sized properly (no extra space below the image)
    display: "block"
  },
  imageSelected: {
    // This "selected" state outline style is copied from our standard editor
    // styles (which are kept there as well so they appear even if not using our
    // custom resizable image).
    outline: `3px solid ${theme.palette.primary.main}`
  },
  resizer: {
    // As described here https://github.com/ueberdosis/tiptap/issues/3775,
    // updates to editor isEditable do not trigger re-rendering of node views.
    // Even editor state changes external to a given ReactNodeView component
    // will not trigger re-render (which is probably a good thing most of the
    // time, in terms of performance). As such, we always render the resizer
    // component with React (and so in the DOM), but hide it with CSS when the
    // editor is not editable. This also means its mouse event listeners will
    // also not fire, as intended.
    '.ProseMirror[contenteditable="false"] &': {
      display: "none"
    }
  }
}));
function ResizableImageComponent(props) {
  var _a;
  const { node, selected, updateAttributes, extension } = props;
  const { classes, cx } = useStyles26();
  const { attrs } = node;
  const imageRef = (0, import_react48.useRef)(null);
  const [resizerMouseDown, setResizerMouseDown] = (0, import_react48.useState)(false);
  const selectedOrResizing = selected || resizerMouseDown;
  const handleResize = (0, import_react48.useMemo)(() => (
    // Throttle our "on resize" handler, since the event fires very rapidly during
    // dragging, so rendering would end up stuttering a bit without a throttle
    (0, import_throttle.default)((event) => {
      if (!imageRef.current) {
        return;
      }
      const originalBoundingRect = imageRef.current.getBoundingClientRect();
      const resizedWidth = event.clientX - originalBoundingRect.x;
      const resizedHeight = event.clientY - originalBoundingRect.y;
      const resultantWidth = Math.max(
        resizedWidth,
        originalBoundingRect.width / originalBoundingRect.height * resizedHeight,
        // Set a minimum width, since any smaller is probably a mistake, and we
        // don't want images to get mistakenly shrunken below a size which makes
        // it hard to later select/resize the image
        IMAGE_MINIMUM_WIDTH_PIXELS
      );
      updateAttributes({
        width: Math.round(resultantWidth)
      });
    }, 50, { trailing: true })
  ), [updateAttributes]);
  const ChildComponent = extension.options.ChildComponent;
  return (0, import_jsx_runtime110.jsx)(NodeViewWrapper, {
    style: {
      // Handle @tiptap/extension-text-align. Ideally we'd be able to inherit
      // this style from TextAlign's GlobalAttributes directly, but those are
      // only applied via `renderHTML` and not the `NodeView` renderer
      // (https://github.com/ueberdosis/tiptap/blob/6c34dec33ac39c9f037a0a72e4525f3fc6d422bf/packages/extension-text-align/src/text-align.ts#L43-L49),
      // so we have to do this manually/redundantly here.
      textAlign: attrs.textAlign,
      width: "100%"
    },
    // Change the outer component's component to a "span" if the `inline`
    // extension option is enabled, to ensure it can appear alongside other
    // inline elements like text.
    as: extension.options.inline ? "span" : "div",
    children: (0, import_jsx_runtime110.jsxs)("div", { className: classes.imageContainer, children: [(0, import_jsx_runtime110.jsx)("img", {
      ref: imageRef,
      src: attrs.src,
      height: "auto",
      width: attrs.width ? attrs.width : void 0,
      alt: attrs.alt || void 0,
      title: attrs.title || void 0,
      className: cx(
        classes.image,
        // For consistency with the standard Image extension selection
        // class/UI:
        selectedOrResizing && "ProseMirror-selectednode",
        // We'll only show the outline when the editor content is selected
        selectedOrResizing && classes.imageSelected
      ),
      style: {
        // If no width has been specified, we use auto max-width
        maxWidth: attrs.width ? void 0 : "auto",
        // Always specify the aspect-ratio if it's been defined, to improve
        // initial render (so auto-height works before the image loads)
        aspectRatio: (_a = attrs.aspectRatio) !== null && _a !== void 0 ? _a : void 0
      },
      "data-drag-handle": true,
      // When the image loads, we'll update our width and aspect-ratio based
      // on the image's natural size, if they're not set. That way, all future
      // renders will know the image width/height prior to load/render,
      // preventing flashing
      onLoad: (event) => {
        const newAttributes = {};
        if (!attrs.width) {
          newAttributes.width = event.currentTarget.naturalWidth;
        }
        if (!attrs.aspectRatio) {
          newAttributes.aspectRatio = String(event.currentTarget.naturalWidth / event.currentTarget.naturalHeight);
        }
        if (newAttributes.width || newAttributes.aspectRatio) {
          updateAttributes(newAttributes);
        }
      }
    }), selectedOrResizing && (0, import_jsx_runtime110.jsx)(ResizableImageResizer, { onResize: handleResize, className: classes.resizer, mouseDown: resizerMouseDown, setMouseDown: setResizerMouseDown }), ChildComponent && (0, import_jsx_runtime110.jsx)(ChildComponent, { ...props })] })
  });
}
var ResizableImageComponent_default = ResizableImageComponent;

// node_modules/mui-tiptap/dist/esm/extensions/ResizableImage.js
var ResizableImage = Image.extend({
  addOptions() {
    var _a;
    return {
      // Tiptap claims and TS indicates that `this.parent` can be undefined
      // (https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#extend-existing-attributes),
      // but `Image` does define `addOptions`, so add a type cast
      // https://github.com/ueberdosis/tiptap/blob/d230f7ecf311f4b2212258b30b1f54437d3902d7/packages/extension-image/src/image.ts#L63-L69
      ...(_a = this.parent) === null || _a === void 0 ? void 0 : _a.call(this),
      // By default, allow all images where `src` is non-empty
      isAllowedImgSrc: (src) => {
        if (!src) {
          return false;
        }
        return true;
      }
    };
  },
  addAttributes() {
    var _a;
    return {
      ...(_a = this.parent) === null || _a === void 0 ? void 0 : _a.call(this),
      // The `width` attribute will be used by users to override/specify the width of
      // the image. If not specified, the image will display with its default/full
      // width, up to a `max-width: 100%` (via CSS styles). Height will be set to
      // "auto", so `width` will always determine sizing and we'll preserve the original
      // aspect ratio.
      width: {
        default: null,
        // How to render this attribute in the HTML, so it's serialized/saved
        // (and in this case, affects visuals)
        renderHTML: (attributes) => ({
          width: attributes.width
        }),
        // How to load this attribute from any existing HTML content
        parseHTML: (element) => element.getAttribute("width")
      },
      // The `aspectRatio` attribute will be used to set the `aspect-ratio` CSS
      // style, which ensures that whatever the width (the specific value set
      // via attribute or max-width of 100%, if the viewport is narrower than
      // that), the "height: auto" can be inferred even before the image loads,
      // making the page flash/jitter less before/after the image renders (see
      // https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio, and note
      // that the newer alternative approach they describe using
      // `attr(width) / attr(height)` does not work in Chrome and other browsers
      // yet). We'll make sure to set `aspectRatio` whenever a user resizes and
      // sets `width`, so that we improve initial page/image rendering.
      aspectRatio: {
        default: null,
        renderHTML: (attributes) => {
          if (!attributes.aspectRatio) {
            return {};
          }
          return {
            style: `aspect-ratio: ${attributes.aspectRatio}`
          };
        },
        parseHTML: (element) => element.style.aspectRatio
      }
    };
  },
  renderHTML({ HTMLAttributes }) {
    return [
      "img",
      mergeAttributes(
        // Always render the `height="auto"` attribute by default, since we control the
        // width with resizing (and this maintains the image aspect ratio)
        {
          height: "auto"
        },
        this.options.HTMLAttributes,
        HTMLAttributes
      )
    ];
  },
  parseHTML() {
    return [
      {
        // This default tag-parsing rule is taken directly from the builtin Image
        // extension
        // (https://github.com/ueberdosis/tiptap/blob/4108e9f991522b5ac8f669ae2d24cfe9f91780ba/packages/extension-image/src/image.ts#L61-L69)
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])',
        /**
         * We add `getAttrs` here to include our own additional conditions for
         * parsing/matching images from input HTML (where returning false marks it as
         * not "matching", therefore ignoring it and not creating an Image node in
         * prosemirror). See https://tiptap.dev/guide/custom-extensions#parse-html
         */
        getAttrs: (node) => {
          if (!(node instanceof Element)) {
            return false;
          }
          const src = node.getAttribute("src");
          return this.options.isAllowedImgSrc(src) && null;
        }
      }
    ];
  },
  /**
   * By default, the Image extension supports markdown-like input rules for text entered
   * in the editor, such as the string "![wat](https://picsum.photos/600/400)". We'll
   * override the default implementation so that we can restrict which `src` values are
   * permitted.
   */
  addInputRules() {
    var _a;
    const parentInputRules = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.call(this);
    if (!parentInputRules) {
      return [];
    }
    const getAttributes2 = (match) => {
      const [, , alt, src, title] = match;
      return { src, alt, title };
    };
    return parentInputRules.map((rule) => new InputRule({
      find: rule.find,
      handler: (props) => {
        const attributes = getAttributes2(props.match);
        if (!this.options.isAllowedImgSrc(attributes.src)) {
          return;
        }
        return rule.handler(props);
      }
    }));
  },
  addNodeView() {
    return ReactNodeViewRenderer(ResizableImageComponent_default);
  }
});
var ResizableImage_default = ResizableImage;

// node_modules/prosemirror-tables/dist/index.js
var readFromCache;
var addToCache;
if (typeof WeakMap != "undefined") {
  let cache = /* @__PURE__ */ new WeakMap();
  readFromCache = (key) => cache.get(key);
  addToCache = (key, value) => {
    cache.set(key, value);
    return value;
  };
} else {
  const cache = [];
  const cacheSize = 10;
  let cachePos = 0;
  readFromCache = (key) => {
    for (let i2 = 0; i2 < cache.length; i2 += 2)
      if (cache[i2] == key) return cache[i2 + 1];
  };
  addToCache = (key, value) => {
    if (cachePos == cacheSize) cachePos = 0;
    cache[cachePos++] = key;
    return cache[cachePos++] = value;
  };
}
var TableMap = class {
  constructor(width, height, map, problems) {
    this.width = width;
    this.height = height;
    this.map = map;
    this.problems = problems;
  }
  // Find the dimensions of the cell at the given position.
  findCell(pos) {
    for (let i2 = 0; i2 < this.map.length; i2++) {
      const curPos = this.map[i2];
      if (curPos != pos) continue;
      const left = i2 % this.width;
      const top = i2 / this.width | 0;
      let right = left + 1;
      let bottom = top + 1;
      for (let j = 1; right < this.width && this.map[i2 + j] == curPos; j++) {
        right++;
      }
      for (let j = 1; bottom < this.height && this.map[i2 + this.width * j] == curPos; j++) {
        bottom++;
      }
      return { left, top, right, bottom };
    }
    throw new RangeError(`No cell with offset ${pos} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(pos) {
    for (let i2 = 0; i2 < this.map.length; i2++) {
      if (this.map[i2] == pos) {
        return i2 % this.width;
      }
    }
    throw new RangeError(`No cell with offset ${pos} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(pos, axis, dir) {
    const { left, right, top, bottom } = this.findCell(pos);
    if (axis == "horiz") {
      if (dir < 0 ? left == 0 : right == this.width) return null;
      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];
    } else {
      if (dir < 0 ? top == 0 : bottom == this.height) return null;
      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];
    }
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(a2, b2) {
    const {
      left: leftA,
      right: rightA,
      top: topA,
      bottom: bottomA
    } = this.findCell(a2);
    const {
      left: leftB,
      right: rightB,
      top: topB,
      bottom: bottomB
    } = this.findCell(b2);
    return {
      left: Math.min(leftA, leftB),
      top: Math.min(topA, topB),
      right: Math.max(rightA, rightB),
      bottom: Math.max(bottomA, bottomB)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(rect) {
    const result = [];
    const seen = {};
    for (let row = rect.top; row < rect.bottom; row++) {
      for (let col = rect.left; col < rect.right; col++) {
        const index = row * this.width + col;
        const pos = this.map[index];
        if (seen[pos]) continue;
        seen[pos] = true;
        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {
          continue;
        }
        result.push(pos);
      }
    }
    return result;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(row, col, table) {
    for (let i2 = 0, rowStart = 0; ; i2++) {
      const rowEnd = rowStart + table.child(i2).nodeSize;
      if (i2 == row) {
        let index = col + row * this.width;
        const rowEndIndex = (row + 1) * this.width;
        while (index < rowEndIndex && this.map[index] < rowStart) index++;
        return index == rowEndIndex ? rowEnd - 1 : this.map[index];
      }
      rowStart = rowEnd;
    }
  }
  // Find the table map for the given table node.
  static get(table) {
    return readFromCache(table) || addToCache(table, computeMap(table));
  }
};
function computeMap(table) {
  if (table.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + table.type.name);
  const width = findWidth(table), height = table.childCount;
  const map = [];
  let mapPos = 0;
  let problems = null;
  const colWidths = [];
  for (let i2 = 0, e2 = width * height; i2 < e2; i2++) map[i2] = 0;
  for (let row = 0, pos = 0; row < height; row++) {
    const rowNode = table.child(row);
    pos++;
    for (let i2 = 0; ; i2++) {
      while (mapPos < map.length && map[mapPos] != 0) mapPos++;
      if (i2 == rowNode.childCount) break;
      const cellNode = rowNode.child(i2);
      const { colspan, rowspan, colwidth } = cellNode.attrs;
      for (let h2 = 0; h2 < rowspan; h2++) {
        if (h2 + row >= height) {
          (problems || (problems = [])).push({
            type: "overlong_rowspan",
            pos,
            n: rowspan - h2
          });
          break;
        }
        const start = mapPos + h2 * width;
        for (let w2 = 0; w2 < colspan; w2++) {
          if (map[start + w2] == 0) map[start + w2] = pos;
          else
            (problems || (problems = [])).push({
              type: "collision",
              row,
              pos,
              n: colspan - w2
            });
          const colW = colwidth && colwidth[w2];
          if (colW) {
            const widthIndex = (start + w2) % width * 2, prev = colWidths[widthIndex];
            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {
              colWidths[widthIndex] = colW;
              colWidths[widthIndex + 1] = 1;
            } else if (prev == colW) {
              colWidths[widthIndex + 1]++;
            }
          }
        }
      }
      mapPos += colspan;
      pos += cellNode.nodeSize;
    }
    const expectedPos = (row + 1) * width;
    let missing = 0;
    while (mapPos < expectedPos) if (map[mapPos++] == 0) missing++;
    if (missing)
      (problems || (problems = [])).push({ type: "missing", row, n: missing });
    pos++;
  }
  if (width === 0 || height === 0)
    (problems || (problems = [])).push({ type: "zero_sized" });
  const tableMap = new TableMap(width, height, map, problems);
  let badWidths = false;
  for (let i2 = 0; !badWidths && i2 < colWidths.length; i2 += 2)
    if (colWidths[i2] != null && colWidths[i2 + 1] < height) badWidths = true;
  if (badWidths) findBadColWidths(tableMap, colWidths, table);
  return tableMap;
}
function findWidth(table) {
  let width = -1;
  let hasRowSpan = false;
  for (let row = 0; row < table.childCount; row++) {
    const rowNode = table.child(row);
    let rowWidth = 0;
    if (hasRowSpan)
      for (let j = 0; j < row; j++) {
        const prevRow = table.child(j);
        for (let i2 = 0; i2 < prevRow.childCount; i2++) {
          const cell = prevRow.child(i2);
          if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;
        }
      }
    for (let i2 = 0; i2 < rowNode.childCount; i2++) {
      const cell = rowNode.child(i2);
      rowWidth += cell.attrs.colspan;
      if (cell.attrs.rowspan > 1) hasRowSpan = true;
    }
    if (width == -1) width = rowWidth;
    else if (width != rowWidth) width = Math.max(width, rowWidth);
  }
  return width;
}
function findBadColWidths(map, colWidths, table) {
  if (!map.problems) map.problems = [];
  const seen = {};
  for (let i2 = 0; i2 < map.map.length; i2++) {
    const pos = map.map[i2];
    if (seen[pos]) continue;
    seen[pos] = true;
    const node = table.nodeAt(pos);
    if (!node) {
      throw new RangeError(`No cell with offset ${pos} found`);
    }
    let updated = null;
    const attrs = node.attrs;
    for (let j = 0; j < attrs.colspan; j++) {
      const col = (i2 + j) % map.width;
      const colWidth = colWidths[col * 2];
      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))
        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;
    }
    if (updated)
      map.problems.unshift({
        type: "colwidth mismatch",
        pos,
        colwidth: updated
      });
  }
}
function freshColWidth(attrs) {
  if (attrs.colwidth) return attrs.colwidth.slice();
  const result = [];
  for (let i2 = 0; i2 < attrs.colspan; i2++) result.push(0);
  return result;
}
function tableNodeTypes(schema) {
  let result = schema.cached.tableNodeTypes;
  if (!result) {
    result = schema.cached.tableNodeTypes = {};
    for (const name in schema.nodes) {
      const type = schema.nodes[name], role = type.spec.tableRole;
      if (role) result[role] = type;
    }
  }
  return result;
}
var tableEditingKey = new PluginKey("selectingCells");
function cellAround($pos) {
  for (let d2 = $pos.depth - 1; d2 > 0; d2--)
    if ($pos.node(d2).type.spec.tableRole == "row")
      return $pos.node(0).resolve($pos.before(d2 + 1));
  return null;
}
function cellWrapping($pos) {
  for (let d2 = $pos.depth; d2 > 0; d2--) {
    const role = $pos.node(d2).type.spec.tableRole;
    if (role === "cell" || role === "header_cell") return $pos.node(d2);
  }
  return null;
}
function isInTable(state) {
  const $head = state.selection.$head;
  for (let d2 = $head.depth; d2 > 0; d2--)
    if ($head.node(d2).type.spec.tableRole == "row") return true;
  return false;
}
function selectionCell(state) {
  const sel = state.selection;
  if ("$anchorCell" in sel && sel.$anchorCell) {
    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;
  } else if ("node" in sel && sel.node && sel.node.type.spec.tableRole == "cell") {
    return sel.$anchor;
  }
  const $cell = cellAround(sel.$head) || cellNear(sel.$head);
  if ($cell) {
    return $cell;
  }
  throw new RangeError(`No cell found around position ${sel.head}`);
}
function cellNear($pos) {
  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {
    const role = after.type.spec.tableRole;
    if (role == "cell" || role == "header_cell") return $pos.doc.resolve(pos);
  }
  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {
    const role = before.type.spec.tableRole;
    if (role == "cell" || role == "header_cell")
      return $pos.doc.resolve(pos - before.nodeSize);
  }
}
function pointsAtCell($pos) {
  return $pos.parent.type.spec.tableRole == "row" && !!$pos.nodeAfter;
}
function moveCellForward($pos) {
  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);
}
function inSameTable($cellA, $cellB) {
  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);
}
function nextCell($pos, axis, dir) {
  const table = $pos.node(-1);
  const map = TableMap.get(table);
  const tableStart = $pos.start(-1);
  const moved = map.nextCell($pos.pos - tableStart, axis, dir);
  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);
}
function removeColSpan(attrs, pos, n2 = 1) {
  const result = { ...attrs, colspan: attrs.colspan - n2 };
  if (result.colwidth) {
    result.colwidth = result.colwidth.slice();
    result.colwidth.splice(pos, n2);
    if (!result.colwidth.some((w2) => w2 > 0)) result.colwidth = null;
  }
  return result;
}
function addColSpan(attrs, pos, n2 = 1) {
  const result = { ...attrs, colspan: attrs.colspan + n2 };
  if (result.colwidth) {
    result.colwidth = result.colwidth.slice();
    for (let i2 = 0; i2 < n2; i2++) result.colwidth.splice(pos, 0, 0);
  }
  return result;
}
function columnIsHeader(map, table, col) {
  const headerCell = tableNodeTypes(table.type.schema).header_cell;
  for (let row = 0; row < map.height; row++)
    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)
      return false;
  return true;
}
var CellSelection = class _CellSelection extends Selection {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor($anchorCell, $headCell = $anchorCell) {
    const table = $anchorCell.node(-1);
    const map = TableMap.get(table);
    const tableStart = $anchorCell.start(-1);
    const rect = map.rectBetween(
      $anchorCell.pos - tableStart,
      $headCell.pos - tableStart
    );
    const doc = $anchorCell.node(0);
    const cells = map.cellsInRect(rect).filter((p2) => p2 != $headCell.pos - tableStart);
    cells.unshift($headCell.pos - tableStart);
    const ranges = cells.map((pos) => {
      const cell = table.nodeAt(pos);
      if (!cell) {
        throw RangeError(`No cell with offset ${pos} found`);
      }
      const from = tableStart + pos + 1;
      return new SelectionRange(
        doc.resolve(from),
        doc.resolve(from + cell.content.size)
      );
    });
    super(ranges[0].$from, ranges[0].$to, ranges);
    this.$anchorCell = $anchorCell;
    this.$headCell = $headCell;
  }
  map(doc, mapping) {
    const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));
    const $headCell = doc.resolve(mapping.map(this.$headCell.pos));
    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {
      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);
      if (tableChanged && this.isRowSelection())
        return _CellSelection.rowSelection($anchorCell, $headCell);
      else if (tableChanged && this.isColSelection())
        return _CellSelection.colSelection($anchorCell, $headCell);
      else return new _CellSelection($anchorCell, $headCell);
    }
    return TextSelection.between($anchorCell, $headCell);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const table = this.$anchorCell.node(-1);
    const map = TableMap.get(table);
    const tableStart = this.$anchorCell.start(-1);
    const rect = map.rectBetween(
      this.$anchorCell.pos - tableStart,
      this.$headCell.pos - tableStart
    );
    const seen = {};
    const rows = [];
    for (let row = rect.top; row < rect.bottom; row++) {
      const rowContent = [];
      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {
        const pos = map.map[index];
        if (seen[pos]) continue;
        seen[pos] = true;
        const cellRect = map.findCell(pos);
        let cell = table.nodeAt(pos);
        if (!cell) {
          throw RangeError(`No cell with offset ${pos} found`);
        }
        const extraLeft = rect.left - cellRect.left;
        const extraRight = cellRect.right - rect.right;
        if (extraLeft > 0 || extraRight > 0) {
          let attrs = cell.attrs;
          if (extraLeft > 0) {
            attrs = removeColSpan(attrs, 0, extraLeft);
          }
          if (extraRight > 0) {
            attrs = removeColSpan(
              attrs,
              attrs.colspan - extraRight,
              extraRight
            );
          }
          if (cellRect.left < rect.left) {
            cell = cell.type.createAndFill(attrs);
            if (!cell) {
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(attrs)}`
              );
            }
          } else {
            cell = cell.type.create(attrs, cell.content);
          }
        }
        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {
          const attrs = {
            ...cell.attrs,
            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)
          };
          if (cellRect.top < rect.top) {
            cell = cell.type.createAndFill(attrs);
          } else {
            cell = cell.type.create(attrs, cell.content);
          }
        }
        rowContent.push(cell);
      }
      rows.push(table.child(row).copy(Fragment.from(rowContent)));
    }
    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;
    return new Slice(Fragment.from(fragment), 1, 1);
  }
  replace(tr, content = Slice.empty) {
    const mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i2 = 0; i2 < ranges.length; i2++) {
      const { $from, $to } = ranges[i2], mapping = tr.mapping.slice(mapFrom);
      tr.replace(
        mapping.map($from.pos),
        mapping.map($to.pos),
        i2 ? Slice.empty : content
      );
    }
    const sel = Selection.findFrom(
      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),
      -1
    );
    if (sel) tr.setSelection(sel);
  }
  replaceWith(tr, node) {
    this.replace(tr, new Slice(Fragment.from(node), 0, 0));
  }
  forEachCell(f2) {
    const table = this.$anchorCell.node(-1);
    const map = TableMap.get(table);
    const tableStart = this.$anchorCell.start(-1);
    const cells = map.cellsInRect(
      map.rectBetween(
        this.$anchorCell.pos - tableStart,
        this.$headCell.pos - tableStart
      )
    );
    for (let i2 = 0; i2 < cells.length; i2++) {
      f2(table.nodeAt(cells[i2]), tableStart + cells[i2]);
    }
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const anchorTop = this.$anchorCell.index(-1);
    const headTop = this.$headCell.index(-1);
    if (Math.min(anchorTop, headTop) > 0) return false;
    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;
    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection($anchorCell, $headCell = $anchorCell) {
    const table = $anchorCell.node(-1);
    const map = TableMap.get(table);
    const tableStart = $anchorCell.start(-1);
    const anchorRect = map.findCell($anchorCell.pos - tableStart);
    const headRect = map.findCell($headCell.pos - tableStart);
    const doc = $anchorCell.node(0);
    if (anchorRect.top <= headRect.top) {
      if (anchorRect.top > 0)
        $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);
      if (headRect.bottom < map.height)
        $headCell = doc.resolve(
          tableStart + map.map[map.width * (map.height - 1) + headRect.right - 1]
        );
    } else {
      if (headRect.top > 0)
        $headCell = doc.resolve(tableStart + map.map[headRect.left]);
      if (anchorRect.bottom < map.height)
        $anchorCell = doc.resolve(
          tableStart + map.map[map.width * (map.height - 1) + anchorRect.right - 1]
        );
    }
    return new _CellSelection($anchorCell, $headCell);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const table = this.$anchorCell.node(-1);
    const map = TableMap.get(table);
    const tableStart = this.$anchorCell.start(-1);
    const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);
    const headLeft = map.colCount(this.$headCell.pos - tableStart);
    if (Math.min(anchorLeft, headLeft) > 0) return false;
    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;
    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(anchorRight, headRight) == map.width;
  }
  eq(other) {
    return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection($anchorCell, $headCell = $anchorCell) {
    const table = $anchorCell.node(-1);
    const map = TableMap.get(table);
    const tableStart = $anchorCell.start(-1);
    const anchorRect = map.findCell($anchorCell.pos - tableStart);
    const headRect = map.findCell($headCell.pos - tableStart);
    const doc = $anchorCell.node(0);
    if (anchorRect.left <= headRect.left) {
      if (anchorRect.left > 0)
        $anchorCell = doc.resolve(
          tableStart + map.map[anchorRect.top * map.width]
        );
      if (headRect.right < map.width)
        $headCell = doc.resolve(
          tableStart + map.map[map.width * (headRect.top + 1) - 1]
        );
    } else {
      if (headRect.left > 0)
        $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);
      if (anchorRect.right < map.width)
        $anchorCell = doc.resolve(
          tableStart + map.map[map.width * (anchorRect.top + 1) - 1]
        );
    }
    return new _CellSelection($anchorCell, $headCell);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(doc, json) {
    return new _CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));
  }
  static create(doc, anchorCell, headCell = anchorCell) {
    return new _CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));
  }
  getBookmark() {
    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);
  }
};
CellSelection.prototype.visible = false;
Selection.jsonID("cell", CellSelection);
var CellBookmark = class _CellBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc) {
    const $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);
    if ($anchorCell.parent.type.spec.tableRole == "row" && $headCell.parent.type.spec.tableRole == "row" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))
      return new CellSelection($anchorCell, $headCell);
    else return Selection.near($headCell, 1);
  }
};
function drawCellSelection(state) {
  if (!(state.selection instanceof CellSelection)) return null;
  const cells = [];
  state.selection.forEachCell((node, pos) => {
    cells.push(
      Decoration.node(pos, pos + node.nodeSize, { class: "selectedCell" })
    );
  });
  return DecorationSet.create(state.doc, cells);
}
function isCellBoundarySelection({ $from, $to }) {
  if ($from.pos == $to.pos || $from.pos < $to.pos - 6) return false;
  let afterFrom = $from.pos;
  let beforeTo = $to.pos;
  let depth = $from.depth;
  for (; depth >= 0; depth--, afterFrom++)
    if ($from.after(depth + 1) < $from.end(depth)) break;
  for (let d2 = $to.depth; d2 >= 0; d2--, beforeTo--)
    if ($to.before(d2 + 1) > $to.start(d2)) break;
  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);
}
function isTextSelectionAcrossCells({ $from, $to }) {
  let fromCellBoundaryNode;
  let toCellBoundaryNode;
  for (let i2 = $from.depth; i2 > 0; i2--) {
    const node = $from.node(i2);
    if (node.type.spec.tableRole === "cell" || node.type.spec.tableRole === "header_cell") {
      fromCellBoundaryNode = node;
      break;
    }
  }
  for (let i2 = $to.depth; i2 > 0; i2--) {
    const node = $to.node(i2);
    if (node.type.spec.tableRole === "cell" || node.type.spec.tableRole === "header_cell") {
      toCellBoundaryNode = node;
      break;
    }
  }
  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;
}
function normalizeSelection(state, tr, allowTableNodeSelection) {
  const sel = (tr || state).selection;
  const doc = (tr || state).doc;
  let normalize;
  let role;
  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {
    if (role == "cell" || role == "header_cell") {
      normalize = CellSelection.create(doc, sel.from);
    } else if (role == "row") {
      const $cell = doc.resolve(sel.from + 1);
      normalize = CellSelection.rowSelection($cell, $cell);
    } else if (!allowTableNodeSelection) {
      const map = TableMap.get(sel.node);
      const start = sel.from + 1;
      const lastCell = start + map.map[map.width * map.height - 1];
      normalize = CellSelection.create(doc, start + 1, lastCell);
    }
  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {
    normalize = TextSelection.create(doc, sel.from);
  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {
    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());
  }
  if (normalize) (tr || (tr = state.tr)).setSelection(normalize);
  return tr;
}
var fixTablesKey = new PluginKey("fix-tables");
function changedDescendants(old, cur, offset, f2) {
  const oldSize = old.childCount, curSize = cur.childCount;
  outer: for (let i2 = 0, j = 0; i2 < curSize; i2++) {
    const child = cur.child(i2);
    for (let scan = j, e2 = Math.min(oldSize, i2 + 3); scan < e2; scan++) {
      if (old.child(scan) == child) {
        j = scan + 1;
        offset += child.nodeSize;
        continue outer;
      }
    }
    f2(child, offset);
    if (j < oldSize && old.child(j).sameMarkup(child))
      changedDescendants(old.child(j), child, offset + 1, f2);
    else child.nodesBetween(0, child.content.size, f2, offset + 1);
    offset += child.nodeSize;
  }
}
function fixTables(state, oldState) {
  let tr;
  const check = (node, pos) => {
    if (node.type.spec.tableRole == "table")
      tr = fixTable(state, node, pos, tr);
  };
  if (!oldState) state.doc.descendants(check);
  else if (oldState.doc != state.doc)
    changedDescendants(oldState.doc, state.doc, 0, check);
  return tr;
}
function fixTable(state, table, tablePos, tr) {
  const map = TableMap.get(table);
  if (!map.problems) return tr;
  if (!tr) tr = state.tr;
  const mustAdd = [];
  for (let i2 = 0; i2 < map.height; i2++) mustAdd.push(0);
  for (let i2 = 0; i2 < map.problems.length; i2++) {
    const prob = map.problems[i2];
    if (prob.type == "collision") {
      const cell = table.nodeAt(prob.pos);
      if (!cell) continue;
      const attrs = cell.attrs;
      for (let j = 0; j < attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n;
      tr.setNodeMarkup(
        tr.mapping.map(tablePos + 1 + prob.pos),
        null,
        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)
      );
    } else if (prob.type == "missing") {
      mustAdd[prob.row] += prob.n;
    } else if (prob.type == "overlong_rowspan") {
      const cell = table.nodeAt(prob.pos);
      if (!cell) continue;
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {
        ...cell.attrs,
        rowspan: cell.attrs.rowspan - prob.n
      });
    } else if (prob.type == "colwidth mismatch") {
      const cell = table.nodeAt(prob.pos);
      if (!cell) continue;
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {
        ...cell.attrs,
        colwidth: prob.colwidth
      });
    } else if (prob.type == "zero_sized") {
      const pos = tr.mapping.map(tablePos);
      tr.delete(pos, pos + table.nodeSize);
    }
  }
  let first, last;
  for (let i2 = 0; i2 < mustAdd.length; i2++)
    if (mustAdd[i2]) {
      if (first == null) first = i2;
      last = i2;
    }
  for (let i2 = 0, pos = tablePos + 1; i2 < map.height; i2++) {
    const row = table.child(i2);
    const end = pos + row.nodeSize;
    const add = mustAdd[i2];
    if (add > 0) {
      let role = "cell";
      if (row.firstChild) {
        role = row.firstChild.type.spec.tableRole;
      }
      const nodes = [];
      for (let j = 0; j < add; j++) {
        const node = tableNodeTypes(state.schema)[role].createAndFill();
        if (node) nodes.push(node);
      }
      const side = (i2 == 0 || first == i2 - 1) && last == i2 ? pos + 1 : end - 1;
      tr.insert(tr.mapping.map(side), nodes);
    }
    pos = end;
  }
  return tr.setMeta(fixTablesKey, { fixTables: true });
}
function selectedRect(state) {
  const sel = state.selection;
  const $pos = selectionCell(state);
  const table = $pos.node(-1);
  const tableStart = $pos.start(-1);
  const map = TableMap.get(table);
  const rect = sel instanceof CellSelection ? map.rectBetween(
    sel.$anchorCell.pos - tableStart,
    sel.$headCell.pos - tableStart
  ) : map.findCell($pos.pos - tableStart);
  return { ...rect, tableStart, map, table };
}
function addColumn(tr, { map, tableStart, table }, col) {
  let refColumn = col > 0 ? -1 : 0;
  if (columnIsHeader(map, table, col + refColumn)) {
    refColumn = col == 0 || col == map.width ? null : 0;
  }
  for (let row = 0; row < map.height; row++) {
    const index = row * map.width + col;
    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {
      const pos = map.map[index];
      const cell = table.nodeAt(pos);
      tr.setNodeMarkup(
        tr.mapping.map(tableStart + pos),
        null,
        addColSpan(cell.attrs, col - map.colCount(pos))
      );
      row += cell.attrs.rowspan - 1;
    } else {
      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;
      const pos = map.positionAt(row, col, table);
      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());
    }
  }
  return tr;
}
function addColumnBefore(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addColumn(state.tr, rect, rect.left));
  }
  return true;
}
function addColumnAfter(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addColumn(state.tr, rect, rect.right));
  }
  return true;
}
function removeColumn(tr, { map, table, tableStart }, col) {
  const mapStart = tr.mapping.maps.length;
  for (let row = 0; row < map.height; ) {
    const index = row * map.width + col;
    const pos = map.map[index];
    const cell = table.nodeAt(pos);
    const attrs = cell.attrs;
    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {
      tr.setNodeMarkup(
        tr.mapping.slice(mapStart).map(tableStart + pos),
        null,
        removeColSpan(attrs, col - map.colCount(pos))
      );
    } else {
      const start = tr.mapping.slice(mapStart).map(tableStart + pos);
      tr.delete(start, start + cell.nodeSize);
    }
    row += attrs.rowspan;
  }
}
function deleteColumn(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    const tr = state.tr;
    if (rect.left == 0 && rect.right == rect.map.width) return false;
    for (let i2 = rect.right - 1; ; i2--) {
      removeColumn(tr, rect, i2);
      if (i2 == rect.left) break;
      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
      if (!table) {
        throw RangeError("No table found");
      }
      rect.table = table;
      rect.map = TableMap.get(table);
    }
    dispatch(tr);
  }
  return true;
}
function rowIsHeader(map, table, row) {
  var _a;
  const headerCell = tableNodeTypes(table.type.schema).header_cell;
  for (let col = 0; col < map.width; col++)
    if (((_a = table.nodeAt(map.map[col + row * map.width])) == null ? void 0 : _a.type) != headerCell)
      return false;
  return true;
}
function addRow(tr, { map, tableStart, table }, row) {
  var _a;
  let rowPos = tableStart;
  for (let i2 = 0; i2 < row; i2++) rowPos += table.child(i2).nodeSize;
  const cells = [];
  let refRow = row > 0 ? -1 : 0;
  if (rowIsHeader(map, table, row + refRow))
    refRow = row == 0 || row == map.height ? null : 0;
  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {
    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {
      const pos = map.map[index];
      const attrs = table.nodeAt(pos).attrs;
      tr.setNodeMarkup(tableStart + pos, null, {
        ...attrs,
        rowspan: attrs.rowspan + 1
      });
      col += attrs.colspan - 1;
    } else {
      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map.map[index + refRow * map.width])) == null ? void 0 : _a.type;
      const node = type == null ? void 0 : type.createAndFill();
      if (node) cells.push(node);
    }
  }
  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));
  return tr;
}
function addRowBefore(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addRow(state.tr, rect, rect.top));
  }
  return true;
}
function addRowAfter(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addRow(state.tr, rect, rect.bottom));
  }
  return true;
}
function removeRow(tr, { map, table, tableStart }, row) {
  let rowPos = 0;
  for (let i2 = 0; i2 < row; i2++) rowPos += table.child(i2).nodeSize;
  const nextRow = rowPos + table.child(row).nodeSize;
  const mapFrom = tr.mapping.maps.length;
  tr.delete(rowPos + tableStart, nextRow + tableStart);
  const seen = /* @__PURE__ */ new Set();
  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {
    const pos = map.map[index];
    if (seen.has(pos)) continue;
    seen.add(pos);
    if (row > 0 && pos == map.map[index - map.width]) {
      const attrs = table.nodeAt(pos).attrs;
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {
        ...attrs,
        rowspan: attrs.rowspan - 1
      });
      col += attrs.colspan - 1;
    } else if (row < map.height && pos == map.map[index + map.width]) {
      const cell = table.nodeAt(pos);
      const attrs = cell.attrs;
      const copy = cell.type.create(
        { ...attrs, rowspan: cell.attrs.rowspan - 1 },
        cell.content
      );
      const newPos = map.positionAt(row + 1, col, table);
      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);
      col += attrs.colspan - 1;
    }
  }
}
function deleteRow(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state), tr = state.tr;
    if (rect.top == 0 && rect.bottom == rect.map.height) return false;
    for (let i2 = rect.bottom - 1; ; i2--) {
      removeRow(tr, rect, i2);
      if (i2 == rect.top) break;
      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
      if (!table) {
        throw RangeError("No table found");
      }
      rect.table = table;
      rect.map = TableMap.get(rect.table);
    }
    dispatch(tr);
  }
  return true;
}
function isEmpty(cell) {
  const c2 = cell.content;
  return c2.childCount == 1 && c2.child(0).isTextblock && c2.child(0).childCount == 0;
}
function cellsOverlapRectangle({ width, height, map }, rect) {
  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;
  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);
  for (let i2 = rect.top; i2 < rect.bottom; i2++) {
    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1])
      return true;
    indexLeft += width;
    indexRight += width;
  }
  for (let i2 = rect.left; i2 < rect.right; i2++) {
    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width])
      return true;
    indexTop++;
    indexBottom++;
  }
  return false;
}
function mergeCells(state, dispatch) {
  const sel = state.selection;
  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)
    return false;
  const rect = selectedRect(state), { map } = rect;
  if (cellsOverlapRectangle(map, rect)) return false;
  if (dispatch) {
    const tr = state.tr;
    const seen = {};
    let content = Fragment.empty;
    let mergedPos;
    let mergedCell;
    for (let row = rect.top; row < rect.bottom; row++) {
      for (let col = rect.left; col < rect.right; col++) {
        const cellPos = map.map[row * map.width + col];
        const cell = rect.table.nodeAt(cellPos);
        if (seen[cellPos] || !cell) continue;
        seen[cellPos] = true;
        if (mergedPos == null) {
          mergedPos = cellPos;
          mergedCell = cell;
        } else {
          if (!isEmpty(cell)) content = content.append(cell.content);
          const mapped = tr.mapping.map(cellPos + rect.tableStart);
          tr.delete(mapped, mapped + cell.nodeSize);
        }
      }
    }
    if (mergedPos == null || mergedCell == null) {
      return true;
    }
    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {
      ...addColSpan(
        mergedCell.attrs,
        mergedCell.attrs.colspan,
        rect.right - rect.left - mergedCell.attrs.colspan
      ),
      rowspan: rect.bottom - rect.top
    });
    if (content.size) {
      const end = mergedPos + 1 + mergedCell.content.size;
      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;
      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);
    }
    tr.setSelection(
      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart))
    );
    dispatch(tr);
  }
  return true;
}
function splitCell(state, dispatch) {
  const nodeTypes = tableNodeTypes(state.schema);
  return splitCellWithType(({ node }) => {
    return nodeTypes[node.type.spec.tableRole];
  })(state, dispatch);
}
function splitCellWithType(getCellType) {
  return (state, dispatch) => {
    var _a;
    const sel = state.selection;
    let cellNode;
    let cellPos;
    if (!(sel instanceof CellSelection)) {
      cellNode = cellWrapping(sel.$from);
      if (!cellNode) return false;
      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;
    } else {
      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;
      cellNode = sel.$anchorCell.nodeAfter;
      cellPos = sel.$anchorCell.pos;
    }
    if (cellNode == null || cellPos == null) {
      return false;
    }
    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {
      return false;
    }
    if (dispatch) {
      let baseAttrs = cellNode.attrs;
      const attrs = [];
      const colwidth = baseAttrs.colwidth;
      if (baseAttrs.rowspan > 1) baseAttrs = { ...baseAttrs, rowspan: 1 };
      if (baseAttrs.colspan > 1) baseAttrs = { ...baseAttrs, colspan: 1 };
      const rect = selectedRect(state), tr = state.tr;
      for (let i2 = 0; i2 < rect.right - rect.left; i2++)
        attrs.push(
          colwidth ? {
            ...baseAttrs,
            colwidth: colwidth && colwidth[i2] ? [colwidth[i2]] : null
          } : baseAttrs
        );
      let lastCell;
      for (let row = rect.top; row < rect.bottom; row++) {
        let pos = rect.map.positionAt(row, rect.left, rect.table);
        if (row == rect.top) pos += cellNode.nodeSize;
        for (let col = rect.left, i2 = 0; col < rect.right; col++, i2++) {
          if (col == rect.left && row == rect.top) continue;
          tr.insert(
            lastCell = tr.mapping.map(pos + rect.tableStart, 1),
            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i2])
          );
        }
      }
      tr.setNodeMarkup(
        cellPos,
        getCellType({ node: cellNode, row: rect.top, col: rect.left }),
        attrs[0]
      );
      if (sel instanceof CellSelection)
        tr.setSelection(
          new CellSelection(
            tr.doc.resolve(sel.$anchorCell.pos),
            lastCell ? tr.doc.resolve(lastCell) : void 0
          )
        );
      dispatch(tr);
    }
    return true;
  };
}
function setCellAttr(name, value) {
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    const $cell = selectionCell(state);
    if ($cell.nodeAfter.attrs[name] === value) return false;
    if (dispatch) {
      const tr = state.tr;
      if (state.selection instanceof CellSelection)
        state.selection.forEachCell((node, pos) => {
          if (node.attrs[name] !== value)
            tr.setNodeMarkup(pos, null, {
              ...node.attrs,
              [name]: value
            });
        });
      else
        tr.setNodeMarkup($cell.pos, null, {
          ...$cell.nodeAfter.attrs,
          [name]: value
        });
      dispatch(tr);
    }
    return true;
  };
}
function deprecated_toggleHeader(type) {
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    if (dispatch) {
      const types = tableNodeTypes(state.schema);
      const rect = selectedRect(state), tr = state.tr;
      const cells = rect.map.cellsInRect(
        type == "column" ? {
          left: rect.left,
          top: 0,
          right: rect.right,
          bottom: rect.map.height
        } : type == "row" ? {
          left: 0,
          top: rect.top,
          right: rect.map.width,
          bottom: rect.bottom
        } : rect
      );
      const nodes = cells.map((pos) => rect.table.nodeAt(pos));
      for (let i2 = 0; i2 < cells.length; i2++)
        if (nodes[i2].type == types.header_cell)
          tr.setNodeMarkup(
            rect.tableStart + cells[i2],
            types.cell,
            nodes[i2].attrs
          );
      if (tr.steps.length == 0)
        for (let i2 = 0; i2 < cells.length; i2++)
          tr.setNodeMarkup(
            rect.tableStart + cells[i2],
            types.header_cell,
            nodes[i2].attrs
          );
      dispatch(tr);
    }
    return true;
  };
}
function isHeaderEnabledByType(type, rect, types) {
  const cellPositions = rect.map.cellsInRect({
    left: 0,
    top: 0,
    right: type == "row" ? rect.map.width : 1,
    bottom: type == "column" ? rect.map.height : 1
  });
  for (let i2 = 0; i2 < cellPositions.length; i2++) {
    const cell = rect.table.nodeAt(cellPositions[i2]);
    if (cell && cell.type !== types.header_cell) {
      return false;
    }
  }
  return true;
}
function toggleHeader(type, options) {
  options = options || { useDeprecatedLogic: false };
  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    if (dispatch) {
      const types = tableNodeTypes(state.schema);
      const rect = selectedRect(state), tr = state.tr;
      const isHeaderRowEnabled = isHeaderEnabledByType("row", rect, types);
      const isHeaderColumnEnabled = isHeaderEnabledByType(
        "column",
        rect,
        types
      );
      const isHeaderEnabled = type === "column" ? isHeaderRowEnabled : type === "row" ? isHeaderColumnEnabled : false;
      const selectionStartsAt = isHeaderEnabled ? 1 : 0;
      const cellsRect = type == "column" ? {
        left: 0,
        top: selectionStartsAt,
        right: 1,
        bottom: rect.map.height
      } : type == "row" ? {
        left: selectionStartsAt,
        top: 0,
        right: rect.map.width,
        bottom: 1
      } : rect;
      const newType = type == "column" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == "row" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;
      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {
        const cellPos = relativeCellPos + rect.tableStart;
        const cell = tr.doc.nodeAt(cellPos);
        if (cell) {
          tr.setNodeMarkup(cellPos, newType, cell.attrs);
        }
      });
      dispatch(tr);
    }
    return true;
  };
}
var toggleHeaderRow = toggleHeader("row", {
  useDeprecatedLogic: true
});
var toggleHeaderColumn = toggleHeader("column", {
  useDeprecatedLogic: true
});
var toggleHeaderCell = toggleHeader("cell", {
  useDeprecatedLogic: true
});
function findNextCell($cell, dir) {
  if (dir < 0) {
    const before = $cell.nodeBefore;
    if (before) return $cell.pos - before.nodeSize;
    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {
      const rowNode = $cell.node(-1).child(row);
      const lastChild = rowNode.lastChild;
      if (lastChild) {
        return rowEnd - 1 - lastChild.nodeSize;
      }
      rowEnd -= rowNode.nodeSize;
    }
  } else {
    if ($cell.index() < $cell.parent.childCount - 1) {
      return $cell.pos + $cell.nodeAfter.nodeSize;
    }
    const table = $cell.node(-1);
    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {
      const rowNode = table.child(row);
      if (rowNode.childCount) return rowStart + 1;
      rowStart += rowNode.nodeSize;
    }
  }
  return null;
}
function goToNextCell(direction) {
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    const cell = findNextCell(selectionCell(state), direction);
    if (cell == null) return false;
    if (dispatch) {
      const $cell = state.doc.resolve(cell);
      dispatch(
        state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView()
      );
    }
    return true;
  };
}
function deleteTable(state, dispatch) {
  const $pos = state.selection.$anchor;
  for (let d2 = $pos.depth; d2 > 0; d2--) {
    const node = $pos.node(d2);
    if (node.type.spec.tableRole == "table") {
      if (dispatch)
        dispatch(
          state.tr.delete($pos.before(d2), $pos.after(d2)).scrollIntoView()
        );
      return true;
    }
  }
  return false;
}
function deleteCellSelection(state, dispatch) {
  const sel = state.selection;
  if (!(sel instanceof CellSelection)) return false;
  if (dispatch) {
    const tr = state.tr;
    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;
    sel.forEachCell((cell, pos) => {
      if (!cell.content.eq(baseContent))
        tr.replace(
          tr.mapping.map(pos + 1),
          tr.mapping.map(pos + cell.nodeSize - 1),
          new Slice(baseContent, 0, 0)
        );
    });
    if (tr.docChanged) dispatch(tr);
  }
  return true;
}
function pastedCells(slice) {
  if (!slice.size) return null;
  let { content, openStart, openEnd } = slice;
  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == "table")) {
    openStart--;
    openEnd--;
    content = content.child(0).content;
  }
  const first = content.child(0);
  const role = first.type.spec.tableRole;
  const schema = first.type.schema, rows = [];
  if (role == "row") {
    for (let i2 = 0; i2 < content.childCount; i2++) {
      let cells = content.child(i2).content;
      const left = i2 ? 0 : Math.max(0, openStart - 1);
      const right = i2 < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);
      if (left || right)
        cells = fitSlice(
          tableNodeTypes(schema).row,
          new Slice(cells, left, right)
        ).content;
      rows.push(cells);
    }
  } else if (role == "cell" || role == "header_cell") {
    rows.push(
      openStart || openEnd ? fitSlice(
        tableNodeTypes(schema).row,
        new Slice(content, openStart, openEnd)
      ).content : content
    );
  } else {
    return null;
  }
  return ensureRectangular(schema, rows);
}
function ensureRectangular(schema, rows) {
  const widths = [];
  for (let i2 = 0; i2 < rows.length; i2++) {
    const row = rows[i2];
    for (let j = row.childCount - 1; j >= 0; j--) {
      const { rowspan, colspan } = row.child(j).attrs;
      for (let r2 = i2; r2 < i2 + rowspan; r2++)
        widths[r2] = (widths[r2] || 0) + colspan;
    }
  }
  let width = 0;
  for (let r2 = 0; r2 < widths.length; r2++) width = Math.max(width, widths[r2]);
  for (let r2 = 0; r2 < widths.length; r2++) {
    if (r2 >= rows.length) rows.push(Fragment.empty);
    if (widths[r2] < width) {
      const empty = tableNodeTypes(schema).cell.createAndFill();
      const cells = [];
      for (let i2 = widths[r2]; i2 < width; i2++) {
        cells.push(empty);
      }
      rows[r2] = rows[r2].append(Fragment.from(cells));
    }
  }
  return { height: rows.length, width, rows };
}
function fitSlice(nodeType, slice) {
  const node = nodeType.createAndFill();
  const tr = new Transform(node).replace(0, node.content.size, slice);
  return tr.doc;
}
function clipCells({ width, height, rows }, newWidth, newHeight) {
  if (width != newWidth) {
    const added = [];
    const newRows = [];
    for (let row = 0; row < rows.length; row++) {
      const frag = rows[row], cells = [];
      for (let col = added[row] || 0, i2 = 0; col < newWidth; i2++) {
        let cell = frag.child(i2 % frag.childCount);
        if (col + cell.attrs.colspan > newWidth)
          cell = cell.type.createChecked(
            removeColSpan(
              cell.attrs,
              cell.attrs.colspan,
              col + cell.attrs.colspan - newWidth
            ),
            cell.content
          );
        cells.push(cell);
        col += cell.attrs.colspan;
        for (let j = 1; j < cell.attrs.rowspan; j++)
          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;
      }
      newRows.push(Fragment.from(cells));
    }
    rows = newRows;
    width = newWidth;
  }
  if (height != newHeight) {
    const newRows = [];
    for (let row = 0, i2 = 0; row < newHeight; row++, i2++) {
      const cells = [], source = rows[i2 % height];
      for (let j = 0; j < source.childCount; j++) {
        let cell = source.child(j);
        if (row + cell.attrs.rowspan > newHeight)
          cell = cell.type.create(
            {
              ...cell.attrs,
              rowspan: Math.max(1, newHeight - cell.attrs.rowspan)
            },
            cell.content
          );
        cells.push(cell);
      }
      newRows.push(Fragment.from(cells));
    }
    rows = newRows;
    height = newHeight;
  }
  return { width, height, rows };
}
function growTable(tr, map, table, start, width, height, mapFrom) {
  const schema = tr.doc.type.schema;
  const types = tableNodeTypes(schema);
  let empty;
  let emptyHead;
  if (width > map.width) {
    for (let row = 0, rowEnd = 0; row < map.height; row++) {
      const rowNode = table.child(row);
      rowEnd += rowNode.nodeSize;
      const cells = [];
      let add;
      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)
        add = empty || (empty = types.cell.createAndFill());
      else add = emptyHead || (emptyHead = types.header_cell.createAndFill());
      for (let i2 = map.width; i2 < width; i2++) cells.push(add);
      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);
    }
  }
  if (height > map.height) {
    const cells = [];
    for (let i2 = 0, start2 = (map.height - 1) * map.width; i2 < Math.max(map.width, width); i2++) {
      const header = i2 >= map.width ? false : table.nodeAt(map.map[start2 + i2]).type == types.header_cell;
      cells.push(
        header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill())
      );
    }
    const emptyRow = types.row.create(null, Fragment.from(cells)), rows = [];
    for (let i2 = map.height; i2 < height; i2++) rows.push(emptyRow);
    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);
  }
  return !!(empty || emptyHead);
}
function isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {
  if (top == 0 || top == map.height) return false;
  let found = false;
  for (let col = left; col < right; col++) {
    const index = top * map.width + col, pos = map.map[index];
    if (map.map[index - map.width] == pos) {
      found = true;
      const cell = table.nodeAt(pos);
      const { top: cellTop, left: cellLeft } = map.findCell(pos);
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {
        ...cell.attrs,
        rowspan: top - cellTop
      });
      tr.insert(
        tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),
        cell.type.createAndFill({
          ...cell.attrs,
          rowspan: cellTop + cell.attrs.rowspan - top
        })
      );
      col += cell.attrs.colspan - 1;
    }
  }
  return found;
}
function isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {
  if (left == 0 || left == map.width) return false;
  let found = false;
  for (let row = top; row < bottom; row++) {
    const index = row * map.width + left, pos = map.map[index];
    if (map.map[index - 1] == pos) {
      found = true;
      const cell = table.nodeAt(pos);
      const cellLeft = map.colCount(pos);
      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);
      tr.setNodeMarkup(
        updatePos,
        null,
        removeColSpan(
          cell.attrs,
          left - cellLeft,
          cell.attrs.colspan - (left - cellLeft)
        )
      );
      tr.insert(
        updatePos + cell.nodeSize,
        cell.type.createAndFill(
          removeColSpan(cell.attrs, 0, left - cellLeft)
        )
      );
      row += cell.attrs.rowspan - 1;
    }
  }
  return found;
}
function insertCells(state, dispatch, tableStart, rect, cells) {
  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;
  if (!table) {
    throw new Error("No table found");
  }
  let map = TableMap.get(table);
  const { top, left } = rect;
  const right = left + cells.width, bottom = top + cells.height;
  const tr = state.tr;
  let mapFrom = 0;
  function recomp() {
    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;
    if (!table) {
      throw new Error("No table found");
    }
    map = TableMap.get(table);
    mapFrom = tr.mapping.maps.length;
  }
  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp();
  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom))
    recomp();
  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom))
    recomp();
  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom))
    recomp();
  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom))
    recomp();
  for (let row = top; row < bottom; row++) {
    const from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);
    tr.replace(
      tr.mapping.slice(mapFrom).map(from + tableStart),
      tr.mapping.slice(mapFrom).map(to + tableStart),
      new Slice(cells.rows[row - top], 0, 0)
    );
  }
  recomp();
  tr.setSelection(
    new CellSelection(
      tr.doc.resolve(tableStart + map.positionAt(top, left, table)),
      tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))
    )
  );
  dispatch(tr);
}
var handleKeyDown = keydownHandler({
  ArrowLeft: arrow("horiz", -1),
  ArrowRight: arrow("horiz", 1),
  ArrowUp: arrow("vert", -1),
  ArrowDown: arrow("vert", 1),
  "Shift-ArrowLeft": shiftArrow("horiz", -1),
  "Shift-ArrowRight": shiftArrow("horiz", 1),
  "Shift-ArrowUp": shiftArrow("vert", -1),
  "Shift-ArrowDown": shiftArrow("vert", 1),
  Backspace: deleteCellSelection,
  "Mod-Backspace": deleteCellSelection,
  Delete: deleteCellSelection,
  "Mod-Delete": deleteCellSelection
});
function maybeSetSelection(state, dispatch, selection) {
  if (selection.eq(state.selection)) return false;
  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());
  return true;
}
function arrow(axis, dir) {
  return (state, dispatch, view) => {
    if (!view) return false;
    const sel = state.selection;
    if (sel instanceof CellSelection) {
      return maybeSetSelection(
        state,
        dispatch,
        Selection.near(sel.$headCell, dir)
      );
    }
    if (axis != "horiz" && !sel.empty) return false;
    const end = atEndOfCell(view, axis, dir);
    if (end == null) return false;
    if (axis == "horiz") {
      return maybeSetSelection(
        state,
        dispatch,
        Selection.near(state.doc.resolve(sel.head + dir), dir)
      );
    } else {
      const $cell = state.doc.resolve(end);
      const $next = nextCell($cell, axis, dir);
      let newSel;
      if ($next) newSel = Selection.near($next, 1);
      else if (dir < 0)
        newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);
      else newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);
      return maybeSetSelection(state, dispatch, newSel);
    }
  };
}
function shiftArrow(axis, dir) {
  return (state, dispatch, view) => {
    if (!view) return false;
    const sel = state.selection;
    let cellSel;
    if (sel instanceof CellSelection) {
      cellSel = sel;
    } else {
      const end = atEndOfCell(view, axis, dir);
      if (end == null) return false;
      cellSel = new CellSelection(state.doc.resolve(end));
    }
    const $head = nextCell(cellSel.$headCell, axis, dir);
    if (!$head) return false;
    return maybeSetSelection(
      state,
      dispatch,
      new CellSelection(cellSel.$anchorCell, $head)
    );
  };
}
function handleTripleClick(view, pos) {
  const doc = view.state.doc, $cell = cellAround(doc.resolve(pos));
  if (!$cell) return false;
  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));
  return true;
}
function handlePaste(view, _2, slice) {
  if (!isInTable(view.state)) return false;
  let cells = pastedCells(slice);
  const sel = view.state.selection;
  if (sel instanceof CellSelection) {
    if (!cells)
      cells = {
        width: 1,
        height: 1,
        rows: [
          Fragment.from(
            fitSlice(tableNodeTypes(view.state.schema).cell, slice)
          )
        ]
      };
    const table = sel.$anchorCell.node(-1);
    const start = sel.$anchorCell.start(-1);
    const rect = TableMap.get(table).rectBetween(
      sel.$anchorCell.pos - start,
      sel.$headCell.pos - start
    );
    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);
    insertCells(view.state, view.dispatch, start, rect, cells);
    return true;
  } else if (cells) {
    const $cell = selectionCell(view.state);
    const start = $cell.start(-1);
    insertCells(
      view.state,
      view.dispatch,
      start,
      TableMap.get($cell.node(-1)).findCell($cell.pos - start),
      cells
    );
    return true;
  } else {
    return false;
  }
}
function handleMouseDown(view, startEvent) {
  var _a;
  if (startEvent.ctrlKey || startEvent.metaKey) return;
  const startDOMCell = domInCell(view, startEvent.target);
  let $anchor;
  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {
    setCellSelection(view.state.selection.$anchorCell, startEvent);
    startEvent.preventDefault();
  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {
    setCellSelection($anchor, startEvent);
    startEvent.preventDefault();
  } else if (!startDOMCell) {
    return;
  }
  function setCellSelection($anchor2, event) {
    let $head = cellUnderMouse(view, event);
    const starting = tableEditingKey.getState(view.state) == null;
    if (!$head || !inSameTable($anchor2, $head)) {
      if (starting) $head = $anchor2;
      else return;
    }
    const selection = new CellSelection($anchor2, $head);
    if (starting || !view.state.selection.eq(selection)) {
      const tr = view.state.tr.setSelection(selection);
      if (starting) tr.setMeta(tableEditingKey, $anchor2.pos);
      view.dispatch(tr);
    }
  }
  function stop() {
    view.root.removeEventListener("mouseup", stop);
    view.root.removeEventListener("dragstart", stop);
    view.root.removeEventListener("mousemove", move);
    if (tableEditingKey.getState(view.state) != null)
      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));
  }
  function move(_event) {
    const event = _event;
    const anchor = tableEditingKey.getState(view.state);
    let $anchor2;
    if (anchor != null) {
      $anchor2 = view.state.doc.resolve(anchor);
    } else if (domInCell(view, event.target) != startDOMCell) {
      $anchor2 = cellUnderMouse(view, startEvent);
      if (!$anchor2) return stop();
    }
    if ($anchor2) setCellSelection($anchor2, event);
  }
  view.root.addEventListener("mouseup", stop);
  view.root.addEventListener("dragstart", stop);
  view.root.addEventListener("mousemove", move);
}
function atEndOfCell(view, axis, dir) {
  if (!(view.state.selection instanceof TextSelection)) return null;
  const { $head } = view.state.selection;
  for (let d2 = $head.depth - 1; d2 >= 0; d2--) {
    const parent = $head.node(d2), index = dir < 0 ? $head.index(d2) : $head.indexAfter(d2);
    if (index != (dir < 0 ? 0 : parent.childCount)) return null;
    if (parent.type.spec.tableRole == "cell" || parent.type.spec.tableRole == "header_cell") {
      const cellPos = $head.before(d2);
      const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
      return view.endOfTextblock(dirStr) ? cellPos : null;
    }
  }
  return null;
}
function domInCell(view, dom) {
  for (; dom && dom != view.dom; dom = dom.parentNode) {
    if (dom.nodeName == "TD" || dom.nodeName == "TH") {
      return dom;
    }
  }
  return null;
}
function cellUnderMouse(view, event) {
  const mousePos = view.posAtCoords({
    left: event.clientX,
    top: event.clientY
  });
  if (!mousePos) return null;
  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;
}
var TableView = class {
  constructor(node, defaultCellMinWidth) {
    this.node = node;
    this.defaultCellMinWidth = defaultCellMinWidth;
    this.dom = document.createElement("div");
    this.dom.className = "tableWrapper";
    this.table = this.dom.appendChild(document.createElement("table"));
    this.table.style.setProperty(
      "--default-cell-min-width",
      `${defaultCellMinWidth}px`
    );
    this.colgroup = this.table.appendChild(document.createElement("colgroup"));
    updateColumnsOnResize(node, this.colgroup, this.table, defaultCellMinWidth);
    this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(node) {
    if (node.type != this.node.type) return false;
    this.node = node;
    updateColumnsOnResize(
      node,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    );
    return true;
  }
  ignoreMutation(record) {
    return record.type == "attributes" && (record.target == this.table || this.colgroup.contains(record.target));
  }
};
function updateColumnsOnResize(node, colgroup, table, defaultCellMinWidth, overrideCol, overrideValue) {
  var _a;
  let totalWidth = 0;
  let fixedWidth = true;
  let nextDOM = colgroup.firstChild;
  const row = node.firstChild;
  if (!row) return;
  for (let i2 = 0, col = 0; i2 < row.childCount; i2++) {
    const { colspan, colwidth } = row.child(i2).attrs;
    for (let j = 0; j < colspan; j++, col++) {
      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];
      const cssWidth = hasWidth ? hasWidth + "px" : "";
      totalWidth += hasWidth || defaultCellMinWidth;
      if (!hasWidth) fixedWidth = false;
      if (!nextDOM) {
        const col2 = document.createElement("col");
        col2.style.width = cssWidth;
        colgroup.appendChild(col2);
      } else {
        if (nextDOM.style.width != cssWidth) {
          nextDOM.style.width = cssWidth;
        }
        nextDOM = nextDOM.nextSibling;
      }
    }
  }
  while (nextDOM) {
    const after = nextDOM.nextSibling;
    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);
    nextDOM = after;
  }
  if (fixedWidth) {
    table.style.width = totalWidth + "px";
    table.style.minWidth = "";
  } else {
    table.style.width = "";
    table.style.minWidth = totalWidth + "px";
  }
}
var columnResizingPluginKey = new PluginKey(
  "tableColumnResizing"
);
function columnResizing({
  handleWidth = 5,
  cellMinWidth = 25,
  defaultCellMinWidth = 100,
  View = TableView,
  lastColumnResizable = true
} = {}) {
  const plugin = new Plugin({
    key: columnResizingPluginKey,
    state: {
      init(_2, state) {
        var _a, _b;
        const nodeViews = (_b = (_a = plugin.spec) == null ? void 0 : _a.props) == null ? void 0 : _b.nodeViews;
        const tableName = tableNodeTypes(state.schema).table.name;
        if (View && nodeViews) {
          nodeViews[tableName] = (node, view) => {
            return new View(node, defaultCellMinWidth, view);
          };
        }
        return new ResizeState(-1, false);
      },
      apply(tr, prev) {
        return prev.apply(tr);
      }
    },
    props: {
      attributes: (state) => {
        const pluginState = columnResizingPluginKey.getState(state);
        return pluginState && pluginState.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (view, event) => {
          handleMouseMove(view, event, handleWidth, lastColumnResizable);
        },
        mouseleave: (view) => {
          handleMouseLeave(view);
        },
        mousedown: (view, event) => {
          handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth);
        }
      },
      decorations: (state) => {
        const pluginState = columnResizingPluginKey.getState(state);
        if (pluginState && pluginState.activeHandle > -1) {
          return handleDecorations(state, pluginState.activeHandle);
        }
      },
      nodeViews: {}
    }
  });
  return plugin;
}
var ResizeState = class _ResizeState {
  constructor(activeHandle, dragging) {
    this.activeHandle = activeHandle;
    this.dragging = dragging;
  }
  apply(tr) {
    const state = this;
    const action = tr.getMeta(columnResizingPluginKey);
    if (action && action.setHandle != null)
      return new _ResizeState(action.setHandle, false);
    if (action && action.setDragging !== void 0)
      return new _ResizeState(state.activeHandle, action.setDragging);
    if (state.activeHandle > -1 && tr.docChanged) {
      let handle = tr.mapping.map(state.activeHandle, -1);
      if (!pointsAtCell(tr.doc.resolve(handle))) {
        handle = -1;
      }
      return new _ResizeState(handle, state.dragging);
    }
    return state;
  }
};
function handleMouseMove(view, event, handleWidth, lastColumnResizable) {
  if (!view.editable) return;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (!pluginState) return;
  if (!pluginState.dragging) {
    const target = domCellAround(event.target);
    let cell = -1;
    if (target) {
      const { left, right } = target.getBoundingClientRect();
      if (event.clientX - left <= handleWidth)
        cell = edgeCell(view, event, "left", handleWidth);
      else if (right - event.clientX <= handleWidth)
        cell = edgeCell(view, event, "right", handleWidth);
    }
    if (cell != pluginState.activeHandle) {
      if (!lastColumnResizable && cell !== -1) {
        const $cell = view.state.doc.resolve(cell);
        const table = $cell.node(-1);
        const map = TableMap.get(table);
        const tableStart = $cell.start(-1);
        const col = map.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;
        if (col == map.width - 1) {
          return;
        }
      }
      updateHandle(view, cell);
    }
  }
}
function handleMouseLeave(view) {
  if (!view.editable) return;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)
    updateHandle(view, -1);
}
function handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth) {
  var _a;
  if (!view.editable) return false;
  const win = (_a = view.dom.ownerDocument.defaultView) != null ? _a : window;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)
    return false;
  const cell = view.state.doc.nodeAt(pluginState.activeHandle);
  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);
  view.dispatch(
    view.state.tr.setMeta(columnResizingPluginKey, {
      setDragging: { startX: event.clientX, startWidth: width }
    })
  );
  function finish(event2) {
    win.removeEventListener("mouseup", finish);
    win.removeEventListener("mousemove", move);
    const pluginState2 = columnResizingPluginKey.getState(view.state);
    if (pluginState2 == null ? void 0 : pluginState2.dragging) {
      updateColumnWidth(
        view,
        pluginState2.activeHandle,
        draggedWidth(pluginState2.dragging, event2, cellMinWidth)
      );
      view.dispatch(
        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })
      );
    }
  }
  function move(event2) {
    if (!event2.which) return finish(event2);
    const pluginState2 = columnResizingPluginKey.getState(view.state);
    if (!pluginState2) return;
    if (pluginState2.dragging) {
      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);
      displayColumnWidth(
        view,
        pluginState2.activeHandle,
        dragged,
        defaultCellMinWidth
      );
    }
  }
  displayColumnWidth(
    view,
    pluginState.activeHandle,
    width,
    defaultCellMinWidth
  );
  win.addEventListener("mouseup", finish);
  win.addEventListener("mousemove", move);
  event.preventDefault();
  return true;
}
function currentColWidth(view, cellPos, { colspan, colwidth }) {
  const width = colwidth && colwidth[colwidth.length - 1];
  if (width) return width;
  const dom = view.domAtPos(cellPos);
  const node = dom.node.childNodes[dom.offset];
  let domWidth = node.offsetWidth, parts = colspan;
  if (colwidth) {
    for (let i2 = 0; i2 < colspan; i2++)
      if (colwidth[i2]) {
        domWidth -= colwidth[i2];
        parts--;
      }
  }
  return domWidth / parts;
}
function domCellAround(target) {
  while (target && target.nodeName != "TD" && target.nodeName != "TH")
    target = target.classList && target.classList.contains("ProseMirror") ? null : target.parentNode;
  return target;
}
function edgeCell(view, event, side, handleWidth) {
  const offset = side == "right" ? -handleWidth : handleWidth;
  const found = view.posAtCoords({
    left: event.clientX + offset,
    top: event.clientY
  });
  if (!found) return -1;
  const { pos } = found;
  const $cell = cellAround(view.state.doc.resolve(pos));
  if (!$cell) return -1;
  if (side == "right") return $cell.pos;
  const map = TableMap.get($cell.node(-1)), start = $cell.start(-1);
  const index = map.map.indexOf($cell.pos - start);
  return index % map.width == 0 ? -1 : start + map.map[index - 1];
}
function draggedWidth(dragging, event, resizeMinWidth) {
  const offset = event.clientX - dragging.startX;
  return Math.max(resizeMinWidth, dragging.startWidth + offset);
}
function updateHandle(view, value) {
  view.dispatch(
    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })
  );
}
function updateColumnWidth(view, cell, width) {
  const $cell = view.state.doc.resolve(cell);
  const table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);
  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
  const tr = view.state.tr;
  for (let row = 0; row < map.height; row++) {
    const mapIndex = row * map.width + col;
    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue;
    const pos = map.map[mapIndex];
    const attrs = table.nodeAt(pos).attrs;
    const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);
    if (attrs.colwidth && attrs.colwidth[index] == width) continue;
    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);
    colwidth[index] = width;
    tr.setNodeMarkup(start + pos, null, { ...attrs, colwidth });
  }
  if (tr.docChanged) view.dispatch(tr);
}
function displayColumnWidth(view, cell, width, defaultCellMinWidth) {
  const $cell = view.state.doc.resolve(cell);
  const table = $cell.node(-1), start = $cell.start(-1);
  const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
  let dom = view.domAtPos($cell.start(-1)).node;
  while (dom && dom.nodeName != "TABLE") {
    dom = dom.parentNode;
  }
  if (!dom) return;
  updateColumnsOnResize(
    table,
    dom.firstChild,
    dom,
    defaultCellMinWidth,
    col,
    width
  );
}
function zeroes(n2) {
  return Array(n2).fill(0);
}
function handleDecorations(state, cell) {
  var _a;
  const decorations = [];
  const $cell = state.doc.resolve(cell);
  const table = $cell.node(-1);
  if (!table) {
    return DecorationSet.empty;
  }
  const map = TableMap.get(table);
  const start = $cell.start(-1);
  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
  for (let row = 0; row < map.height; row++) {
    const index = col + row * map.width;
    if ((col == map.width - 1 || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index] != map.map[index - map.width])) {
      const cellPos = map.map[index];
      const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;
      const dom = document.createElement("div");
      dom.className = "column-resize-handle";
      if ((_a = columnResizingPluginKey.getState(state)) == null ? void 0 : _a.dragging) {
        decorations.push(
          Decoration.node(
            start + cellPos,
            start + cellPos + table.nodeAt(cellPos).nodeSize,
            {
              class: "column-resize-dragging"
            }
          )
        );
      }
      decorations.push(Decoration.widget(pos, dom));
    }
  }
  return DecorationSet.create(state.doc, decorations);
}
function tableEditing({
  allowTableNodeSelection = false
} = {}) {
  return new Plugin({
    key: tableEditingKey,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(tr, cur) {
        const set = tr.getMeta(tableEditingKey);
        if (set != null) return set == -1 ? null : set;
        if (cur == null || !tr.docChanged) return cur;
        const { deleted, pos } = tr.mapping.mapResult(cur);
        return deleted ? null : pos;
      }
    },
    props: {
      decorations: drawCellSelection,
      handleDOMEvents: {
        mousedown: handleMouseDown
      },
      createSelectionBetween(view) {
        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;
      },
      handleTripleClick,
      handleKeyDown,
      handlePaste
    },
    appendTransaction(_2, oldState, state) {
      return normalizeSelection(
        state,
        fixTables(state, oldState),
        allowTableNodeSelection
      );
    }
  });
}

// node_modules/@tiptap/extension-table/dist/index.js
var TableCell = Node3.create({
  name: "tableCell",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (element) => {
          const colwidth = element.getAttribute("colwidth");
          const value = colwidth ? colwidth.split(",").map((width) => parseInt(width, 10)) : null;
          return value;
        }
      }
    };
  },
  tableRole: "cell",
  isolating: true,
  parseHTML() {
    return [{ tag: "td" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["td", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  }
});
var TableHeader = Node3.create({
  name: "tableHeader",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (element) => {
          const colwidth = element.getAttribute("colwidth");
          const value = colwidth ? colwidth.split(",").map((width) => parseInt(width, 10)) : null;
          return value;
        }
      }
    };
  },
  tableRole: "header_cell",
  isolating: true,
  parseHTML() {
    return [{ tag: "th" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["th", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  }
});
var TableRow = Node3.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  parseHTML() {
    return [{ tag: "tr" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["tr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  }
});
function getColStyleDeclaration(minWidth, width) {
  if (width) {
    return ["width", `${Math.max(width, minWidth)}px`];
  }
  return ["min-width", `${minWidth}px`];
}
function updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {
  var _a;
  let totalWidth = 0;
  let fixedWidth = true;
  let nextDOM = colgroup.firstChild;
  const row = node.firstChild;
  if (row !== null) {
    for (let i2 = 0, col = 0; i2 < row.childCount; i2 += 1) {
      const { colspan, colwidth } = row.child(i2).attrs;
      for (let j = 0; j < colspan; j += 1, col += 1) {
        const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];
        const cssWidth = hasWidth ? `${hasWidth}px` : "";
        totalWidth += hasWidth || cellMinWidth;
        if (!hasWidth) {
          fixedWidth = false;
        }
        if (!nextDOM) {
          const colElement = document.createElement("col");
          const [propertyKey, propertyValue] = getColStyleDeclaration(cellMinWidth, hasWidth);
          colElement.style.setProperty(propertyKey, propertyValue);
          colgroup.appendChild(colElement);
        } else {
          if (nextDOM.style.width !== cssWidth) {
            const [propertyKey, propertyValue] = getColStyleDeclaration(cellMinWidth, hasWidth);
            nextDOM.style.setProperty(propertyKey, propertyValue);
          }
          nextDOM = nextDOM.nextSibling;
        }
      }
    }
  }
  while (nextDOM) {
    const after = nextDOM.nextSibling;
    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);
    nextDOM = after;
  }
  if (fixedWidth) {
    table.style.width = `${totalWidth}px`;
    table.style.minWidth = "";
  } else {
    table.style.width = "";
    table.style.minWidth = `${totalWidth}px`;
  }
}
var TableView2 = class {
  constructor(node, cellMinWidth) {
    this.node = node;
    this.cellMinWidth = cellMinWidth;
    this.dom = document.createElement("div");
    this.dom.className = "tableWrapper";
    this.table = this.dom.appendChild(document.createElement("table"));
    this.colgroup = this.table.appendChild(document.createElement("colgroup"));
    updateColumns(node, this.colgroup, this.table, cellMinWidth);
    this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(node) {
    if (node.type !== this.node.type) {
      return false;
    }
    this.node = node;
    updateColumns(node, this.colgroup, this.table, this.cellMinWidth);
    return true;
  }
  ignoreMutation(mutation) {
    return mutation.type === "attributes" && (mutation.target === this.table || this.colgroup.contains(mutation.target));
  }
};
function createColGroup(node, cellMinWidth, overrideCol, overrideValue) {
  let totalWidth = 0;
  let fixedWidth = true;
  const cols = [];
  const row = node.firstChild;
  if (!row) {
    return {};
  }
  for (let i2 = 0, col = 0; i2 < row.childCount; i2 += 1) {
    const { colspan, colwidth } = row.child(i2).attrs;
    for (let j = 0; j < colspan; j += 1, col += 1) {
      const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];
      totalWidth += hasWidth || cellMinWidth;
      if (!hasWidth) {
        fixedWidth = false;
      }
      const [property, value] = getColStyleDeclaration(cellMinWidth, hasWidth);
      cols.push(["col", { style: `${property}: ${value}` }]);
    }
  }
  const tableWidth = fixedWidth ? `${totalWidth}px` : "";
  const tableMinWidth = fixedWidth ? "" : `${totalWidth}px`;
  const colgroup = ["colgroup", {}, ...cols];
  return { colgroup, tableWidth, tableMinWidth };
}
function createCell(cellType, cellContent) {
  if (cellContent) {
    return cellType.createChecked(null, cellContent);
  }
  return cellType.createAndFill();
}
function getTableNodeTypes(schema) {
  if (schema.cached.tableNodeTypes) {
    return schema.cached.tableNodeTypes;
  }
  const roles = {};
  Object.keys(schema.nodes).forEach((type) => {
    const nodeType = schema.nodes[type];
    if (nodeType.spec.tableRole) {
      roles[nodeType.spec.tableRole] = nodeType;
    }
  });
  schema.cached.tableNodeTypes = roles;
  return roles;
}
function createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {
  const types = getTableNodeTypes(schema);
  const headerCells = [];
  const cells = [];
  for (let index = 0; index < colsCount; index += 1) {
    const cell = createCell(types.cell, cellContent);
    if (cell) {
      cells.push(cell);
    }
    if (withHeaderRow) {
      const headerCell = createCell(types.header_cell, cellContent);
      if (headerCell) {
        headerCells.push(headerCell);
      }
    }
  }
  const rows = [];
  for (let index = 0; index < rowsCount; index += 1) {
    rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells));
  }
  return types.table.createChecked(null, rows);
}
function isCellSelection(value) {
  return value instanceof CellSelection;
}
var deleteTableWhenAllCellsSelected = ({ editor }) => {
  const { selection } = editor.state;
  if (!isCellSelection(selection)) {
    return false;
  }
  let cellCount = 0;
  const table = findParentNodeClosestToPos(selection.ranges[0].$from, (node) => {
    return node.type.name === "table";
  });
  table == null ? void 0 : table.node.descendants((node) => {
    if (node.type.name === "table") {
      return false;
    }
    if (["tableCell", "tableHeader"].includes(node.type.name)) {
      cellCount += 1;
    }
  });
  const allCellsSelected = cellCount === selection.ranges.length;
  if (!allCellsSelected) {
    return false;
  }
  editor.commands.deleteTable();
  return true;
};
var Table2 = Node3.create({
  name: "table",
  // @ts-ignore
  addOptions() {
    return {
      HTMLAttributes: {},
      resizable: false,
      handleWidth: 5,
      cellMinWidth: 25,
      // TODO: fix
      View: TableView2,
      lastColumnResizable: true,
      allowTableNodeSelection: false
    };
  },
  content: "tableRow+",
  tableRole: "table",
  isolating: true,
  group: "block",
  parseHTML() {
    return [{ tag: "table" }];
  },
  renderHTML({ node, HTMLAttributes }) {
    const { colgroup, tableWidth, tableMinWidth } = createColGroup(node, this.options.cellMinWidth);
    const table = [
      "table",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {
        style: tableWidth ? `width: ${tableWidth}` : `min-width: ${tableMinWidth}`
      }),
      colgroup,
      ["tbody", 0]
    ];
    return table;
  },
  addCommands() {
    return {
      insertTable: ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr, dispatch, editor }) => {
        const node = createTable(editor.schema, rows, cols, withHeaderRow);
        if (dispatch) {
          const offset = tr.selection.from + 1;
          tr.replaceSelectionWith(node).scrollIntoView().setSelection(TextSelection.near(tr.doc.resolve(offset)));
        }
        return true;
      },
      addColumnBefore: () => ({ state, dispatch }) => {
        return addColumnBefore(state, dispatch);
      },
      addColumnAfter: () => ({ state, dispatch }) => {
        return addColumnAfter(state, dispatch);
      },
      deleteColumn: () => ({ state, dispatch }) => {
        return deleteColumn(state, dispatch);
      },
      addRowBefore: () => ({ state, dispatch }) => {
        return addRowBefore(state, dispatch);
      },
      addRowAfter: () => ({ state, dispatch }) => {
        return addRowAfter(state, dispatch);
      },
      deleteRow: () => ({ state, dispatch }) => {
        return deleteRow(state, dispatch);
      },
      deleteTable: () => ({ state, dispatch }) => {
        return deleteTable(state, dispatch);
      },
      mergeCells: () => ({ state, dispatch }) => {
        return mergeCells(state, dispatch);
      },
      splitCell: () => ({ state, dispatch }) => {
        return splitCell(state, dispatch);
      },
      toggleHeaderColumn: () => ({ state, dispatch }) => {
        return toggleHeader("column")(state, dispatch);
      },
      toggleHeaderRow: () => ({ state, dispatch }) => {
        return toggleHeader("row")(state, dispatch);
      },
      toggleHeaderCell: () => ({ state, dispatch }) => {
        return toggleHeaderCell(state, dispatch);
      },
      mergeOrSplit: () => ({ state, dispatch }) => {
        if (mergeCells(state, dispatch)) {
          return true;
        }
        return splitCell(state, dispatch);
      },
      setCellAttribute: (name, value) => ({ state, dispatch }) => {
        return setCellAttr(name, value)(state, dispatch);
      },
      goToNextCell: () => ({ state, dispatch }) => {
        return goToNextCell(1)(state, dispatch);
      },
      goToPreviousCell: () => ({ state, dispatch }) => {
        return goToNextCell(-1)(state, dispatch);
      },
      fixTables: () => ({ state, dispatch }) => {
        if (dispatch) {
          fixTables(state);
        }
        return true;
      },
      setCellSelection: (position) => ({ tr, dispatch }) => {
        if (dispatch) {
          const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell);
          tr.setSelection(selection);
        }
        return true;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => {
        if (this.editor.commands.goToNextCell()) {
          return true;
        }
        if (!this.editor.can().addRowAfter()) {
          return false;
        }
        return this.editor.chain().addRowAfter().goToNextCell().run();
      },
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: deleteTableWhenAllCellsSelected,
      "Mod-Backspace": deleteTableWhenAllCellsSelected,
      Delete: deleteTableWhenAllCellsSelected,
      "Mod-Delete": deleteTableWhenAllCellsSelected
    };
  },
  addProseMirrorPlugins() {
    const isResizable = this.options.resizable && this.editor.isEditable;
    return [
      ...isResizable ? [
        columnResizing({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          defaultCellMinWidth: this.options.cellMinWidth,
          View: this.options.View,
          lastColumnResizable: this.options.lastColumnResizable
        })
      ] : [],
      tableEditing({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(extension) {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      tableRole: callOrReturn(getExtensionField(extension, "tableRole", context))
    };
  }
});
var TableKit = Extension.create({
  name: "tableKit",
  addExtensions() {
    const extensions = [];
    if (this.options.table !== false) {
      extensions.push(Table2.configure(this.options.table));
    }
    if (this.options.tableCell !== false) {
      extensions.push(TableCell.configure(this.options.tableCell));
    }
    if (this.options.tableHeader !== false) {
      extensions.push(TableHeader.configure(this.options.tableHeader));
    }
    if (this.options.tableRow !== false) {
      extensions.push(TableRow.configure(this.options.tableRow));
    }
    return extensions;
  }
});

// node_modules/mui-tiptap/dist/esm/extensions/TableImproved.js
var TableImproved = Table2.extend({
  // This function is taken directly from
  // https://github.com/ueberdosis/tiptap/blob/31c3a9aad9eb37f445eadcd27135611291178ca6/packages/extension-table/src/table.ts#L229-L245,
  // except overridden to always include `columnResizing`, even if `editable` is
  // false. We update our RichTextContent styles so that the table resizing
  // controls are not visible when `editable` is false, and since the editor
  // itself has contenteditable=false, the table will remain read-only. By doing
  // this, we can ensure that column widths are preserved when editable is false
  // (otherwise any dragged column widths are ignored when editable is false, as
  // reported here https://github.com/ueberdosis/tiptap/issues/2041). Moreover,
  // we do not need any hacky workarounds to ensure that the necessary table
  // extensions are reset when the editable state changes (since the resizable
  // extension will be omitted if not initially editable, or wouldn't be removed
  // if initially not editable if we relied on it being removed, as reported
  // here https://github.com/ueberdosis/tiptap/issues/2301, which was not
  // resolved despite what the OP there later said).
  addProseMirrorPlugins() {
    const isResizable = this.options.resizable;
    return [
      ...isResizable ? [
        columnResizing({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          View: this.options.View,
          lastColumnResizable: this.options.lastColumnResizable
        })
      ] : [],
      tableEditing({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  }
});
var TableImproved_default = TableImproved;
export {
  ColorPicker,
  ColorPickerPopper,
  ColorPickerPopperBody,
  ColorSwatchButton,
  ControlledBubbleMenu,
  DebounceRender,
  FontSize_default as FontSize,
  HeadingWithAnchor_default as HeadingWithAnchor,
  LinkBubbleMenu,
  LinkBubbleMenuHandler_default as LinkBubbleMenuHandler,
  MenuBar,
  MenuButton,
  MenuButtonAddImage,
  MenuButtonAddTable,
  MenuButtonAlignCenter,
  MenuButtonAlignJustify,
  MenuButtonAlignLeft,
  MenuButtonAlignRight,
  MenuButtonBlockquote,
  MenuButtonBold,
  MenuButtonBulletedList,
  MenuButtonCode,
  MenuButtonCodeBlock,
  MenuButtonColorPicker,
  MenuButtonEditLink,
  MenuButtonHighlightColor,
  MenuButtonHighlightToggle,
  MenuButtonHorizontalRule,
  MenuButtonImageUpload,
  MenuButtonIndent,
  MenuButtonItalic,
  MenuButtonOrderedList,
  MenuButtonRedo,
  MenuButtonRemoveFormatting,
  MenuButtonStrikethrough,
  MenuButtonSubscript,
  MenuButtonSuperscript,
  MenuButtonTaskList,
  MenuButtonTextColor,
  MenuButtonTooltip,
  MenuButtonUnderline,
  MenuButtonUndo,
  MenuButtonUnindent,
  MenuControlsContainer,
  MenuDivider,
  MenuSelect,
  MenuSelectFontFamily,
  MenuSelectFontSize,
  MenuSelectHeading,
  MenuSelectTextAlign,
  ResizableImage_default as ResizableImage,
  RichTextContent,
  RichTextEditor_default as RichTextEditor,
  RichTextEditorContext,
  RichTextEditorProvider,
  RichTextField,
  RichTextReadOnly,
  TableBubbleMenu,
  TableImproved_default as TableImproved,
  TableMenuControls,
  Z_INDEXES,
  colorToHex,
  formatHref,
  getAttributesForEachSelected,
  getAttributesForMarks,
  getAttributesForNodes,
  getEditorStyles,
  getImageBackgroundColorStyles,
  getModShortcutKey,
  insertImages,
  isMac,
  isTouchDevice,
  keymapPluginFactory,
  scrollToCurrentHeadingAnchor,
  slugify,
  truncateMiddle,
  useDebouncedFocus,
  useEditorOnEditableUpdate,
  useKeyDown,
  useRichTextEditorContext
};
/*! Bundled license information:

encodeurl/index.js:
  (*!
   * encodeurl
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=mui-tiptap.js.map
